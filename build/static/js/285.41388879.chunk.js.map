{"version":3,"file":"static/js/285.41388879.chunk.js","mappings":"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","sources":["../node_modules/three-bvh-csg/src/core/constants.js","../node_modules/three-mesh-bvh/src/core/Constants.js","../node_modules/three-mesh-bvh/src/core/build/geometryUtils.js","../node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js","../node_modules/three-mesh-bvh/src/core/build/computeBoundsUtils.js","../node_modules/three-mesh-bvh/src/core/build/splitUtils.js","../node_modules/three-mesh-bvh/src/core/MeshBVHNode.js","../node_modules/three-mesh-bvh/src/core/build/sortUtils.generated.js","../node_modules/three-mesh-bvh/src/core/build/sortUtils_indirect.generated.js","../node_modules/three-mesh-bvh/src/core/build/buildTree.js","../node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js","../node_modules/three-mesh-bvh/src/math/MathUtilities.js","../node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js","../node_modules/three-mesh-bvh/src/math/OrientedBox.js","../node_modules/three-mesh-bvh/src/utils/PrimitivePool.js","../node_modules/three-mesh-bvh/src/utils/ExtendedTrianglePool.js","../node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js","../node_modules/three-mesh-bvh/src/core/utils/BufferStack.js","../node_modules/three-mesh-bvh/src/core/cast/shapecast.js","../node_modules/three-mesh-bvh/src/core/cast/closestPointToPoint.js","../node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js","../node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js","../node_modules/three-mesh-bvh/src/core/utils/iterationUtils.generated.js","../node_modules/three-mesh-bvh/src/core/cast/refit.generated.js","../node_modules/three-mesh-bvh/src/core/utils/intersectUtils.js","../node_modules/three-mesh-bvh/src/core/cast/raycast.generated.js","../node_modules/three-mesh-bvh/src/core/cast/raycastFirst.generated.js","../node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry.generated.js","../node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry.generated.js","../node_modules/three-mesh-bvh/src/core/utils/iterationUtils_indirect.generated.js","../node_modules/three-mesh-bvh/src/core/cast/refit_indirect.generated.js","../node_modules/three-mesh-bvh/src/core/cast/raycast_indirect.generated.js","../node_modules/three-mesh-bvh/src/core/cast/raycastFirst_indirect.generated.js","../node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry_indirect.generated.js","../node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry_indirect.generated.js","../node_modules/three-mesh-bvh/src/core/cast/bvhcast.js","../node_modules/three-mesh-bvh/src/core/MeshBVH.js","../node_modules/three-mesh-bvh/src/utils/BufferUtils.js","../node_modules/three-bvh-csg/src/core/utils/hashUtils.js","../node_modules/three-bvh-csg/src/core/utils/geometryUtils.js","../node_modules/three-bvh-csg/src/core/utils/halfEdgeUtils.js","../node_modules/three-bvh-csg/src/core/utils/RaySet.js","../node_modules/three-bvh-csg/src/core/utils/computeDisjointEdges.js","../node_modules/three-bvh-csg/src/core/HalfEdgeMap.js","../node_modules/three-bvh-csg/src/core/Brush.js","../node_modules/three-bvh-csg/src/core/utils/triangleUtils.js","../node_modules/three-bvh-csg/src/core/TriangleSplitter.js","../node_modules/three-bvh-csg/src/core/TypeBackedArray.js","../node_modules/three-bvh-csg/src/core/TypedAttributeData.js","../node_modules/three-bvh-csg/src/core/IntersectionMap.js","../node_modules/three-bvh-csg/src/core/operations/operationsUtils.js","../node_modules/three-bvh-csg/src/core/debug/OperationDebugData.js","../node_modules/three-bvh-csg/src/core/operations/operations.js","../node_modules/three-bvh-csg/src/core/Evaluator.js","../node_modules/@react-three/csg/dist/index.js","../node_modules/@react-three/drei/core/shaderMaterial.js","../node_modules/@react-three/drei/materials/DiscardMaterial.js","../node_modules/@react-three/drei/core/MeshTransmissionMaterial.js","../node_modules/src/objects/Sky.ts","../node_modules/@react-three/drei/core/Sky.js","../node_modules/src/_polyfill/constants.ts","../node_modules/three/src/loaders/Cache.js","../node_modules/three/src/loaders/LoadingManager.js","../node_modules/three/src/loaders/Loader.js","../node_modules/three/src/utils.js","../node_modules/three/src/loaders/ImageLoader.js","../node_modules/three/src/core/EventDispatcher.js","../node_modules/three/src/constants.js","../node_modules/three/src/math/MathUtils.js","../node_modules/three/src/math/Vector2.js","../node_modules/three/src/math/Matrix3.js","../node_modules/three/src/math/ColorManagement.js","../node_modules/three/src/extras/ImageUtils.js","../node_modules/three/src/textures/Source.js","../node_modules/three/src/textures/Texture.js","../node_modules/three/src/loaders/TextureLoader.js"],"sourcesContent":["export const ADDITION = 0;\nexport const SUBTRACTION = 1;\nexport const REVERSE_SUBTRACTION = 2;\nexport const INTERSECTION = 3;\nexport const DIFFERENCE = 4;\n\n// guaranteed non manifold results\nexport const HOLLOW_SUBTRACTION = 5;\nexport const HOLLOW_INTERSECTION = 6;\n","// Split strategy constants\nexport const CENTER = 0;\nexport const AVERAGE = 1;\nexport const SAH = 2;\n\n// Traversal constants\nexport const NOT_INTERSECTED = 0;\nexport const INTERSECTED = 1;\nexport const CONTAINED = 2;\n\n// SAH cost constants\n// TODO: hone these costs more. The relative difference between them should be the\n// difference in measured time to perform a triangle intersection vs traversing\n// bounds.\nexport const TRIANGLE_INTERSECT_COST = 1.25;\nexport const TRAVERSAL_COST = 1;\n\n\n// Build constants\nexport const BYTES_PER_NODE = 6 * 4 + 4 + 4;\nexport const IS_LEAFNODE_FLAG = 0xFFFF;\n\n// EPSILON for computing floating point error during build\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\nexport const FLOAT32_EPSILON = Math.pow( 2, - 24 );\n\nexport const SKIP_GENERATION = Symbol( 'SKIP_GENERATION' );\n","import { BufferAttribute } from 'three';\n\nexport function getVertexCount( geo ) {\n\n\treturn geo.index ? geo.index.count : geo.attributes.position.count;\n\n}\n\nexport function getTriCount( geo ) {\n\n\treturn getVertexCount( geo ) / 3;\n\n}\n\nexport function getIndexArray( vertexCount, BufferConstructor = ArrayBuffer ) {\n\n\tif ( vertexCount > 65535 ) {\n\n\t\treturn new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\n\n\t} else {\n\n\t\treturn new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\n\n\t}\n\n}\n\n// ensures that an index is present on the geometry\nexport function ensureIndex( geo, options ) {\n\n\tif ( ! geo.index ) {\n\n\t\tconst vertexCount = geo.attributes.position.count;\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\tconst index = getIndexArray( vertexCount, BufferConstructor );\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\n\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tindex[ i ] = i;\n\n\t\t}\n\n\t}\n\n}\n\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nexport function getFullGeometryRange( geo ) {\n\n\tconst triCount = getTriCount( geo );\n\tconst drawRange = geo.drawRange;\n\tconst start = drawRange.start / 3;\n\tconst end = ( drawRange.start + drawRange.count ) / 3;\n\n\tconst offset = Math.max( 0, start );\n\tconst count = Math.min( triCount, end ) - offset;\n\treturn [ {\n\t\toffset: Math.floor( offset ),\n\t\tcount: Math.floor( count ),\n\t} ];\n\n}\n\nexport function getRootIndexRanges( geo ) {\n\n\tif ( ! geo.groups || ! geo.groups.length ) {\n\n\t\treturn getFullGeometryRange( geo );\n\n\t}\n\n\tconst ranges = [];\n\tconst rangeBoundaries = new Set();\n\n\tconst drawRange = geo.drawRange;\n\tconst drawRangeStart = drawRange.start / 3;\n\tconst drawRangeEnd = ( drawRange.start + drawRange.count ) / 3;\n\tfor ( const group of geo.groups ) {\n\n\t\tconst groupStart = group.start / 3;\n\t\tconst groupEnd = ( group.start + group.count ) / 3;\n\t\trangeBoundaries.add( Math.max( drawRangeStart, groupStart ) );\n\t\trangeBoundaries.add( Math.min( drawRangeEnd, groupEnd ) );\n\n\t}\n\n\n\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\n\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\n\n\t\tconst start = sortedBoundaries[ i ];\n\t\tconst end = sortedBoundaries[ i + 1 ];\n\n\t\tranges.push( {\n\t\t\toffset: Math.floor( start ),\n\t\t\tcount: Math.floor( end - start ),\n\t\t} );\n\n\t}\n\n\treturn ranges;\n\n}\n\nexport function hasGroupGaps( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\treturn false;\n\n\t}\n\n\tconst vertexCount = getTriCount( geometry );\n\tconst groups = getRootIndexRanges( geometry )\n\t\t.sort( ( a, b ) => a.offset - b.offset );\n\n\tconst finalGroup = groups[ groups.length - 1 ];\n\tfinalGroup.count = Math.min( vertexCount - finalGroup.offset, finalGroup.count );\n\n\tlet total = 0;\n\tgroups.forEach( ( { count } ) => total += count );\n\treturn vertexCount !== total;\n\n}\n","export function arrayToBox( nodeIndex32, array, target ) {\n\n\ttarget.min.x = array[ nodeIndex32 ];\n\ttarget.min.y = array[ nodeIndex32 + 1 ];\n\ttarget.min.z = array[ nodeIndex32 + 2 ];\n\n\ttarget.max.x = array[ nodeIndex32 + 3 ];\n\ttarget.max.y = array[ nodeIndex32 + 4 ];\n\ttarget.max.z = array[ nodeIndex32 + 5 ];\n\n\treturn target;\n\n}\n\nexport function makeEmptyBounds( target ) {\n\n\ttarget[ 0 ] = target[ 1 ] = target[ 2 ] = Infinity;\n\ttarget[ 3 ] = target[ 4 ] = target[ 5 ] = - Infinity;\n\n}\n\nexport function getLongestEdgeIndex( bounds ) {\n\n\tlet splitDimIdx = - 1;\n\tlet splitDist = - Infinity;\n\n\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\tconst dist = bounds[ i + 3 ] - bounds[ i ];\n\t\tif ( dist > splitDist ) {\n\n\t\t\tsplitDist = dist;\n\t\t\tsplitDimIdx = i;\n\n\t\t}\n\n\t}\n\n\treturn splitDimIdx;\n\n}\n\n// copies bounds a into bounds b\nexport function copyBounds( source, target ) {\n\n\ttarget.set( source );\n\n}\n\n// sets bounds target to the union of bounds a and b\nexport function unionBounds( a, b, target ) {\n\n\tlet aVal, bVal;\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst d3 = d + 3;\n\n\t\t// set the minimum values\n\t\taVal = a[ d ];\n\t\tbVal = b[ d ];\n\t\ttarget[ d ] = aVal < bVal ? aVal : bVal;\n\n\t\t// set the max values\n\t\taVal = a[ d3 ];\n\t\tbVal = b[ d3 ];\n\t\ttarget[ d3 ] = aVal > bVal ? aVal : bVal;\n\n\t}\n\n}\n\n// expands the given bounds by the provided triangle bounds\nexport function expandByTriangleBounds( startIndex, triangleBounds, bounds ) {\n\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst tCenter = triangleBounds[ startIndex + 2 * d ];\n\t\tconst tHalf = triangleBounds[ startIndex + 2 * d + 1 ];\n\n\t\tconst tMin = tCenter - tHalf;\n\t\tconst tMax = tCenter + tHalf;\n\n\t\tif ( tMin < bounds[ d ] ) {\n\n\t\t\tbounds[ d ] = tMin;\n\n\t\t}\n\n\t\tif ( tMax > bounds[ d + 3 ] ) {\n\n\t\t\tbounds[ d + 3 ] = tMax;\n\n\t\t}\n\n\t}\n\n}\n\n// compute bounds surface area\nexport function computeSurfaceArea( bounds ) {\n\n\tconst d0 = bounds[ 3 ] - bounds[ 0 ];\n\tconst d1 = bounds[ 4 ] - bounds[ 1 ];\n\tconst d2 = bounds[ 5 ] - bounds[ 2 ];\n\n\treturn 2 * ( d0 * d1 + d1 * d2 + d2 * d0 );\n\n}\n","import { FLOAT32_EPSILON } from '../Constants.js';\nimport { makeEmptyBounds } from '../../utils/ArrayBoxUtilities.js';\nimport { getTriCount } from './geometryUtils.js';\n\n// computes the union of the bounds of all of the given triangles and puts the resulting box in target. If\n// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.\n// These are computed together to avoid redundant accesses to bounds array.\nexport function getBounds( triangleBounds, offset, count, target, centroidTarget = null ) {\n\n\tlet minx = Infinity;\n\tlet miny = Infinity;\n\tlet minz = Infinity;\n\tlet maxx = - Infinity;\n\tlet maxy = - Infinity;\n\tlet maxz = - Infinity;\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tconst includeCentroid = centroidTarget !== null;\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tconst hx = triangleBounds[ i + 1 ];\n\t\tconst lx = cx - hx;\n\t\tconst rx = cx + hx;\n\t\tif ( lx < minx ) minx = lx;\n\t\tif ( rx > maxx ) maxx = rx;\n\t\tif ( includeCentroid && cx < cminx ) cminx = cx;\n\t\tif ( includeCentroid && cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tconst hy = triangleBounds[ i + 3 ];\n\t\tconst ly = cy - hy;\n\t\tconst ry = cy + hy;\n\t\tif ( ly < miny ) miny = ly;\n\t\tif ( ry > maxy ) maxy = ry;\n\t\tif ( includeCentroid && cy < cminy ) cminy = cy;\n\t\tif ( includeCentroid && cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tconst hz = triangleBounds[ i + 5 ];\n\t\tconst lz = cz - hz;\n\t\tconst rz = cz + hz;\n\t\tif ( lz < minz ) minz = lz;\n\t\tif ( rz > maxz ) maxz = rz;\n\t\tif ( includeCentroid && cz < cminz ) cminz = cz;\n\t\tif ( includeCentroid && cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\ttarget[ 0 ] = minx;\n\ttarget[ 1 ] = miny;\n\ttarget[ 2 ] = minz;\n\n\ttarget[ 3 ] = maxx;\n\ttarget[ 4 ] = maxy;\n\ttarget[ 5 ] = maxz;\n\n\tif ( includeCentroid ) {\n\n\t\tcentroidTarget[ 0 ] = cminx;\n\t\tcentroidTarget[ 1 ] = cminy;\n\t\tcentroidTarget[ 2 ] = cminz;\n\n\t\tcentroidTarget[ 3 ] = cmaxx;\n\t\tcentroidTarget[ 4 ] = cmaxy;\n\t\tcentroidTarget[ 5 ] = cmaxz;\n\n\t}\n\n}\n\n// A stand alone function for retrieving the centroid bounds.\nexport function getCentroidBounds( triangleBounds, offset, count, centroidTarget ) {\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tif ( cx < cminx ) cminx = cx;\n\t\tif ( cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tif ( cy < cminy ) cminy = cy;\n\t\tif ( cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tif ( cz < cminz ) cminz = cz;\n\t\tif ( cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\tcentroidTarget[ 0 ] = cminx;\n\tcentroidTarget[ 1 ] = cminy;\n\tcentroidTarget[ 2 ] = cminz;\n\n\tcentroidTarget[ 3 ] = cmaxx;\n\tcentroidTarget[ 4 ] = cmaxy;\n\tcentroidTarget[ 5 ] = cmaxz;\n\n}\n\n\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\nexport function computeTriangleBounds( geo, fullBounds ) {\n\n\t// clear the bounds to empty\n\tmakeEmptyBounds( fullBounds );\n\n\tconst posAttr = geo.attributes.position;\n\tconst index = geo.index ? geo.index.array : null;\n\tconst triCount = getTriCount( geo );\n\tconst triangleBounds = new Float32Array( triCount * 6 );\n\tconst normalized = posAttr.normalized;\n\n\t// used for non-normalized positions\n\tconst posArr = posAttr.array;\n\n\t// support for an interleaved position buffer\n\tconst bufferOffset = posAttr.offset || 0;\n\tlet stride = 3;\n\tif ( posAttr.isInterleavedBufferAttribute ) {\n\n\t\tstride = posAttr.data.stride;\n\n\t}\n\n\t// used for normalized positions\n\tconst getters = [ 'getX', 'getY', 'getZ' ];\n\n\tfor ( let tri = 0; tri < triCount; tri ++ ) {\n\n\t\tconst tri3 = tri * 3;\n\t\tconst tri6 = tri * 6;\n\n\t\tlet ai = tri3 + 0;\n\t\tlet bi = tri3 + 1;\n\t\tlet ci = tri3 + 2;\n\n\t\tif ( index ) {\n\n\t\t\tai = index[ ai ];\n\t\t\tbi = index[ bi ];\n\t\t\tci = index[ ci ];\n\n\t\t}\n\n\t\t// we add the stride and offset here since we access the array directly\n\t\t// below for the sake of performance\n\t\tif ( ! normalized ) {\n\n\t\t\tai = ai * stride + bufferOffset;\n\t\t\tbi = bi * stride + bufferOffset;\n\t\t\tci = ci * stride + bufferOffset;\n\n\t\t}\n\n\t\tfor ( let el = 0; el < 3; el ++ ) {\n\n\t\t\tlet a, b, c;\n\n\t\t\tif ( normalized ) {\n\n\t\t\t\ta = posAttr[ getters[ el ] ]( ai );\n\t\t\t\tb = posAttr[ getters[ el ] ]( bi );\n\t\t\t\tc = posAttr[ getters[ el ] ]( ci );\n\n\t\t\t} else {\n\n\t\t\t\ta = posArr[ ai + el ];\n\t\t\t\tb = posArr[ bi + el ];\n\t\t\t\tc = posArr[ ci + el ];\n\n\t\t\t}\n\n\t\t\tlet min = a;\n\t\t\tif ( b < min ) min = b;\n\t\t\tif ( c < min ) min = c;\n\n\t\t\tlet max = a;\n\t\t\tif ( b > max ) max = b;\n\t\t\tif ( c > max ) max = c;\n\n\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\n\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\n\t\t\t// worked with.\n\t\t\tconst halfExtents = ( max - min ) / 2;\n\t\t\tconst el2 = el * 2;\n\t\t\ttriangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;\n\t\t\ttriangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\n\n\t\t\tif ( min < fullBounds[ el ] ) fullBounds[ el ] = min;\n\t\t\tif ( max > fullBounds[ el + 3 ] ) fullBounds[ el + 3 ] = max;\n\n\t\t}\n\n\t}\n\n\treturn triangleBounds;\n\n}\n","import { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByTriangleBounds } from '../../utils/ArrayBoxUtilities.js';\nimport { CENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST } from '../Constants.js';\n\nconst BIN_COUNT = 32;\nconst binsSort = ( a, b ) => a.candidate - b.candidate;\nconst sahBins = new Array( BIN_COUNT ).fill().map( () => {\n\n\treturn {\n\n\t\tcount: 0,\n\t\tbounds: new Float32Array( 6 ),\n\t\trightCacheBounds: new Float32Array( 6 ),\n\t\tleftCacheBounds: new Float32Array( 6 ),\n\t\tcandidate: 0,\n\n\t};\n\n} );\nconst leftBounds = new Float32Array( 6 );\n\nexport function getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {\n\n\tlet axis = - 1;\n\tlet pos = 0;\n\n\t// Center\n\tif ( strategy === CENTER ) {\n\n\t\taxis = getLongestEdgeIndex( centroidBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\n\n\t\t}\n\n\t} else if ( strategy === AVERAGE ) {\n\n\t\taxis = getLongestEdgeIndex( nodeBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = getAverage( triangleBounds, offset, count, axis );\n\n\t\t}\n\n\t} else if ( strategy === SAH ) {\n\n\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\n\t\tlet bestCost = TRIANGLE_INTERSECT_COST * count;\n\n\t\t// iterate over all axes\n\t\tconst cStart = offset * 6;\n\t\tconst cEnd = ( offset + count ) * 6;\n\t\tfor ( let a = 0; a < 3; a ++ ) {\n\n\t\t\tconst axisLeft = centroidBoundingData[ a ];\n\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\n\t\t\tconst axisLength = axisRight - axisLeft;\n\t\t\tconst binWidth = axisLength / BIN_COUNT;\n\n\t\t\t// If we have fewer triangles than we're planning to split then just check all\n\t\t\t// the triangle positions because it will be faster.\n\t\t\tif ( count < BIN_COUNT / 4 ) {\n\n\t\t\t\t// initialize the bin candidates\n\t\t\t\tconst truncatedBins = [ ...sahBins ];\n\t\t\t\ttruncatedBins.length = count;\n\n\t\t\t\t// set the candidates\n\t\t\t\tlet b = 0;\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ b ];\n\t\t\t\t\tbin.candidate = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tbin.count = 0;\n\n\t\t\t\t\tconst {\n\t\t\t\t\t\tbounds,\n\t\t\t\t\t\tleftCacheBounds,\n\t\t\t\t\t\trightCacheBounds,\n\t\t\t\t\t} = bin;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bounds );\n\n\t\t\t\t}\n\n\t\t\t\ttruncatedBins.sort( binsSort );\n\n\t\t\t\t// remove redundant splits\n\t\t\t\tlet splitCount = count;\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\n\n\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\n\t\t\t\t\t\tsplitCount --;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// find the appropriate bin for each triangle and expand the bounds.\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst center = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\tif ( center >= bin.candidate ) {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.rightCacheBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.leftCacheBounds );\n\t\t\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// expand all the bounds\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\tconst leftCount = bin.count;\n\t\t\t\t\tconst rightCount = count - bin.count;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\n\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\n\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet rightProb = 0;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// reset the bins\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tbin.count = 0;\n\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\n\n\t\t\t\t\tconst bounds = bin.bounds;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over all center positions\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst triCenter = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\n\n\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\n\t\t\t\t\t// considered to be on the right side of the split\n\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\n\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\n\n\t\t\t\t\tconst bin = sahBins[ binIndex ];\n\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.bounds );\n\n\t\t\t\t}\n\n\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\n\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\n\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\n\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\n\n\t\t\t\t}\n\n\t\t\t\tlet leftCount = 0;\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst binCount = bin.count;\n\t\t\t\t\tconst bounds = bin.bounds;\n\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\n\n\t\t\t\t\t// don't do anything with the bounds if the new bounds have no triangles\n\t\t\t\t\tif ( binCount !== 0 ) {\n\n\t\t\t\t\t\tif ( leftCount === 0 ) {\n\n\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tleftCount += binCount;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tlet rightProb = 0;\n\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rightCount = count - leftCount;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tconsole.warn( `MeshBVH: Invalid build strategy value ${ strategy } used.` );\n\n\t}\n\n\treturn { axis, pos };\n\n}\n\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction getAverage( triangleBounds, offset, count, axis ) {\n\n\tlet avg = 0;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tavg += triangleBounds[ i * 6 + axis * 2 ];\n\n\t}\n\n\treturn avg / count;\n\n}\n","export class MeshBVHNode {\n\n\tconstructor() {\n\n\t\t// internal nodes have boundingData, left, right, and splitAxis\n\t\t// leaf nodes have offset and count (referring to primitives in the mesh geometry)\n\n\t}\n\n}\n","/********************************************************/\n/* This file is generated from \"sortUtils.template.js\". */\n/********************************************************/\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition( indirectBuffer, index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tlet t0 = index[ left * 3 + i ];\n\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\n\t\t\t\tindex[ right * 3 + i ] = t0;\n\n\t\t\t}\n\n\n\t\t\t// swap bounds\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\n\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\n\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nexport { partition };\n","/********************************************************/\n/* This file is generated from \"sortUtils.template.js\". */\n/********************************************************/\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition_indirect( indirectBuffer, index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\t\t\tlet t = indirectBuffer[ left ];\n\t\t\tindirectBuffer[ left ] = indirectBuffer[ right ];\n\t\t\tindirectBuffer[ right ] = t;\n\n\n\t\t\t// swap bounds\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\n\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\n\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nexport { partition_indirect };\n","import { ensureIndex, getFullGeometryRange, getRootIndexRanges, getTriCount, hasGroupGaps, } from './geometryUtils.js';\nimport { getBounds, getCentroidBounds, computeTriangleBounds } from './computeBoundsUtils.js';\nimport { getOptimalSplit } from './splitUtils.js';\nimport { MeshBVHNode } from '../MeshBVHNode.js';\nimport { BYTES_PER_NODE, IS_LEAFNODE_FLAG } from '../Constants.js';\n\nimport { partition } from './sortUtils.generated.js';\nimport { partition_indirect } from './sortUtils_indirect.generated.js';\n\nfunction generateIndirectBuffer( geometry, useSharedArrayBuffer ) {\n\n\tconst triCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\tconst useUint32 = triCount > 2 ** 16;\n\tconst byteCount = useUint32 ? 4 : 2;\n\n\tconst buffer = useSharedArrayBuffer ? new SharedArrayBuffer( triCount * byteCount ) : new ArrayBuffer( triCount * byteCount );\n\tconst indirectBuffer = useUint32 ? new Uint32Array( buffer ) : new Uint16Array( buffer );\n\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\n\n\t\tindirectBuffer[ i ] = i;\n\n\t}\n\n\treturn indirectBuffer;\n\n}\n\nfunction buildTree( bvh, options ) {\n\n\t// Compute the full bounds of the geometry at the same time as triangle bounds because\n\t// we'll need it for the root bounds in the case with no groups and it should be fast here.\n\t// We can't use the geometry bounding box if it's available because it may be out of date.\n\tconst geometry = bvh.geometry;\n\tconst indexArray = geometry.index ? geometry.index.array : null;\n\tconst maxDepth = options.maxDepth;\n\tconst verbose = options.verbose;\n\tconst maxLeafTris = options.maxLeafTris;\n\tconst strategy = options.strategy;\n\tconst onProgress = options.onProgress;\n\tconst totalTriangles = getTriCount( geometry );\n\tconst indirectBuffer = bvh._indirectBuffer;\n\tlet reachedMaxDepth = false;\n\n\tconst fullBounds = new Float32Array( 6 );\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\n\tconst triangleBounds = computeTriangleBounds( geometry, fullBounds );\n\tconst partionFunc = options.indirect ? partition_indirect : partition;\n\n\tconst roots = [];\n\tconst ranges = options.indirect ? getFullGeometryRange( geometry ) : getRootIndexRanges( geometry );\n\n\tif ( ranges.length === 1 ) {\n\n\t\tconst range = ranges[ 0 ];\n\t\tconst root = new MeshBVHNode();\n\t\troot.boundingData = fullBounds;\n\t\tgetCentroidBounds( triangleBounds, range.offset, range.count, cacheCentroidBoundingData );\n\n\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\n\t\troots.push( root );\n\n\t} else {\n\n\t\tfor ( let range of ranges ) {\n\n\t\t\tconst root = new MeshBVHNode();\n\t\t\troot.boundingData = new Float32Array( 6 );\n\t\t\tgetBounds( triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData );\n\n\t\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\n\t\t\troots.push( root );\n\n\t\t}\n\n\t}\n\n\treturn roots;\n\n\tfunction triggerProgress( trianglesProcessed ) {\n\n\t\tif ( onProgress ) {\n\n\t\t\tonProgress( trianglesProcessed / totalTriangles );\n\n\t\t}\n\n\t}\n\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\n\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\n\n\t\t\treachedMaxDepth = true;\n\t\t\tif ( verbose ) {\n\n\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\n\t\t\t\tconsole.warn( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// early out if we've met our capacity\n\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\t// Find where to split the volume\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\n\t\tif ( split.axis === - 1 ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\tconst splitOffset = partionFunc( indirectBuffer, indexArray, triangleBounds, offset, count, split );\n\n\t\t// create the two new child nodes\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\n\t\t} else {\n\n\t\t\tnode.splitAxis = split.axis;\n\n\t\t\t// create the left child and compute its bounding box\n\t\t\tconst left = new MeshBVHNode();\n\t\t\tconst lstart = offset;\n\t\t\tconst lcount = splitOffset - offset;\n\t\t\tnode.left = left;\n\t\t\tleft.boundingData = new Float32Array( 6 );\n\n\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t// repeat for right\n\t\t\tconst right = new MeshBVHNode();\n\t\t\tconst rstart = splitOffset;\n\t\t\tconst rcount = count - lcount;\n\t\t\tnode.right = right;\n\t\t\tright.boundingData = new Float32Array( 6 );\n\n\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nexport function buildPackedTree( bvh, options ) {\n\n\tconst geometry = bvh.geometry;\n\tif ( options.indirect ) {\n\n\t\tbvh._indirectBuffer = generateIndirectBuffer( geometry, options.useSharedArrayBuffer );\n\n\t\tif ( hasGroupGaps( geometry ) && ! options.verbose ) {\n\n\t\t\tconsole.warn(\n\t\t\t\t'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the \"indirect\" option. ' +\n\t\t\t\t'BVH may incorrectly report intersections on unrendered portions of the geometry.'\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\tif ( ! bvh._indirectBuffer ) {\n\n\t\tensureIndex( geometry, options );\n\n\t}\n\n\t// boundingData  \t\t\t\t: 6 float32\n\t// right / offset \t\t\t\t: 1 uint32\n\t// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\n\tconst roots = buildTree( bvh, options );\n\n\tlet float32Array;\n\tlet uint32Array;\n\tlet uint16Array;\n\tconst packedRoots = [];\n\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\tfor ( let i = 0; i < roots.length; i ++ ) {\n\n\t\tconst root = roots[ i ];\n\t\tlet nodeCount = countNodes( root );\n\n\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\n\t\tfloat32Array = new Float32Array( buffer );\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tpopulateBuffer( 0, root );\n\t\tpackedRoots.push( buffer );\n\n\t}\n\n\tbvh._roots = packedRoots;\n\treturn;\n\n\tfunction countNodes( node ) {\n\n\t\tif ( node.count ) {\n\n\t\t\treturn 1;\n\n\t\t} else {\n\n\t\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\n\n\t\t}\n\n\t}\n\n\tfunction populateBuffer( byteOffset, node ) {\n\n\t\tconst stride4Offset = byteOffset / 4;\n\t\tconst stride2Offset = byteOffset / 2;\n\t\tconst isLeaf = ! ! node.count;\n\t\tconst boundingData = node.boundingData;\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tfloat32Array[ stride4Offset + i ] = boundingData[ i ];\n\n\t\t}\n\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = node.offset;\n\t\t\tconst count = node.count;\n\t\t\tuint32Array[ stride4Offset + 6 ] = offset;\n\t\t\tuint16Array[ stride2Offset + 14 ] = count;\n\t\t\tuint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;\n\t\t\treturn byteOffset + BYTES_PER_NODE;\n\n\t\t} else {\n\n\t\t\tconst left = node.left;\n\t\t\tconst right = node.right;\n\t\t\tconst splitAxis = node.splitAxis;\n\n\t\t\tlet nextUnusedPointer;\n\t\t\tnextUnusedPointer = populateBuffer( byteOffset + BYTES_PER_NODE, left );\n\n\t\t\tif ( ( nextUnusedPointer / 4 ) > Math.pow( 2, 32 ) ) {\n\n\t\t\t\tthrow new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );\n\n\t\t\t}\n\n\t\t\tuint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;\n\t\t\tnextUnusedPointer = populateBuffer( nextUnusedPointer, right );\n\n\t\t\tuint32Array[ stride4Offset + 7 ] = splitAxis;\n\t\t\treturn nextUnusedPointer;\n\n\t\t}\n\n\t}\n\n}\n","import { Vector3 } from 'three';\n\nexport class SeparatingAxisBounds {\n\n\tconstructor() {\n\n\t\tthis.min = Infinity;\n\t\tthis.max = - Infinity;\n\n\t}\n\n\tsetFromPointsField( points, field ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = p[ field ];\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tsetFromPoints( axis, points ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = axis.dot( p );\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tisSeparated( other ) {\n\n\t\treturn this.min > other.max || other.min > this.max;\n\n\t}\n\n}\n\nSeparatingAxisBounds.prototype.setFromBox = ( function () {\n\n\tconst p = new Vector3();\n\treturn function setFromBox( axis, box ) {\n\n\t\tconst boxMin = box.min;\n\t\tconst boxMax = box.max;\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tp.x = boxMin.x * x + boxMax.x * ( 1 - x );\n\t\t\t\t\tp.y = boxMin.y * y + boxMax.y * ( 1 - y );\n\t\t\t\t\tp.z = boxMin.z * z + boxMax.z * ( 1 - z );\n\n\t\t\t\t\tconst val = axis.dot( p );\n\t\t\t\t\tmin = Math.min( val, min );\n\t\t\t\t\tmax = Math.max( val, max );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t};\n\n} )();\n\nexport const areIntersecting = ( function () {\n\n\tconst cacheSatBounds = new SeparatingAxisBounds();\n\treturn function areIntersecting( shape1, shape2 ) {\n\n\t\tconst points1 = shape1.points;\n\t\tconst satAxes1 = shape1.satAxes;\n\t\tconst satBounds1 = shape1.satBounds;\n\n\t\tconst points2 = shape2.points;\n\t\tconst satAxes2 = shape2.satAxes;\n\t\tconst satBounds2 = shape2.satBounds;\n\n\t\t// check axes of the first shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds1[ i ];\n\t\t\tconst sa = satAxes1[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points2 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check axes of the second shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds2[ i ];\n\t\t\tconst sa = satAxes2[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points1 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t};\n\n} )();\n","import { Vector3, Vector2, Plane, Line3 } from 'three';\n\nexport const closestPointLineToLine = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst v02 = new Vector3();\n\treturn function closestPointLineToLine( l1, l2, result ) {\n\n\t\tconst v0 = l1.start;\n\t\tconst v10 = dir1;\n\t\tconst v2 = l2.start;\n\t\tconst v32 = dir2;\n\n\t\tv02.subVectors( v0, v2 );\n\t\tdir1.subVectors( l1.end, l1.start );\n\t\tdir2.subVectors( l2.end, l2.start );\n\n\t\t// float d0232 = v02.Dot(v32);\n\t\tconst d0232 = v02.dot( v32 );\n\n\t\t// float d3210 = v32.Dot(v10);\n\t\tconst d3210 = v32.dot( v10 );\n\n\t\t// float d3232 = v32.Dot(v32);\n\t\tconst d3232 = v32.dot( v32 );\n\n\t\t// float d0210 = v02.Dot(v10);\n\t\tconst d0210 = v02.dot( v10 );\n\n\t\t// float d1010 = v10.Dot(v10);\n\t\tconst d1010 = v10.dot( v10 );\n\n\t\t// float denom = d1010*d3232 - d3210*d3210;\n\t\tconst denom = d1010 * d3232 - d3210 * d3210;\n\n\t\tlet d, d2;\n\t\tif ( denom !== 0 ) {\n\n\t\t\td = ( d0232 * d3210 - d0210 * d3232 ) / denom;\n\n\t\t} else {\n\n\t\t\td = 0;\n\n\t\t}\n\n\t\td2 = ( d0232 + d * d3210 ) / d3232;\n\n\t\tresult.x = d;\n\t\tresult.y = d2;\n\n\t};\n\n} )();\n\nexport const closestPointsSegmentToSegment = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\n\tconst paramResult = new Vector2();\n\tconst temp1 = new Vector3();\n\tconst temp2 = new Vector3();\n\treturn function closestPointsSegmentToSegment( l1, l2, target1, target2 ) {\n\n\t\tclosestPointLineToLine( l1, l2, paramResult );\n\n\t\tlet d = paramResult.x;\n\t\tlet d2 = paramResult.y;\n\t\tif ( d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1 ) {\n\n\t\t\tl1.at( d, target1 );\n\t\t\tl2.at( d2, target2 );\n\n\t\t\treturn;\n\n\t\t} else if ( d >= 0 && d <= 1 ) {\n\n\t\t\t// Only d2 is out of bounds.\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tl2.at( 0, target2 );\n\n\t\t\t} else {\n\n\t\t\t\tl2.at( 1, target2 );\n\n\t\t\t}\n\n\t\t\tl1.closestPointToPoint( target2, true, target1 );\n\t\t\treturn;\n\n\t\t} else if ( d2 >= 0 && d2 <= 1 ) {\n\n\t\t\t// Only d is out of bounds.\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tl1.at( 0, target1 );\n\n\t\t\t} else {\n\n\t\t\t\tl1.at( 1, target1 );\n\n\t\t\t}\n\n\t\t\tl2.closestPointToPoint( target1, true, target2 );\n\t\t\treturn;\n\n\t\t} else {\n\n\t\t\t// Both u and u2 are out of bounds.\n\t\t\tlet p;\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tp = l1.start;\n\n\t\t\t} else {\n\n\t\t\t\tp = l1.end;\n\n\t\t\t}\n\n\t\t\tlet p2;\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tp2 = l2.start;\n\n\t\t\t} else {\n\n\t\t\t\tp2 = l2.end;\n\n\t\t\t}\n\n\t\t\tconst closestPoint = temp1;\n\t\t\tconst closestPoint2 = temp2;\n\t\t\tl1.closestPointToPoint( p2, true, temp1 );\n\t\t\tl2.closestPointToPoint( p, true, temp2 );\n\n\t\t\tif ( closestPoint.distanceToSquared( p2 ) <= closestPoint2.distanceToSquared( p ) ) {\n\n\t\t\t\ttarget1.copy( closestPoint );\n\t\t\t\ttarget2.copy( p2 );\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\ttarget1.copy( p );\n\t\t\t\ttarget2.copy( closestPoint2 );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n} )();\n\n\nexport const sphereIntersectTriangle = ( function () {\n\n\t// https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\n\tconst closestPointTemp = new Vector3();\n\tconst projectedPointTemp = new Vector3();\n\tconst planeTemp = new Plane();\n\tconst lineTemp = new Line3();\n\treturn function sphereIntersectTriangle( sphere, triangle ) {\n\n\t\tconst { radius, center } = sphere;\n\t\tconst { a, b, c } = triangle;\n\n\t\t// phase 1\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = b;\n\t\tconst closestPoint1 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint1.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint2 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint2.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = b;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint3 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint3.distanceTo( center ) <= radius ) return true;\n\n\t\t// phase 2\n\t\tconst plane = triangle.getPlane( planeTemp );\n\t\tconst dp = Math.abs( plane.distanceToPoint( center ) );\n\t\tif ( dp <= radius ) {\n\n\t\t\tconst pp = plane.projectPoint( center, projectedPointTemp );\n\t\t\tconst cp = triangle.containsPoint( pp );\n\t\t\tif ( cp ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n} )();\n","import { Triangle, Vector3, Line3, Sphere, Plane } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { closestPointsSegmentToSegment, sphereIntersectTriangle } from './MathUtilities.js';\n\nconst ZERO_EPSILON = 1e-15;\nfunction isNearZero( value ) {\n\n\treturn Math.abs( value ) < ZERO_EPSILON;\n\n}\n\nexport class ExtendedTriangle extends Triangle {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.isExtendedTriangle = true;\n\t\tthis.satAxes = new Array( 4 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 4 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.points = [ this.a, this.b, this.c ];\n\t\tthis.sphere = new Sphere();\n\t\tthis.plane = new Plane();\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn sphereIntersectTriangle( sphere, this );\n\n\t}\n\n\tupdate() {\n\n\t\tconst a = this.a;\n\t\tconst b = this.b;\n\t\tconst c = this.c;\n\t\tconst points = this.points;\n\n\t\tconst satAxes = this.satAxes;\n\t\tconst satBounds = this.satBounds;\n\n\t\tconst axis0 = satAxes[ 0 ];\n\t\tconst sab0 = satBounds[ 0 ];\n\t\tthis.getNormal( axis0 );\n\t\tsab0.setFromPoints( axis0, points );\n\n\t\tconst axis1 = satAxes[ 1 ];\n\t\tconst sab1 = satBounds[ 1 ];\n\t\taxis1.subVectors( a, b );\n\t\tsab1.setFromPoints( axis1, points );\n\n\t\tconst axis2 = satAxes[ 2 ];\n\t\tconst sab2 = satBounds[ 2 ];\n\t\taxis2.subVectors( b, c );\n\t\tsab2.setFromPoints( axis2, points );\n\n\t\tconst axis3 = satAxes[ 3 ];\n\t\tconst sab3 = satBounds[ 3 ];\n\t\taxis3.subVectors( c, a );\n\t\tsab3.setFromPoints( axis3, points );\n\n\t\tthis.sphere.setFromPoints( this.points );\n\t\tthis.plane.setFromNormalAndCoplanarPoint( axis0, a );\n\t\tthis.needsUpdate = false;\n\n\t}\n\n}\n\nExtendedTriangle.prototype.closestPointToSegment = ( function () {\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\tconst edge = new Line3();\n\n\treturn function distanceToSegment( segment, target1 = null, target2 = null ) {\n\n\t\tconst { start, end } = segment;\n\t\tconst points = this.points;\n\t\tlet distSq;\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check the triangle edges\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst nexti = ( i + 1 ) % 3;\n\t\t\tedge.start.copy( points[ i ] );\n\t\t\tedge.end.copy( points[ nexti ] );\n\n\t\t\tclosestPointsSegmentToSegment( edge, segment, point1, point2 );\n\n\t\t\tdistSq = point1.distanceToSquared( point2 );\n\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check end points\n\t\tthis.closestPointToPoint( start, point1 );\n\t\tdistSq = start.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( start );\n\n\t\t}\n\n\t\tthis.closestPointToPoint( end, point1 );\n\t\tdistSq = end.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( end );\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n\nExtendedTriangle.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri2 = new ExtendedTriangle();\n\tconst arr1 = new Array( 3 );\n\tconst arr2 = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\tconst dir = new Vector3();\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst tempDir = new Vector3();\n\tconst edge = new Line3();\n\tconst edge1 = new Line3();\n\tconst edge2 = new Line3();\n\tconst tempPoint = new Vector3();\n\n\tfunction triIntersectPlane( tri, plane, targetEdge ) {\n\n\t\t// find the edge that intersects the other triangle plane\n\t\tconst points = tri.points;\n\t\tlet count = 0;\n\t\tlet startPointIntersection = - 1;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst { start, end } = edge;\n\t\t\tstart.copy( points[ i ] );\n\t\t\tend.copy( points[ ( i + 1 ) % 3 ] );\n\t\t\tedge.delta( dir );\n\n\t\t\tconst startIntersects = isNearZero( plane.distanceToPoint( start ) );\n\t\t\tif ( isNearZero( plane.normal.dot( dir ) ) && startIntersects ) {\n\n\t\t\t\t// if the edge lies on the plane then take the line\n\t\t\t\ttargetEdge.copy( edge );\n\t\t\t\tcount = 2;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// check if the start point is near the plane because \"intersectLine\" is not robust to that case\n\t\t\tconst doesIntersect = plane.intersectLine( edge, tempPoint );\n\t\t\tif ( ! doesIntersect && startIntersects ) {\n\n\t\t\t\ttempPoint.copy( start );\n\n\t\t\t}\n\n\t\t\t// ignore the end point\n\t\t\tif ( ( doesIntersect || startIntersects ) && ! isNearZero( tempPoint.distanceTo( end ) ) ) {\n\n\t\t\t\tif ( count <= 1 ) {\n\n\t\t\t\t\t// assign to the start or end point and save which index was snapped to\n\t\t\t\t\t// the start point if necessary\n\t\t\t\t\tconst point = count === 1 ? targetEdge.start : targetEdge.end;\n\t\t\t\t\tpoint.copy( tempPoint );\n\t\t\t\t\tif ( startIntersects ) {\n\n\t\t\t\t\t\tstartPointIntersection = count;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( count >= 2 ) {\n\n\t\t\t\t\t// if we're here that means that there must have been one point that had\n\t\t\t\t\t// snapped to the start point so replace it here\n\t\t\t\t\tconst point = startPointIntersection === 1 ? targetEdge.start : targetEdge.end;\n\t\t\t\t\tpoint.copy( tempPoint );\n\t\t\t\t\tcount = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tcount ++;\n\t\t\t\tif ( count === 2 && startPointIntersection === - 1 ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn count;\n\n\t}\n\n\t// TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\n\t// be a line contained by both triangles if not a different special case somehow represented in the return result.\n\treturn function intersectsTriangle( other, target = null, suppressLog = false ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! other.isExtendedTriangle ) {\n\n\t\t\tsaTri2.copy( other );\n\t\t\tsaTri2.update();\n\t\t\tother = saTri2;\n\n\t\t} else if ( other.needsUpdate ) {\n\n\t\t\tother.update();\n\n\t\t}\n\n\t\tconst plane1 = this.plane;\n\t\tconst plane2 = other.plane;\n\n\t\tif ( Math.abs( plane1.normal.dot( plane2.normal ) ) > 1.0 - 1e-10 ) {\n\n\t\t\t// perform separating axis intersection test only for coplanar triangles\n\t\t\tconst satBounds1 = this.satBounds;\n\t\t\tconst satAxes1 = this.satAxes;\n\t\t\tarr2[ 0 ] = other.a;\n\t\t\tarr2[ 1 ] = other.b;\n\t\t\tarr2[ 2 ] = other.c;\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sb = satBounds1[ i ];\n\t\t\t\tconst sa = satAxes1[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr2 );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\tconst satBounds2 = other.satBounds;\n\t\t\tconst satAxes2 = other.satAxes;\n\t\t\tarr1[ 0 ] = this.a;\n\t\t\tarr1[ 1 ] = this.b;\n\t\t\tarr1[ 2 ] = this.c;\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sb = satBounds2[ i ];\n\t\t\t\tconst sa = satAxes2[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr1 );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\t// check crossed axes\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sa1 = satAxes1[ i ];\n\t\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\t\tconst sa2 = satAxes2[ i2 ];\n\t\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, arr1 );\n\t\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, arr2 );\n\t\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( target ) {\n\n\t\t\t\t// TODO find two points that intersect on the edges and make that the result\n\t\t\t\tif ( ! suppressLog ) {\n\n\t\t\t\t\tconsole.warn( 'ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.' );\n\n\t\t\t\t}\n\n\t\t\t\ttarget.start.set( 0, 0, 0 );\n\t\t\t\ttarget.end.set( 0, 0, 0 );\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\t// find the edge that intersects the other triangle plane\n\t\t\tconst count1 = triIntersectPlane( this, plane2, edge1 );\n\t\t\tif ( count1 === 1 && other.containsPoint( edge1.end ) ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( edge1.end );\n\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( count1 !== 2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// find the other triangles edge that intersects this plane\n\t\t\tconst count2 = triIntersectPlane( other, plane1, edge2 );\n\t\t\tif ( count2 === 1 && this.containsPoint( edge2.end ) ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( edge2.end );\n\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( count2 !== 2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// find swap the second edge so both lines are running the same direction\n\t\t\tedge1.delta( dir1 );\n\t\t\tedge2.delta( dir2 );\n\n\t\t\tif ( dir1.dot( dir2 ) < 0 ) {\n\n\t\t\t\tlet tmp = edge2.start;\n\t\t\t\tedge2.start = edge2.end;\n\t\t\t\tedge2.end = tmp;\n\n\t\t\t}\n\n\t\t\t// check if the edges are overlapping\n\t\t\tconst s1 = edge1.start.dot( dir1 );\n\t\t\tconst e1 = edge1.end.dot( dir1 );\n\t\t\tconst s2 = edge2.start.dot( dir1 );\n\t\t\tconst e2 = edge2.end.dot( dir1 );\n\t\t\tconst separated1 = e1 < s2;\n\t\t\tconst separated2 = s1 < e2;\n\n\t\t\tif ( s1 !== e2 && s2 !== e1 && separated1 === separated2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// assign the target output\n\t\t\tif ( target ) {\n\n\t\t\t\ttempDir.subVectors( edge1.start, edge2.start );\n\t\t\t\tif ( tempDir.dot( dir1 ) > 0 ) {\n\n\t\t\t\t\ttarget.start.copy( edge1.start );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget.start.copy( edge2.start );\n\n\t\t\t\t}\n\n\t\t\t\ttempDir.subVectors( edge1.end, edge2.end );\n\t\t\t\tif ( tempDir.dot( dir1 ) < 0 ) {\n\n\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToTriangle = ( function () {\n\n\tconst point = new Vector3();\n\tconst point2 = new Vector3();\n\tconst cornerFields = [ 'a', 'b', 'c' ];\n\tconst line1 = new Line3();\n\tconst line2 = new Line3();\n\n\treturn function distanceToTriangle( other, target1 = null, target2 = null ) {\n\n\t\tconst lineTarget = target1 || target2 ? line1 : null;\n\t\tif ( this.intersectsTriangle( other, lineTarget ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tif ( target1 ) lineTarget.getCenter( target1 );\n\t\t\t\tif ( target2 ) lineTarget.getCenter( target2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check all point distances\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tlet dist;\n\t\t\tconst field = cornerFields[ i ];\n\t\t\tconst otherVec = other[ field ];\n\t\t\tthis.closestPointToPoint( otherVec, point );\n\n\t\t\tdist = otherVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\tif ( target2 ) target2.copy( otherVec );\n\n\t\t\t}\n\n\n\t\t\tconst thisVec = this[ field ];\n\t\t\tother.closestPointToPoint( thisVec, point );\n\n\t\t\tdist = thisVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( thisVec );\n\t\t\t\tif ( target2 ) target2.copy( point );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst f11 = cornerFields[ i ];\n\t\t\tconst f12 = cornerFields[ ( i + 1 ) % 3 ];\n\t\t\tline1.set( this[ f11 ], this[ f12 ] );\n\t\t\tfor ( let i2 = 0; i2 < 3; i2 ++ ) {\n\n\t\t\t\tconst f21 = cornerFields[ i2 ];\n\t\t\t\tconst f22 = cornerFields[ ( i2 + 1 ) % 3 ];\n\t\t\t\tline2.set( other[ f21 ], other[ f22 ] );\n\n\t\t\t\tclosestPointsSegmentToSegment( line1, line2, point, point2 );\n\n\t\t\t\tconst dist = point.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n","import { Vector3, Matrix4, Line3 } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { ExtendedTriangle } from './ExtendedTriangle.js';\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\n\nexport class OrientedBox {\n\n\tconstructor( min, max, matrix ) {\n\n\t\tthis.isOrientedBox = true;\n\t\tthis.min = new Vector3();\n\t\tthis.max = new Vector3();\n\t\tthis.matrix = new Matrix4();\n\t\tthis.invMatrix = new Matrix4();\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\n\t\tthis.satAxes = new Array( 3 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.needsUpdate = false;\n\n\t\tif ( min ) this.min.copy( min );\n\t\tif ( max ) this.max.copy( max );\n\t\tif ( matrix ) this.matrix.copy( matrix );\n\n\t}\n\n\tset( min, max, matrix ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\t\tthis.matrix.copy( matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.min.copy( other.min );\n\t\tthis.max.copy( other.max );\n\t\tthis.matrix.copy( other.matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nOrientedBox.prototype.update = ( function () {\n\n\treturn function update() {\n\n\t\tconst matrix = this.matrix;\n\t\tconst min = this.min;\n\t\tconst max = this.max;\n\n\t\tconst points = this.points;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\n\t\t\t\t\tconst v = points[ i ];\n\t\t\t\t\tv.x = x ? max.x : min.x;\n\t\t\t\t\tv.y = y ? max.y : min.y;\n\t\t\t\t\tv.z = z ? max.z : min.z;\n\n\t\t\t\t\tv.applyMatrix4( matrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst minVec = points[ 0 ];\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst index = 1 << i;\n\t\t\tconst pi = points[ index ];\n\n\t\t\taxis.subVectors( minVec, pi );\n\t\t\tsb.setFromPoints( axis, points );\n\n\t\t}\n\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\n\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\n\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\n\n\t\tthis.invMatrix.copy( this.matrix ).invert();\n\t\tthis.needsUpdate = false;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsBox = ( function () {\n\n\tconst aabbBounds = new SeparatingAxisBounds();\n\treturn function intersectsBox( box ) {\n\n\t\t// TODO: should this be doing SAT against the AABB?\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\n\t\taabbBounds.min = min.x;\n\t\taabbBounds.max = max.x;\n\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.y;\n\t\taabbBounds.max = max.y;\n\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.z;\n\t\taabbBounds.max = max.z;\n\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\taabbBounds.setFromBox( axis, box );\n\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri = new ExtendedTriangle();\n\tconst pointsArr = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\treturn function intersectsTriangle( triangle ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! triangle.isExtendedTriangle ) {\n\n\t\t\tsaTri.copy( triangle );\n\t\t\tsaTri.update();\n\t\t\ttriangle = saTri;\n\n\t\t} else if ( triangle.needsUpdate ) {\n\n\t\t\ttriangle.update();\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\n\t\tpointsArr[ 0 ] = triangle.a;\n\t\tpointsArr[ 1 ] = triangle.b;\n\t\tpointsArr[ 2 ] = triangle.c;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst sa = satAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\tconst triSatBounds = triangle.satBounds;\n\t\tconst triSatAxes = triangle.satAxes;\n\t\tconst points = this.points;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = triSatBounds[ i ];\n\t\t\tconst sa = triSatAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, points );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check crossed axes\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sa1 = satAxes[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\tconst sa2 = triSatAxes[ i2 ];\n\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\n\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\n\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.closestPointToPoint = ( function () {\n\n\treturn function closestPointToPoint( point, target1 ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\ttarget1\n\t\t\t.copy( point )\n\t\t\t.applyMatrix4( this.invMatrix )\n\t\t\t.clamp( this.min, this.max )\n\t\t\t.applyMatrix4( this.matrix );\n\n\t\treturn target1;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToBox = ( function () {\n\n\tconst xyzFields = [ 'x', 'y', 'z' ];\n\tconst segments1 = new Array( 12 ).fill().map( () => new Line3() );\n\tconst segments2 = new Array( 12 ).fill().map( () => new Line3() );\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\n\t// early out if we find a value below threshold\n\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( this.intersectsBox( box ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tbox.getCenter( point2 );\n\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\tbox.closestPointToPoint( point1, point2 );\n\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst threshold2 = threshold * threshold;\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst points = this.points;\n\n\n\t\t// iterate over every edge and compare distances\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check over all these points\n\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tpoint2.copy( p ).clamp( min, max );\n\n\t\t\tconst dist = p.distanceToSquared( point2 );\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( p );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate and check all line segment distances\n\t\tlet count = 0;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\n\n\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\n\n\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\n\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\n\n\t\t\t\t\t// get obb line segments\n\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst p1 = points[ index ];\n\t\t\t\t\tconst p2 = points[ index2 ];\n\t\t\t\t\tconst line1 = segments1[ count ];\n\t\t\t\t\tline1.set( p1, p2 );\n\n\n\t\t\t\t\t// get aabb line segments\n\t\t\t\t\tconst f1 = xyzFields[ i ];\n\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\n\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\n\t\t\t\t\tconst line2 = segments2[ count ];\n\t\t\t\t\tconst start = line2.start;\n\t\t\t\t\tconst end = line2.end;\n\n\t\t\t\t\tstart[ f1 ] = min[ f1 ];\n\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tend[ f1 ] = max[ f1 ];\n\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check all the other boxes point\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tpoint2.x = x ? max.x : min.x;\n\t\t\t\t\tpoint2.y = y ? max.y : min.y;\n\t\t\t\t\tpoint2.z = z ? max.z : min.z;\n\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 12; i ++ ) {\n\n\t\t\tconst l1 = segments1[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\n\n\t\t\t\tconst l2 = segments2[ i2 ];\n\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\n\t\t\t\tconst dist = point1.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n","export class PrimitivePool {\n\n\tconstructor( getNewPrimitive ) {\n\n\t\tthis._getNewPrimitive = getNewPrimitive;\n\t\tthis._primitives = [];\n\n\t}\n\n\tgetPrimitive() {\n\n\t\tconst primitives = this._primitives;\n\t\tif ( primitives.length === 0 ) {\n\n\t\t\treturn this._getNewPrimitive();\n\n\t\t} else {\n\n\t\t\treturn primitives.pop();\n\n\t\t}\n\n\t}\n\n\treleasePrimitive( primitive ) {\n\n\t\tthis._primitives.push( primitive );\n\n\t}\n\n}\n","import { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { PrimitivePool } from './PrimitivePool.js';\n\nclass ExtendedTrianglePoolBase extends PrimitivePool {\n\n\tconstructor() {\n\n\t\tsuper( () => new ExtendedTriangle() );\n\n\t}\n\n}\n\nexport const ExtendedTrianglePool = /* @__PURE__ */ new ExtendedTrianglePoolBase();\n","export function IS_LEAF( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 15 ] === 0xFFFF;\n\n}\n\nexport function OFFSET( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function COUNT( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 14 ];\n\n}\n\nexport function LEFT_NODE( n32 ) {\n\n\treturn n32 + 8;\n\n}\n\nexport function RIGHT_NODE( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function SPLIT_AXIS( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 7 ];\n\n}\n\nexport function BOUNDING_DATA_INDEX( n32 ) {\n\n\treturn n32;\n\n}\n","class _BufferStack {\n\n\tconstructor() {\n\n\t\tthis.float32Array = null;\n\t\tthis.uint16Array = null;\n\t\tthis.uint32Array = null;\n\n\t\tconst stack = [];\n\t\tlet prevBuffer = null;\n\t\tthis.setBuffer = buffer => {\n\n\t\t\tif ( prevBuffer ) {\n\n\t\t\t\tstack.push( prevBuffer );\n\n\t\t\t}\n\n\t\t\tprevBuffer = buffer;\n\t\t\tthis.float32Array = new Float32Array( buffer );\n\t\t\tthis.uint16Array = new Uint16Array( buffer );\n\t\t\tthis.uint32Array = new Uint32Array( buffer );\n\n\t\t};\n\n\t\tthis.clearBuffer = () => {\n\n\t\t\tprevBuffer = null;\n\t\t\tthis.float32Array = null;\n\t\t\tthis.uint16Array = null;\n\t\t\tthis.uint32Array = null;\n\n\t\t\tif ( stack.length !== 0 ) {\n\n\t\t\t\tthis.setBuffer( stack.pop() );\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n}\n\nexport const BufferStack = new _BufferStack();\n","import { Box3 } from 'three';\nimport { CONTAINED } from '../Constants.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\nlet _box1, _box2;\nconst boxStack = [];\nconst boxPool = /* @__PURE__ */ new PrimitivePool( () => new Box3() );\n\nexport function shapecast( bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset ) {\n\n\t// setup\n\t_box1 = boxPool.getPrimitive();\n\t_box2 = boxPool.getPrimitive();\n\tboxStack.push( _box1, _box2 );\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\n\tconst result = shapecastTraverse( 0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t// cleanup\n\tBufferStack.clearBuffer();\n\tboxPool.releasePrimitive( _box1 );\n\tboxPool.releasePrimitive( _box2 );\n\tboxStack.pop();\n\tboxStack.pop();\n\n\tconst length = boxStack.length;\n\tif ( length > 0 ) {\n\n\t\t_box2 = boxStack[ length - 1 ];\n\t\t_box1 = boxStack[ length - 2 ];\n\n\t}\n\n\treturn result;\n\n}\n\nfunction shapecastTraverse(\n\tnodeIndex32,\n\tgeometry,\n\tintersectsBoundsFunc,\n\tintersectsRangeFunc,\n\tnodeScoreFunc = null,\n\tnodeIndexByteOffset = 0, // offset for unique node identifier\n\tdepth = 0\n) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1 );\n\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1 );\n\n\t} else {\n\n\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tlet c1 = left;\n\t\tlet c2 = right;\n\n\t\tlet score1, score2;\n\t\tlet box1, box2;\n\t\tif ( nodeScoreFunc ) {\n\n\t\t\tbox1 = _box1;\n\t\t\tbox2 = _box2;\n\n\t\t\t// bounding data is not offset\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\tscore1 = nodeScoreFunc( box1 );\n\t\t\tscore2 = nodeScoreFunc( box2 );\n\n\t\t\tif ( score2 < score1 ) {\n\n\t\t\t\tc1 = right;\n\t\t\t\tc2 = left;\n\n\t\t\t\tconst temp = score1;\n\t\t\t\tscore1 = score2;\n\t\t\t\tscore2 = temp;\n\n\t\t\t\tbox1 = box2;\n\t\t\t\t// box2 is always set before use below\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Check box 1 intersection\n\t\tif ( ! box1 ) {\n\n\t\t\tbox1 = _box1;\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\n\t\t}\n\n\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\n\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );\n\n\t\tlet c1StopTraversal;\n\t\tif ( c1Intersection === CONTAINED ) {\n\n\t\t\tconst offset = getLeftOffset( c1 );\n\t\t\tconst end = getRightEndOffset( c1 );\n\t\t\tconst count = end - offset;\n\n\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1 );\n\n\t\t} else {\n\n\t\t\tc1StopTraversal =\n\t\t\t\tc1Intersection &&\n\t\t\t\tshapecastTraverse(\n\t\t\t\t\tc1,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\tdepth + 1\n\t\t\t\t);\n\n\t\t}\n\n\t\tif ( c1StopTraversal ) return true;\n\n\t\t// Check box 2 intersection\n\t\t// cached box2 will have been overwritten by previous traversal\n\t\tbox2 = _box2;\n\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\n\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );\n\n\t\tlet c2StopTraversal;\n\t\tif ( c2Intersection === CONTAINED ) {\n\n\t\t\tconst offset = getLeftOffset( c2 );\n\t\t\tconst end = getRightEndOffset( c2 );\n\t\t\tconst count = end - offset;\n\n\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2 );\n\n\t\t} else {\n\n\t\t\tc2StopTraversal =\n\t\t\t\tc2Intersection &&\n\t\t\t\tshapecastTraverse(\n\t\t\t\t\tc2,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\tdepth + 1\n\t\t\t\t);\n\n\t\t}\n\n\t\tif ( c2StopTraversal ) return true;\n\n\t\treturn false;\n\n\t\t// Define these inside the function so it has access to the local variables needed\n\t\t// when converting to the buffer equivalents\n\t\tfunction getLeftOffset( nodeIndex32 ) {\n\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\treturn OFFSET( nodeIndex32, uint32Array );\n\n\t\t}\n\n\t\tfunction getRightEndOffset( nodeIndex32 ) {\n\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\t// adjust offset to point to the right node\n\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\t// return the end offset of the triangle range\n\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\n\n\t\t}\n\n\t}\n\n}\n","import { Vector3 } from 'three';\n\nconst temp = /* @__PURE__ */ new Vector3();\nconst temp1 = /* @__PURE__ */ new Vector3();\n\nexport function closestPointToPoint(\n\tbvh,\n\tpoint,\n\ttarget = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\t// early out if under minThreshold\n\t// skip checking if over maxThreshold\n\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\n\t// returns Infinity if no value found\n\tconst minThresholdSq = minThreshold * minThreshold;\n\tconst maxThresholdSq = maxThreshold * maxThreshold;\n\tlet closestDistanceSq = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tbvh.shapecast(\n\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\n\t\t\t\treturn temp.distanceToSquared( point );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\n\n\t\t\t},\n\n\t\t\tintersectsTriangle: ( tri, triIndex ) => {\n\n\t\t\t\ttri.closestPointToPoint( point, temp );\n\t\t\t\tconst distSq = point.distanceToSquared( temp );\n\t\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\t\ttemp1.copy( temp );\n\t\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\t\tclosestDistanceTriIndex = triIndex;\n\n\t\t\t\t}\n\n\t\t\t\tif ( distSq < minThresholdSq ) {\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tif ( closestDistanceSq === Infinity ) return null;\n\n\tconst closestDistance = Math.sqrt( closestDistanceSq );\n\n\tif ( ! target.point ) target.point = temp1.clone();\n\telse target.point.copy( temp1 );\n\ttarget.distance = closestDistance,\n\ttarget.faceIndex = closestDistanceTriIndex;\n\n\treturn target;\n\n}\n","import { Vector3, Vector2, Triangle, DoubleSide, BackSide } from 'three';\n\n// Ripped and modified From THREE.js Mesh raycast\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\nconst _vA = /* @__PURE__ */ new Vector3();\nconst _vB = /* @__PURE__ */ new Vector3();\nconst _vC = /* @__PURE__ */ new Vector3();\n\nconst _uvA = /* @__PURE__ */ new Vector2();\nconst _uvB = /* @__PURE__ */ new Vector2();\nconst _uvC = /* @__PURE__ */ new Vector2();\n\nconst _normalA = /* @__PURE__ */ new Vector3();\nconst _normalB = /* @__PURE__ */ new Vector3();\nconst _normalC = /* @__PURE__ */ new Vector3();\n\nconst _intersectionPoint = /* @__PURE__ */ new Vector3();\nfunction checkIntersection( ray, pA, pB, pC, point, side ) {\n\n\tlet intersect;\n\tif ( side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, side !== DoubleSide, point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\tconst distance = ray.origin.distanceTo( point );\n\n\treturn {\n\n\t\tdistance: distance,\n\t\tpoint: point.clone(),\n\n\t};\n\n}\n\nfunction checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side ) {\n\n\t_vA.fromBufferAttribute( position, a );\n\t_vB.fromBufferAttribute( position, b );\n\t_vC.fromBufferAttribute( position, c );\n\n\tconst intersection = checkIntersection( ray, _vA, _vB, _vC, _intersectionPoint, side );\n\n\tif ( intersection ) {\n\n\t\tif ( uv ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv, a );\n\t\t\t_uvB.fromBufferAttribute( uv, b );\n\t\t\t_uvC.fromBufferAttribute( uv, c );\n\n\t\t\tintersection.uv = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t}\n\n\t\tif ( uv1 ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv1, a );\n\t\t\t_uvB.fromBufferAttribute( uv1, b );\n\t\t\t_uvC.fromBufferAttribute( uv1, c );\n\n\t\t\tintersection.uv1 = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t}\n\n\t\tif ( normal ) {\n\n\t\t\t_normalA.fromBufferAttribute( normal, a );\n\t\t\t_normalB.fromBufferAttribute( normal, b );\n\t\t\t_normalC.fromBufferAttribute( normal, c );\n\n\t\t\tintersection.normal = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new Vector3() );\n\t\t\tif ( intersection.normal.dot( ray.direction ) > 0 ) {\n\n\t\t\t\tintersection.normal.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( _vA, _vB, _vC, face.normal );\n\n\t\tintersection.face = face;\n\t\tintersection.faceIndex = a;\n\n\t}\n\n\treturn intersection;\n\n}\n\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\nfunction intersectTri( geo, side, ray, tri, intersections ) {\n\n\tconst triOffset = tri * 3;\n\tlet a = triOffset + 0;\n\tlet b = triOffset + 1;\n\tlet c = triOffset + 2;\n\n\tconst index = geo.index;\n\tif ( geo.index ) {\n\n\t\ta = index.getX( a );\n\t\tb = index.getX( b );\n\t\tc = index.getX( c );\n\n\t}\n\n\tconst { position, normal, uv, uv1 } = geo.attributes;\n\tconst intersection = checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side );\n\n\tif ( intersection ) {\n\n\t\tintersection.faceIndex = tri;\n\t\tif ( intersections ) intersections.push( intersection );\n\t\treturn intersection;\n\n\t}\n\n\treturn null;\n\n}\n\nexport { intersectTri };\n","\nimport { Vector2, Vector3, Triangle } from 'three';\n\n// sets the vertices of triangle `tri` with the 3 vertices after i\nexport function setTriangle( tri, i, index, pos ) {\n\n\tconst ta = tri.a;\n\tconst tb = tri.b;\n\tconst tc = tri.c;\n\n\tlet i0 = i;\n\tlet i1 = i + 1;\n\tlet i2 = i + 2;\n\tif ( index ) {\n\n\t\ti0 = index.getX( i0 );\n\t\ti1 = index.getX( i1 );\n\t\ti2 = index.getX( i2 );\n\n\t}\n\n\tta.x = pos.getX( i0 );\n\tta.y = pos.getY( i0 );\n\tta.z = pos.getZ( i0 );\n\n\ttb.x = pos.getX( i1 );\n\ttb.y = pos.getY( i1 );\n\ttb.z = pos.getZ( i1 );\n\n\ttc.x = pos.getX( i2 );\n\ttc.y = pos.getY( i2 );\n\ttc.z = pos.getZ( i2 );\n\n}\n\nconst tempV1 = /* @__PURE__ */ new Vector3();\nconst tempV2 = /* @__PURE__ */ new Vector3();\nconst tempV3 = /* @__PURE__ */ new Vector3();\nconst tempUV1 = /* @__PURE__ */ new Vector2();\nconst tempUV2 = /* @__PURE__ */ new Vector2();\nconst tempUV3 = /* @__PURE__ */ new Vector2();\n\nexport function getTriangleHitPointInfo( point, geometry, triangleIndex, target ) {\n\n\tconst indices = geometry.getIndex().array;\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst uvs = geometry.getAttribute( 'uv' );\n\n\tconst a = indices[ triangleIndex * 3 ];\n\tconst b = indices[ triangleIndex * 3 + 1 ];\n\tconst c = indices[ triangleIndex * 3 + 2 ];\n\n\ttempV1.fromBufferAttribute( positions, a );\n\ttempV2.fromBufferAttribute( positions, b );\n\ttempV3.fromBufferAttribute( positions, c );\n\n\t// find the associated material index\n\tlet materialIndex = 0;\n\tconst groups = geometry.groups;\n\tconst firstVertexIndex = triangleIndex * 3;\n\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\t\tconst { start, count } = group;\n\t\tif ( firstVertexIndex >= start && firstVertexIndex < start + count ) {\n\n\t\t\tmaterialIndex = group.materialIndex;\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t// extract uvs\n\tlet uv = null;\n\tif ( uvs ) {\n\n\t\ttempUV1.fromBufferAttribute( uvs, a );\n\t\ttempUV2.fromBufferAttribute( uvs, b );\n\t\ttempUV3.fromBufferAttribute( uvs, c );\n\n\t\tif ( target && target.uv ) uv = target.uv;\n\t\telse uv = new Vector2();\n\n\t\tTriangle.getInterpolation( point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv );\n\n\t}\n\n\t// adjust the provided target or create a new one\n\tif ( target ) {\n\n\t\tif ( ! target.face ) target.face = { };\n\t\ttarget.face.a = a;\n\t\ttarget.face.b = b;\n\t\ttarget.face.c = c;\n\t\ttarget.face.materialIndex = materialIndex;\n\t\tif ( ! target.face.normal ) target.face.normal = new Vector3();\n\t\tTriangle.getNormal( tempV1, tempV2, tempV3, target.face.normal );\n\n\t\tif ( uv ) target.uv = uv;\n\n\t\treturn target;\n\n\t} else {\n\n\t\treturn {\n\t\t\tface: {\n\t\t\t\ta: a,\n\t\t\t\tb: b,\n\t\t\t\tc: c,\n\t\t\t\tmaterialIndex: materialIndex,\n\t\t\t\tnormal: Triangle.getNormal( tempV1, tempV2, tempV3, new Vector3() )\n\t\t\t},\n\t\t\tuv: uv\n\t\t};\n\n\t}\n\n}\n","import { intersectTri } from '../../utils/ThreeRayIntersectUtilities.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\n\n/*************************************************************/\n/* This file is generated from \"iterationUtils.template.js\". */\n/*************************************************************/\n/* eslint-disable indent */\n\nfunction intersectTris( bvh, side, ray, offset, count, intersections ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\n\t\tintersectTri( geometry, side, ray, i, intersections );\n\n\n\t}\n\n}\n\nfunction intersectClosestTri( bvh, side, ray, offset, count ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet intersection;\n\n\t\tintersection = intersectTri( geometry, side, ray, i );\n\n\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\nfunction iterateOverTriangles(\n\toffset,\n\tcount,\n\tbvh,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst { geometry } = bvh;\n\tconst { index } = geometry;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tlet tri;\n\n\t\ttri = i;\n\n\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport { intersectClosestTri, intersectTris, iterateOverTriangles };\n","import { IS_LEAFNODE_FLAG } from '../Constants.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit( bvh, nodeIndices = null ) {\n\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\tnodeIndices = new Set( nodeIndices );\n\n\t}\n\n\tconst geometry = bvh.geometry;\n\tconst indexArr = geometry.index ? geometry.index.array : null;\n\tconst posAttr = geometry.attributes.position;\n\n\tlet buffer, uint32Array, uint16Array, float32Array;\n\tlet byteOffset = 0;\n\tconst roots = bvh._roots;\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\tbuffer = roots[ i ];\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t_traverse( 0, byteOffset );\n\t\tbyteOffset += buffer.byteLength;\n\n\t}\n\n\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\tconst node16Index = node32Index * 2;\n\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\tlet minx = Infinity;\n\t\t\tlet miny = Infinity;\n\t\t\tlet minz = Infinity;\n\t\t\tlet maxx = - Infinity;\n\t\t\tlet maxy = - Infinity;\n\t\t\tlet maxz = - Infinity;\n\n\n\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\n\n\t\t\t\tlet index = indexArr[ i ];\n\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\tif ( z > maxz ) maxz = z;\n\n\t\t\t}\n\n\n\t\t\tif (\n\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t) {\n\n\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = node32Index + 8;\n\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\tconst offsetRight = right + byteOffset;\n\t\t\tlet forceChildren = force;\n\t\t\tlet includesLeft = false;\n\t\t\tlet includesRight = false;\n\n\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tincludesLeft = true;\n\t\t\t\tincludesRight = true;\n\n\t\t\t}\n\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\tlet leftChange = false;\n\t\t\tif ( traverseLeft ) {\n\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tlet rightChange = false;\n\t\t\tif ( traverseRight ) {\n\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tconst didChange = leftChange || rightChange;\n\t\t\tif ( didChange ) {\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn didChange;\n\n\t\t}\n\n\t}\n\n}\n\nexport { refit };\n","import { Box3 } from 'three';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\n\nconst _boundingBox = /* @__PURE__ */ new Box3();\nexport function intersectRay( nodeIndex32, array, ray, target ) {\n\n\tarrayToBox( nodeIndex32, array, _boundingBox );\n\treturn ray.intersectBox( _boundingBox, target );\n\n}\n","import { Vector3 } from 'three';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectTris } from '../utils/iterationUtils.generated.js';\nimport '../utils/iterationUtils_indirect.generated.js';\n\n/******************************************************/\n/* This file is generated from \"raycast.template.js\". */\n/******************************************************/\n\nconst _boxIntersection = /* @__PURE__ */ new Vector3();\nfunction raycast( bvh, root, side, ray, intersects ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t_raycast( 0, bvh, side, ray, intersects );\n\tBufferStack.clearBuffer();\n\n}\n\nfunction _raycast( nodeIndex32, bvh, side, ray, intersects ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tconst nodeIndex16 = nodeIndex32 * 2;\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\tintersectTris( bvh, side, ray, offset, count, intersects );\n\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray, _boxIntersection ) ) {\n\n\t\t\t_raycast( leftIndex, bvh, side, ray, intersects );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray, _boxIntersection ) ) {\n\n\t\t\t_raycast( rightIndex, bvh, side, ray, intersects );\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycast };\n","import { Vector3 } from 'three';\nimport { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport { intersectClosestTri } from '../utils/iterationUtils.generated.js';\nimport '../utils/iterationUtils_indirect.generated.js';\n\n/***********************************************************/\n/* This file is generated from \"raycastFirst.template.js\". */\n/***********************************************************/\nconst _boxIntersection = /* @__PURE__ */ new Vector3();\nconst _xyzFields = [ 'x', 'y', 'z' ];\nfunction raycastFirst( bvh, root, side, ray ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _raycastFirst( 0, bvh, side, ray );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _raycastFirst( nodeIndex32, bvh, side, ray ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\treturn intersectClosestTri( bvh, side, ray, offset, count );\n\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, _boxIntersection );\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, side, ray ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, _boxIntersection );\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, side, ray ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycastFirst };\n","import { Box3, Matrix4 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\n/*****************************************************************/\n/* This file is generated from \"intersectsGeometry.template.js\". */\n/*****************************************************************/\n/* eslint-disable indent */\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst triangle = /* @__PURE__ */ new ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new Matrix4();\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\n\nfunction intersectsGeometry( bvh, root, otherGeometry, geometryToBvh ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tif ( cachedObb === null ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tcachedObb = obb;\n\n\t}\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst thisGeometry = bvh.geometry;\n\t\tconst thisIndex = thisGeometry.index;\n\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\tconst index = otherGeometry.index;\n\t\tconst pos = otherGeometry.attributes.position;\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t// here.\n\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t// if there's a bounds tree\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\tobb2.needsUpdate = true;\n\n\t\t\t// TODO: use a triangle iteration function here\n\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.needsUpdate = true;\n\n\n\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\tsetTriangle( triangle2, i, thisIndex, thisPos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn res;\n\n\t\t} else {\n\n\t\t\t// if we're just dealing with raw geometry\n\n\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\tsetTriangle( triangle, i, thisIndex, thisPos );\n\n\n\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = nodeIndex32 + 8;\n\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\tconst leftIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( leftIntersection ) return true;\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\tconst rightIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( rightIntersection ) return true;\n\n\t\treturn false;\n\n\t}\n\n}\n\nexport { intersectsGeometry };\n","import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\n\nfunction closestPointToGeometry(\n\tbvh,\n\totherGeometry,\n\tgeometryToBvh,\n\ttarget1 = { },\n\ttarget2 = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\tif ( ! otherGeometry.boundingBox ) {\n\n\t\totherGeometry.computeBoundingBox();\n\n\t}\n\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\tobb.needsUpdate = true;\n\n\tconst geometry = bvh.geometry;\n\tconst pos = geometry.attributes.position;\n\tconst index = geometry.index;\n\tconst otherPos = otherGeometry.attributes.position;\n\tconst otherIndex = otherGeometry.index;\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tlet tempTarget1 = temp1;\n\tlet tempTargetDest1 = temp2;\n\tlet tempTarget2 = null;\n\tlet tempTargetDest2 = null;\n\n\tif ( target2 ) {\n\n\t\ttempTarget2 = temp3;\n\t\ttempTargetDest2 = temp4;\n\n\t}\n\n\tlet closestDistance = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tlet closestDistanceOtherTriIndex = null;\n\ttempMatrix.copy( geometryToBvh ).invert();\n\tobb2.matrix.copy( tempMatrix );\n\tbvh.shapecast(\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\tif ( closestDistance === Infinity ) {\n\n\t\treturn null;\n\n\t}\n\n\tif ( ! target1.point ) {\n\n\t\ttarget1.point = tempTargetDest1.clone();\n\n\t} else {\n\n\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t}\n\n\ttarget1.distance = closestDistance,\n\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\tif ( target2 ) {\n\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\telse target2.point.copy( tempTargetDest2 );\n\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t}\n\n\treturn target1;\n\n}\n\nexport { closestPointToGeometry };\n","import { intersectTri } from '../../utils/ThreeRayIntersectUtilities.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\n\n/*************************************************************/\n/* This file is generated from \"iterationUtils.template.js\". */\n/*************************************************************/\n/* eslint-disable indent */\n\nfunction intersectTris_indirect( bvh, side, ray, offset, count, intersections ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet vi = _indirectBuffer ? _indirectBuffer[ i ] : i;\n\t\tintersectTri( geometry, side, ray, vi, intersections );\n\n\n\t}\n\n}\n\nfunction intersectClosestTri_indirect( bvh, side, ray, offset, count ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet intersection;\n\t\tintersection = intersectTri( geometry, side, ray, _indirectBuffer ? _indirectBuffer[ i ] : i );\n\n\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\nfunction iterateOverTriangles_indirect(\n\toffset,\n\tcount,\n\tbvh,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst { geometry } = bvh;\n\tconst { index } = geometry;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tlet tri;\n\t\ttri = bvh.resolveTriangleIndex( i );\n\n\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport { intersectClosestTri_indirect, intersectTris_indirect, iterateOverTriangles_indirect };\n","import { IS_LEAFNODE_FLAG } from '../Constants.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit_indirect( bvh, nodeIndices = null ) {\n\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\tnodeIndices = new Set( nodeIndices );\n\n\t}\n\n\tconst geometry = bvh.geometry;\n\tconst indexArr = geometry.index ? geometry.index.array : null;\n\tconst posAttr = geometry.attributes.position;\n\n\tlet buffer, uint32Array, uint16Array, float32Array;\n\tlet byteOffset = 0;\n\tconst roots = bvh._roots;\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\tbuffer = roots[ i ];\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t_traverse( 0, byteOffset );\n\t\tbyteOffset += buffer.byteLength;\n\n\t}\n\n\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\tconst node16Index = node32Index * 2;\n\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\tlet minx = Infinity;\n\t\t\tlet miny = Infinity;\n\t\t\tlet minz = Infinity;\n\t\t\tlet maxx = - Infinity;\n\t\t\tlet maxy = - Infinity;\n\t\t\tlet maxz = - Infinity;\n\n\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\tconst t = 3 * bvh.resolveTriangleIndex( i );\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tlet index = t + j;\n\t\t\t\t\tindex = indexArr ? indexArr[ index ] : index;\n\n\t\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\t\tif ( z > maxz ) maxz = z;\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif (\n\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t) {\n\n\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = node32Index + 8;\n\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\tconst offsetRight = right + byteOffset;\n\t\t\tlet forceChildren = force;\n\t\t\tlet includesLeft = false;\n\t\t\tlet includesRight = false;\n\n\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tincludesLeft = true;\n\t\t\t\tincludesRight = true;\n\n\t\t\t}\n\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\tlet leftChange = false;\n\t\t\tif ( traverseLeft ) {\n\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tlet rightChange = false;\n\t\t\tif ( traverseRight ) {\n\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tconst didChange = leftChange || rightChange;\n\t\t\tif ( didChange ) {\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn didChange;\n\n\t\t}\n\n\t}\n\n}\n\nexport { refit_indirect };\n","import { Vector3 } from 'three';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport '../utils/iterationUtils.generated.js';\nimport { intersectTris_indirect } from '../utils/iterationUtils_indirect.generated.js';\n\n/******************************************************/\n/* This file is generated from \"raycast.template.js\". */\n/******************************************************/\n\nconst _boxIntersection = /* @__PURE__ */ new Vector3();\nfunction raycast_indirect( bvh, root, side, ray, intersects ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t_raycast( 0, bvh, side, ray, intersects );\n\tBufferStack.clearBuffer();\n\n}\n\nfunction _raycast( nodeIndex32, bvh, side, ray, intersects ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tconst nodeIndex16 = nodeIndex32 * 2;\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\tintersectTris_indirect( bvh, side, ray, offset, count, intersects );\n\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray, _boxIntersection ) ) {\n\n\t\t\t_raycast( leftIndex, bvh, side, ray, intersects );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray, _boxIntersection ) ) {\n\n\t\t\t_raycast( rightIndex, bvh, side, ray, intersects );\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycast_indirect };\n","import { Vector3 } from 'three';\nimport { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport '../utils/iterationUtils.generated.js';\nimport { intersectClosestTri_indirect } from '../utils/iterationUtils_indirect.generated.js';\n\n/***********************************************************/\n/* This file is generated from \"raycastFirst.template.js\". */\n/***********************************************************/\nconst _boxIntersection = /* @__PURE__ */ new Vector3();\nconst _xyzFields = [ 'x', 'y', 'z' ];\nfunction raycastFirst_indirect( bvh, root, side, ray ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _raycastFirst( 0, bvh, side, ray );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _raycastFirst( nodeIndex32, bvh, side, ray ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\treturn intersectClosestTri_indirect( bvh, side, ray, offset, count );\n\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, _boxIntersection );\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, side, ray ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, _boxIntersection );\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, side, ray ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycastFirst_indirect };\n","import { Box3, Matrix4 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\n/*****************************************************************/\n/* This file is generated from \"intersectsGeometry.template.js\". */\n/*****************************************************************/\n/* eslint-disable indent */\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst triangle = /* @__PURE__ */ new ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new Matrix4();\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\n\nfunction intersectsGeometry_indirect( bvh, root, otherGeometry, geometryToBvh ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tif ( cachedObb === null ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tcachedObb = obb;\n\n\t}\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst thisGeometry = bvh.geometry;\n\t\tconst thisIndex = thisGeometry.index;\n\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\tconst index = otherGeometry.index;\n\t\tconst pos = otherGeometry.attributes.position;\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t// here.\n\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t// if there's a bounds tree\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\tobb2.needsUpdate = true;\n\n\t\t\t// TODO: use a triangle iteration function here\n\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * bvh.resolveTriangleIndex( i ), thisIndex, thisPos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn res;\n\n\t\t} else {\n\n\t\t\t// if we're just dealing with raw geometry\n\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\tsetTriangle( triangle, 3 * ti, thisIndex, thisPos );\n\n\n\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = nodeIndex32 + 8;\n\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\tconst leftIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( leftIntersection ) return true;\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\tconst rightIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( rightIntersection ) return true;\n\n\t\treturn false;\n\n\t}\n\n}\n\nexport { intersectsGeometry_indirect };\n","import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\n\nfunction closestPointToGeometry_indirect(\n\tbvh,\n\totherGeometry,\n\tgeometryToBvh,\n\ttarget1 = { },\n\ttarget2 = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\tif ( ! otherGeometry.boundingBox ) {\n\n\t\totherGeometry.computeBoundingBox();\n\n\t}\n\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\tobb.needsUpdate = true;\n\n\tconst geometry = bvh.geometry;\n\tconst pos = geometry.attributes.position;\n\tconst index = geometry.index;\n\tconst otherPos = otherGeometry.attributes.position;\n\tconst otherIndex = otherGeometry.index;\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tlet tempTarget1 = temp1;\n\tlet tempTargetDest1 = temp2;\n\tlet tempTarget2 = null;\n\tlet tempTargetDest2 = null;\n\n\tif ( target2 ) {\n\n\t\ttempTarget2 = temp3;\n\t\ttempTargetDest2 = temp4;\n\n\t}\n\n\tlet closestDistance = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tlet closestDistanceOtherTriIndex = null;\n\ttempMatrix.copy( geometryToBvh ).invert();\n\tobb2.matrix.copy( tempMatrix );\n\tbvh.shapecast(\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * ti2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\tif ( closestDistance === Infinity ) {\n\n\t\treturn null;\n\n\t}\n\n\tif ( ! target1.point ) {\n\n\t\ttarget1.point = tempTargetDest1.clone();\n\n\t} else {\n\n\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t}\n\n\ttarget1.distance = closestDistance,\n\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\tif ( target2 ) {\n\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\telse target2.point.copy( tempTargetDest2 );\n\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t}\n\n\treturn target1;\n\n}\n\nexport { closestPointToGeometry_indirect };\n","import { Box3, Matrix4 } from 'three';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { BOUNDING_DATA_INDEX, COUNT, IS_LEAF, LEFT_NODE, OFFSET, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\n\nconst _bufferStack1 = new BufferStack.constructor();\nconst _bufferStack2 = new BufferStack.constructor();\nconst _boxPool = new PrimitivePool( () => new Box3() );\nconst _leftBox1 = new Box3();\nconst _rightBox1 = new Box3();\n\nconst _leftBox2 = new Box3();\nconst _rightBox2 = new Box3();\n\nlet _active = false;\n\nexport function bvhcast( bvh, otherBvh, matrixToLocal, intersectsRanges ) {\n\n\tif ( _active ) {\n\n\t\tthrow new Error( 'MeshBVH: Recursive calls to bvhcast not supported.' );\n\n\t}\n\n\t_active = true;\n\n\tconst roots = bvh._roots;\n\tconst otherRoots = otherBvh._roots;\n\tlet result;\n\tlet offset1 = 0;\n\tlet offset2 = 0;\n\tconst invMat = new Matrix4().copy( matrixToLocal ).invert();\n\n\t// iterate over the first set of roots\n\tfor ( let i = 0, il = roots.length; i < il; i ++ ) {\n\n\t\t_bufferStack1.setBuffer( roots[ i ] );\n\t\toffset2 = 0;\n\n\t\t// prep the initial root box\n\t\tconst localBox = _boxPool.getPrimitive();\n\t\tarrayToBox( BOUNDING_DATA_INDEX( 0 ), _bufferStack1.float32Array, localBox );\n\t\tlocalBox.applyMatrix4( invMat );\n\n\t\t// iterate over the second set of roots\n\t\tfor ( let j = 0, jl = otherRoots.length; j < jl; j ++ ) {\n\n\t\t\t_bufferStack2.setBuffer( otherRoots[ i ] );\n\n\t\t\tresult = _traverse(\n\t\t\t\t0, 0, matrixToLocal, invMat, intersectsRanges,\n\t\t\t\toffset1, offset2, 0, 0,\n\t\t\t\tlocalBox,\n\t\t\t);\n\n\t\t\t_bufferStack2.clearBuffer();\n\t\t\toffset2 += otherRoots[ j ].length;\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// release stack info\n\t\t_boxPool.releasePrimitive( localBox );\n\t\t_bufferStack1.clearBuffer();\n\t\toffset1 += roots[ i ].length;\n\n\t\tif ( result ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t_active = false;\n\treturn result;\n\n}\n\nfunction _traverse(\n\tnode1Index32,\n\tnode2Index32,\n\tmatrix2to1,\n\tmatrix1to2,\n\tintersectsRangesFunc,\n\n\t// offsets for ids\n\tnode1IndexByteOffset = 0,\n\tnode2IndexByteOffset = 0,\n\n\t// tree depth\n\tdepth1 = 0,\n\tdepth2 = 0,\n\n\tcurrBox = null,\n\treversed = false,\n\n) {\n\n\t// get the buffer stacks associated with the current indices\n\tlet bufferStack1, bufferStack2;\n\tif ( reversed ) {\n\n\t\tbufferStack1 = _bufferStack2;\n\t\tbufferStack2 = _bufferStack1;\n\n\t} else {\n\n\t\tbufferStack1 = _bufferStack1;\n\t\tbufferStack2 = _bufferStack2;\n\n\t}\n\n\t// get the local instances of the typed buffers\n\tconst\n\t\tfloat32Array1 = bufferStack1.float32Array,\n\t\tuint32Array1 = bufferStack1.uint32Array,\n\t\tuint16Array1 = bufferStack1.uint16Array,\n\t\tfloat32Array2 = bufferStack2.float32Array,\n\t\tuint32Array2 = bufferStack2.uint32Array,\n\t\tuint16Array2 = bufferStack2.uint16Array;\n\n\tconst node1Index16 = node1Index32 * 2;\n\tconst node2Index16 = node2Index32 * 2;\n\tconst isLeaf1 = IS_LEAF( node1Index16, uint16Array1 );\n\tconst isLeaf2 = IS_LEAF( node2Index16, uint16Array2 );\n\tlet result = false;\n\tif ( isLeaf2 && isLeaf1 ) {\n\n\t\t// if both bounds are leaf nodes then fire the callback if the boxes intersect\n\t\tif ( reversed ) {\n\n\t\t\tresult = intersectsRangesFunc(\n\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\tdepth2, node2IndexByteOffset + node2Index32,\n\t\t\t\tdepth1, node1IndexByteOffset + node1Index32,\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tresult = intersectsRangesFunc(\n\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\tdepth1, node1IndexByteOffset + node1Index32,\n\t\t\t\tdepth2, node2IndexByteOffset + node2Index32,\n\t\t\t);\n\n\t\t}\n\n\t} else if ( isLeaf2 ) {\n\n\t\t// SWAP\n\t\t// If we've traversed to the leaf node on the other bvh then we need to swap over\n\t\t// to traverse down the first one\n\n\t\t// get the new box to use\n\t\tconst newBox = _boxPool.getPrimitive();\n\t\tarrayToBox( BOUNDING_DATA_INDEX( node2Index32 ), float32Array2, newBox );\n\t\tnewBox.applyMatrix4( matrix2to1 );\n\n\t\t// get the child bounds to check before traversal\n\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\tresult = (\n\t\t\tintersectCl1 && _traverse(\n\t\t\t\tnode2Index32, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\tnewBox, ! reversed,\n\t\t\t)\n\t\t) || (\n\t\t\tintersectCr1 && _traverse(\n\t\t\t\tnode2Index32, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\tnewBox, ! reversed,\n\t\t\t)\n\t\t);\n\n\t\t_boxPool.releasePrimitive( newBox );\n\n\t} else {\n\n\t\t// if neither are leaves then we should swap if one of the children does not\n\t\t// intersect with the current bounds\n\n\t\t// get the child bounds to check\n\t\tconst cl2 = LEFT_NODE( node2Index32 );\n\t\tconst cr2 = RIGHT_NODE( node2Index32, uint32Array2 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cl2 ), float32Array2, _leftBox2 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cr2 ), float32Array2, _rightBox2 );\n\n\t\tconst leftIntersects = currBox.intersectsBox( _leftBox2 );\n\t\tconst rightIntersects = currBox.intersectsBox( _rightBox2 );\n\t\tif ( leftIntersects && rightIntersects ) {\n\n\t\t\t// continue to traverse both children if they both intersect\n\t\t\tresult = _traverse(\n\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\tcurrBox, reversed,\n\t\t\t) || _traverse(\n\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\tcurrBox, reversed,\n\t\t\t);\n\n\t\t} else if ( leftIntersects ) {\n\n\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\tresult = _traverse(\n\t\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// SWAP\n\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\tnewBox.copy( _leftBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\tresult = (\n\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\tcl2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t) || (\n\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\tcl2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t}\n\n\t\t} else if ( rightIntersects ) {\n\n\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\tresult = _traverse(\n\t\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// SWAP\n\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\tnewBox.copy( _rightBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\tresult = (\n\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\tcr2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t) || (\n\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\tcr2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\n","import { BufferAttribute, Box3, FrontSide } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG, SKIP_GENERATION } from './Constants.js';\nimport { buildPackedTree } from './build/buildTree.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { ExtendedTrianglePool } from '../utils/ExtendedTrianglePool.js';\nimport { shapecast } from './cast/shapecast.js';\nimport { closestPointToPoint } from './cast/closestPointToPoint.js';\n\nimport { iterateOverTriangles } from './utils/iterationUtils.generated.js';\nimport { refit } from './cast/refit.generated.js';\nimport { raycast } from './cast/raycast.generated.js';\nimport { raycastFirst } from './cast/raycastFirst.generated.js';\nimport { intersectsGeometry } from './cast/intersectsGeometry.generated.js';\nimport { closestPointToGeometry } from './cast/closestPointToGeometry.generated.js';\n\nimport { iterateOverTriangles_indirect } from './utils/iterationUtils_indirect.generated.js';\nimport { refit_indirect } from './cast/refit_indirect.generated.js';\nimport { raycast_indirect } from './cast/raycast_indirect.generated.js';\nimport { raycastFirst_indirect } from './cast/raycastFirst_indirect.generated.js';\nimport { intersectsGeometry_indirect } from './cast/intersectsGeometry_indirect.generated.js';\nimport { closestPointToGeometry_indirect } from './cast/closestPointToGeometry_indirect.generated.js';\nimport { isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\nimport { setTriangle } from '../utils/TriangleUtilities.js';\nimport { bvhcast } from './cast/bvhcast.js';\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst tempBox = /* @__PURE__ */ new Box3();\n\nexport class MeshBVH {\n\n\tstatic serialize( bvh, options = {} ) {\n\n\t\toptions = {\n\t\t\tcloneBuffers: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst rootData = bvh._roots;\n\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\tconst indexAttribute = geometry.getIndex();\n\t\tlet result;\n\t\tif ( options.cloneBuffers ) {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData.map( root => root.slice() ),\n\t\t\t\tindex: indexAttribute.array.slice(),\n\t\t\t\tindirectBuffer: indirectBuffer ? indirectBuffer.slice() : null,\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData,\n\t\t\t\tindex: indexAttribute.array,\n\t\t\t\tindirectBuffer: indirectBuffer,\n\t\t\t};\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tstatic deserialize( data, geometry, options = {} ) {\n\n\t\toptions = {\n\t\t\tsetIndex: true,\n\t\t\tindirect: Boolean( data.indirectBuffer ),\n\t\t\t...options,\n\t\t};\n\n\t\tconst { index, roots, indirectBuffer } = data;\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\n\t\tbvh._roots = roots;\n\t\tbvh._indirectBuffer = indirectBuffer || null;\n\n\t\tif ( options.setIndex ) {\n\n\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\tif ( indexAttribute === null ) {\n\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\n\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t} else if ( indexAttribute.array !== index ) {\n\n\t\t\t\tindexAttribute.array.set( index );\n\t\t\t\tindexAttribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvh;\n\n\t}\n\n\tget indirect() {\n\n\t\treturn ! ! this._indirectBuffer;\n\n\t}\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\n\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\n\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\n\n\t\t}\n\n\t\t// default options\n\t\toptions = Object.assign( {\n\n\t\t\tstrategy: CENTER,\n\t\t\tmaxDepth: 40,\n\t\t\tmaxLeafTris: 10,\n\t\t\tverbose: true,\n\t\t\tuseSharedArrayBuffer: false,\n\t\t\tsetBoundingBox: true,\n\t\t\tonProgress: null,\n\t\t\tindirect: false,\n\n\t\t\t// undocumented options\n\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\n\t\t\t[ SKIP_GENERATION ]: false,\n\n\t\t}, options );\n\n\t\tif ( options.useSharedArrayBuffer && ! isSharedArrayBufferSupported() ) {\n\n\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\n\n\t\t}\n\n\t\t// retain references to the geometry so we can use them it without having to\n\t\t// take a geometry reference in every function.\n\t\tthis.geometry = geometry;\n\t\tthis._roots = null;\n\t\tthis._indirectBuffer = null;\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\n\n\t\t\tbuildPackedTree( this, options );\n\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\n\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst { _indirectBuffer } = this;\n\t\tthis.resolveTriangleIndex = options.indirect ? i => _indirectBuffer[ i ] : i => i;\n\n\t}\n\n\trefit( nodeIndices = null ) {\n\n\t\tconst refitFunc = this.indirect ? refit_indirect : refit;\n\t\treturn refitFunc( this, nodeIndices );\n\n\t}\n\n\ttraverse( callback, rootIndex = 0 ) {\n\n\t\tconst buffer = this._roots[ rootIndex ];\n\t\tconst uint32Array = new Uint32Array( buffer );\n\t\tconst uint16Array = new Uint16Array( buffer );\n\t\t_traverse( 0 );\n\n\t\tfunction _traverse( node32Index, depth = 0 ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\n\n\t\t\t} else {\n\n\t\t\t\t// TODO: use node functions here\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\n\n\t\t\t\tif ( ! stopTraversal ) {\n\n\t\t\t\t\t_traverse( left, depth + 1 );\n\t\t\t\t\t_traverse( right, depth + 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Core Cast Functions */\n\traycast( ray, materialOrSide = FrontSide ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst intersects = [];\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tconst raycastFunc = this.indirect ? raycast_indirect : raycast;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst startCount = intersects.length;\n\n\t\t\traycastFunc( this, i, materialSide, ray, intersects );\n\n\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\n\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn intersects;\n\n\t}\n\n\traycastFirst( ray, materialOrSide = FrontSide ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tlet closestResult = null;\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tconst raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst result = raycastFirstFunc( this, i, materialSide, ray );\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\n\n\t\t\t\tclosestResult = result;\n\t\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn closestResult;\n\n\t}\n\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\n\n\t\tlet result = false;\n\t\tconst roots = this._roots;\n\t\tconst intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tresult = intersectsGeometryFunc( this, i, otherGeometry, geomToMesh );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tshapecast( callbacks ) {\n\n\t\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\t\tconst iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;\n\t\tlet {\n\t\t\tboundsTraverseOrder,\n\t\t\tintersectsBounds,\n\t\t\tintersectsRange,\n\t\t\tintersectsTriangle,\n\t\t} = callbacks;\n\n\t\t// wrap the intersectsRange function\n\t\tif ( intersectsRange && intersectsTriangle ) {\n\n\t\t\tconst originalIntersectsRange = intersectsRange;\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\n\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\n\n\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t} else if ( ! intersectsRange ) {\n\n\t\t\tif ( intersectsTriangle ) {\n\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\n\n\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\n\n\t\t\t\t\treturn contained;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\t// run shapecast\n\t\tlet result = false;\n\t\tlet byteOffset = 0;\n\t\tconst roots = this._roots;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst root = roots[ i ];\n\t\t\tresult = shapecast( this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tbyteOffset += root.byteLength;\n\n\t\t}\n\n\t\tExtendedTrianglePool.releasePrimitive( triangle );\n\n\t\treturn result;\n\n\t}\n\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\n\n\t\tlet {\n\t\t\tintersectsRanges,\n\t\t\tintersectsTriangles,\n\t\t} = callbacks;\n\n\t\tconst triangle1 = ExtendedTrianglePool.getPrimitive();\n\t\tconst indexAttr1 = this.geometry.index;\n\t\tconst positionAttr1 = this.geometry.attributes.position;\n\t\tconst assignTriangle1 = this.indirect ?\n\t\t\ti1 => {\n\n\n\t\t\t\tconst ti = this.resolveTriangleIndex( i1 );\n\t\t\t\tsetTriangle( triangle1, ti * 3, indexAttr1, positionAttr1 );\n\n\t\t\t} :\n\t\t\ti1 => {\n\n\t\t\t\tsetTriangle( triangle1, i1 * 3, indexAttr1, positionAttr1 );\n\n\t\t\t};\n\n\t\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\t\tconst indexAttr2 = otherBvh.geometry.index;\n\t\tconst positionAttr2 = otherBvh.geometry.attributes.position;\n\t\tconst assignTriangle2 = otherBvh.indirect ?\n\t\t\ti2 => {\n\n\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\tsetTriangle( triangle2, ti2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t} :\n\t\t\ti2 => {\n\n\t\t\t\tsetTriangle( triangle2, i2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t};\n\n\t\t// generate triangle callback if needed\n\t\tif ( intersectsTriangles ) {\n\n\t\t\tconst iterateOverDoubleTriangles = ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) => {\n\n\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\tassignTriangle2( i2 );\n\n\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\n\n\t\t\t\t\t\tassignTriangle1( i1 );\n\n\t\t\t\t\t\ttriangle1.needsUpdate = true;\n\n\t\t\t\t\t\tif ( intersectsTriangles( triangle1, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t};\n\n\t\t\tif ( intersectsRanges ) {\n\n\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\n\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvhcast( this, otherBvh, matrixToLocal, intersectsRanges );\n\n\t}\n\n\n\t/* Derived Cast Functions */\n\tintersectsBox( box, boxToMesh ) {\n\n\t\tobb.set( box.min, box.max, boxToMesh );\n\t\tobb.needsUpdate = true;\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\tconst closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;\n\t\treturn closestPointToGeometryFunc(\n\t\t\tthis,\n\t\t\totherGeometry,\n\t\t\tgeometryToBvh,\n\t\t\ttarget1,\n\t\t\ttarget2,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\treturn closestPointToPoint(\n\t\t\tthis,\n\t\t\tpoint,\n\t\t\ttarget,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\ttarget.makeEmpty();\n\n\t\tconst roots = this._roots;\n\t\troots.forEach( buffer => {\n\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\n\t\t\ttarget.union( tempBox );\n\n\t\t} );\n\n\t\treturn target;\n\n\t}\n\n}\n","export function isSharedArrayBufferSupported() {\n\n\treturn typeof SharedArrayBuffer !== 'undefined';\n\n}\n","const HASH_WIDTH = 1e-6;\nconst HASH_HALF_WIDTH = HASH_WIDTH * 0.5;\nconst HASH_MULTIPLIER = Math.pow( 10, - Math.log10( HASH_WIDTH ) );\nconst HASH_ADDITION = HASH_HALF_WIDTH * HASH_MULTIPLIER;\nexport function hashNumber( v ) {\n\n\treturn ~ ~ ( v * HASH_MULTIPLIER + HASH_ADDITION );\n\n}\n\nexport function hashVertex2( v ) {\n\n\treturn `${ hashNumber( v.x ) },${ hashNumber( v.y ) }`;\n\n}\n\nexport function hashVertex3( v ) {\n\n\treturn `${ hashNumber( v.x ) },${ hashNumber( v.y ) },${ hashNumber( v.z ) }`;\n\n}\n\nexport function hashVertex4( v ) {\n\n\treturn `${ hashNumber( v.x ) },${ hashNumber( v.y ) },${ hashNumber( v.z ) },${ hashNumber( v.w ) }`;\n\n}\n\nexport function hashRay( r ) {\n\n\treturn `${ hashVertex3( r.origin ) }-${ hashVertex3( r.direction ) }`;\n\n}\n\nexport function toNormalizedRay( v0, v1, target ) {\n\n\t// get a normalized direction\n\ttarget\n\t\t.direction\n\t\t.subVectors( v1, v0 )\n\t\t.normalize();\n\n\t// project the origin onto the perpendicular plane that\n\t// passes through 0, 0, 0\n\tconst scalar = v0.dot( target.direction );\n\ttarget.\n\t\torigin\n\t\t.copy( v0 )\n\t\t.addScaledVector( target.direction, - scalar );\n\n\treturn target;\n\n}\n","import { BufferAttribute } from 'three';\n\nexport function areSharedArrayBuffersSupported() {\n\n\treturn typeof SharedArrayBuffer !== 'undefined';\n\n}\n\nexport function convertToSharedArrayBuffer( array ) {\n\n\tif ( array.buffer instanceof SharedArrayBuffer ) {\n\n\t\treturn array;\n\n\t}\n\n\tconst cons = array.constructor;\n\tconst buffer = array.buffer;\n\tconst sharedBuffer = new SharedArrayBuffer( buffer.byteLength );\n\n\tconst uintArray = new Uint8Array( buffer );\n\tconst sharedUintArray = new Uint8Array( sharedBuffer );\n\tsharedUintArray.set( uintArray, 0 );\n\n\treturn new cons( sharedBuffer );\n\n}\n\nexport function getIndexArray( vertexCount, BufferConstructor = ArrayBuffer ) {\n\n\tif ( vertexCount > 65535 ) {\n\n\t\treturn new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\n\n\t} else {\n\n\t\treturn new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\n\n\t}\n\n}\n\nexport function ensureIndex( geo, options ) {\n\n\tif ( ! geo.index ) {\n\n\t\tconst vertexCount = geo.attributes.position.count;\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\tconst index = getIndexArray( vertexCount, BufferConstructor );\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\n\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tindex[ i ] = i;\n\n\t\t}\n\n\t}\n\n}\n\nexport function getVertexCount( geo ) {\n\n\treturn geo.index ? geo.index.count : geo.attributes.position.count;\n\n}\n\nexport function getTriCount( geo ) {\n\n\treturn getVertexCount( geo ) / 3;\n\n}\n","import { Vector3 } from 'three';\n\nconst DEGENERATE_EPSILON = 1e-8;\nconst _tempVec = new Vector3();\n\nexport function toTriIndex( v ) {\n\n\treturn ~ ~ ( v / 3 );\n\n}\n\nexport function toEdgeIndex( v ) {\n\n\treturn v % 3;\n\n}\n\nexport function sortEdgeFunc( a, b ) {\n\n\treturn a.start - b.start;\n\n}\n\nexport function getProjectedDistance( ray, vec ) {\n\n\treturn _tempVec.subVectors( vec, ray.origin ).dot( ray.direction );\n\n}\n\nexport function hasOverlaps( arr ) {\n\n\tarr = [ ...arr ].sort( sortEdgeFunc );\n\tfor ( let i = 0, l = arr.length; i < l - 1; i ++ ) {\n\n\t\tconst info0 = arr[ i ];\n\t\tconst info1 = arr[ i + 1 ];\n\n\t\tif ( info1.start < info0.end && Math.abs( info1.start - info0.end ) > 1e-5 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport function getEdgeSetLength( arr ) {\n\n\tlet tot = 0;\n\tarr.forEach( ( { start, end } ) => tot += end - start );\n\treturn tot;\n\n}\n\nexport function matchEdges( forward, reverse, disjointConnectivityMap, eps = DEGENERATE_EPSILON ) {\n\n\tforward.sort( sortEdgeFunc );\n\treverse.sort( sortEdgeFunc );\n\n\tfor ( let i = 0; i < forward.length; i ++ ) {\n\n\t\tconst e0 = forward[ i ];\n\t\tfor ( let o = 0; o < reverse.length; o ++ ) {\n\n\t\t\tconst e1 = reverse[ o ];\n\t\t\tif ( e1.start > e0.end ) {\n\n\t\t\t\t// e2 is completely after e1\n\t\t\t\t// break;\n\n\t\t\t\t// NOTE: there are cases where there are overlaps due to precision issues or\n\t\t\t\t// thin / degenerate triangles. Assuming the sibling side has the same issues\n\t\t\t\t// we let the matching work here. Long term we should remove the degenerate\n\t\t\t\t// triangles before this.\n\n\t\t\t} else if ( e0.end < e1.start || e1.end < e0.start ) {\n\n\t\t\t\t// e1 is completely before e2\n\t\t\t\tcontinue;\n\n\t\t\t} else if ( e0.start <= e1.start && e0.end >= e1.end ) {\n\n\t\t\t\t// e1 is larger than and e2 is completely within e1\n\t\t\t\tif ( ! areDistancesDegenerate( e1.end, e0.end ) ) {\n\n\t\t\t\t\tforward.splice( i + 1, 0, {\n\t\t\t\t\t\tstart: e1.end,\n\t\t\t\t\t\tend: e0.end,\n\t\t\t\t\t\tindex: e0.index,\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\te0.end = e1.start;\n\n\t\t\t\te1.start = 0;\n\t\t\t\te1.end = 0;\n\n\t\t\t} else if ( e0.start >= e1.start && e0.end <= e1.end ) {\n\n\t\t\t\t// e2 is larger than and e1 is completely within e2\n\t\t\t\tif ( ! areDistancesDegenerate( e0.end, e1.end ) ) {\n\n\t\t\t\t\treverse.splice( o + 1, 0, {\n\t\t\t\t\t\tstart: e0.end,\n\t\t\t\t\t\tend: e1.end,\n\t\t\t\t\t\tindex: e1.index,\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\te1.end = e0.start;\n\n\t\t\t\te0.start = 0;\n\t\t\t\te0.end = 0;\n\n\t\t\t} else if ( e0.start <= e1.start && e0.end <= e1.end ) {\n\n\t\t\t\t// e1 overlaps e2 at the beginning\n\t\t\t\tconst tmp = e0.end;\n\t\t\t\te0.end = e1.start;\n\t\t\t\te1.start = tmp;\n\n\t\t\t} else if ( e0.start >= e1.start && e0.end >= e1.end ) {\n\n\t\t\t\t// e1 overlaps e2 at the end\n\t\t\t\tconst tmp = e1.end;\n\t\t\t\te1.end = e0.start;\n\t\t\t\te0.start = tmp;\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error();\n\n\t\t\t}\n\n\t\t\t// Add the connectivity information\n\t\t\tif ( ! disjointConnectivityMap.has( e0.index ) ) {\n\n\t\t\t\tdisjointConnectivityMap.set( e0.index, [] );\n\n\t\t\t}\n\n\t\t\tif ( ! disjointConnectivityMap.has( e1.index ) ) {\n\n\t\t\t\tdisjointConnectivityMap.set( e1.index, [] );\n\n\t\t\t}\n\n\t\t\tdisjointConnectivityMap\n\t\t\t\t.get( e0.index )\n\t\t\t\t.push( e1.index );\n\n\t\t\tdisjointConnectivityMap\n\t\t\t\t.get( e1.index )\n\t\t\t\t.push( e0.index );\n\n\t\t\tif ( isEdgeDegenerate( e1 ) ) {\n\n\t\t\t\treverse.splice( o, 1 );\n\t\t\t\to --;\n\n\t\t\t}\n\n\t\t\tif ( isEdgeDegenerate( e0 ) ) {\n\n\t\t\t\t// and if we have to remove the current original edge then exit this loop\n\t\t\t\t// so we can work on the next one\n\t\t\t\tforward.splice( i, 1 );\n\t\t\t\ti --;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcleanUpEdgeSet( forward );\n\tcleanUpEdgeSet( reverse );\n\n\tfunction cleanUpEdgeSet( arr ) {\n\n\t\tfor ( let i = 0; i < arr.length; i ++ ) {\n\n\t\t\tif ( isEdgeDegenerate( arr[ i ] ) ) {\n\n\t\t\t\tarr.splice( i, 1 );\n\t\t\t\ti --;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction areDistancesDegenerate( start, end ) {\n\n\t\treturn Math.abs( end - start ) < eps;\n\n\t}\n\n\tfunction isEdgeDegenerate( e ) {\n\n\t\treturn Math.abs( e.end - e.start ) < eps;\n\n\t}\n\n}\n","const DIST_EPSILON = 1e-5;\nconst ANGLE_EPSILON = 1e-4;\n\nexport class RaySet {\n\n\tconstructor() {\n\n\t\tthis._rays = [];\n\n\t}\n\n\taddRay( ray ) {\n\n\t\tthis._rays.push( ray );\n\n\t}\n\n\tfindClosestRay( ray ) {\n\n\t\tconst rays = this._rays;\n\t\tconst inv = ray.clone();\n\t\tinv.direction.multiplyScalar( - 1 );\n\n\t\tlet bestScore = Infinity;\n\t\tlet bestRay = null;\n\t\tfor ( let i = 0, l = rays.length; i < l; i ++ ) {\n\n\t\t\tconst r = rays[ i ];\n\t\t\tif ( skipRay( r, ray ) && skipRay( r, inv ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst rayScore = scoreRays( r, ray );\n\t\t\tconst invScore = scoreRays( r, inv );\n\t\t\tconst score = Math.min( rayScore, invScore );\n\t\t\tif ( score < bestScore ) {\n\n\t\t\t\tbestScore = score;\n\t\t\t\tbestRay = r;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bestRay;\n\n\t\tfunction skipRay( r0, r1 ) {\n\n\t\t\tconst distOutOfThreshold = r0.origin.distanceTo( r1.origin ) > DIST_EPSILON;\n\t\t\tconst angleOutOfThreshold = r0.direction.angleTo( r1.direction ) > ANGLE_EPSILON;\n\t\t\treturn angleOutOfThreshold || distOutOfThreshold;\n\n\t\t}\n\n\t\tfunction scoreRays( r0, r1 ) {\n\n\t\t\tconst originDistance = r0.origin.distanceTo( r1.origin );\n\t\t\tconst angleDistance = r0.direction.angleTo( r1.direction );\n\t\t\treturn originDistance / DIST_EPSILON + angleDistance / ANGLE_EPSILON;\n\n\t\t}\n\n\t}\n\n}\n","import { Vector3, Ray } from 'three';\nimport { toEdgeIndex, toTriIndex, matchEdges, getProjectedDistance } from './halfEdgeUtils.js';\nimport { toNormalizedRay } from './hashUtils.js';\nimport { RaySet } from './RaySet.js';\n\nconst _v0 = new Vector3();\nconst _v1 = new Vector3();\nconst _ray = new Ray();\n\nexport function computeDisjointEdges(\n\tgeometry,\n\tunmatchedSet,\n\teps,\n) {\n\n\tconst attributes = geometry.attributes;\n\tconst indexAttr = geometry.index;\n\tconst posAttr = attributes.position;\n\n\tconst disjointConnectivityMap = new Map();\n\tconst fragmentMap = new Map();\n\tconst edges = Array.from( unmatchedSet );\n\tconst rays = new RaySet();\n\n\tfor ( let i = 0, l = edges.length; i < l; i ++ ) {\n\n\t\t// get the triangle edge\n\t\tconst index = edges[ i ];\n\t\tconst triIndex = toTriIndex( index );\n\t\tconst edgeIndex = toEdgeIndex( index );\n\n\t\tlet i0 = 3 * triIndex + edgeIndex;\n\t\tlet i1 = 3 * triIndex + ( edgeIndex + 1 ) % 3;\n\t\tif ( indexAttr ) {\n\n\t\t\ti0 = indexAttr.getX( i0 );\n\t\t\ti1 = indexAttr.getX( i1 );\n\n\t\t}\n\n\t\t_v0.fromBufferAttribute( posAttr, i0 );\n\t\t_v1.fromBufferAttribute( posAttr, i1 );\n\n\t\t// get the ray corresponding to the edge\n\t\ttoNormalizedRay( _v0, _v1, _ray );\n\n\t\t// find the shared ray with other edges\n\t\tlet info;\n\t\tlet commonRay = rays.findClosestRay( _ray );\n\t\tif ( commonRay === null ) {\n\n\t\t\tcommonRay = _ray.clone();\n\t\t\trays.addRay( commonRay );\n\n\t\t}\n\n\t\tif ( ! fragmentMap.has( commonRay ) ) {\n\n\t\t\tfragmentMap.set( commonRay, {\n\n\t\t\t\tforward: [],\n\t\t\t\treverse: [],\n\t\t\t\tray: commonRay,\n\n\t\t\t} );\n\n\t\t}\n\n\t\tinfo = fragmentMap.get( commonRay );\n\n\t\t// store the stride of edge endpoints along the ray\n\t\tlet start = getProjectedDistance( commonRay, _v0 );\n\t\tlet end = getProjectedDistance( commonRay, _v1 );\n\t\tif ( start > end ) {\n\n\t\t\t[ start, end ] = [ end, start ];\n\n\t\t}\n\n\t\tif ( _ray.direction.dot( commonRay.direction ) < 0 ) {\n\n\t\t\tinfo.reverse.push( { start, end, index } );\n\n\t\t} else {\n\n\t\t\tinfo.forward.push( { start, end, index } );\n\n\t\t}\n\n\t}\n\n\t// match the found sibling edges\n\tfragmentMap.forEach( ( { forward, reverse }, ray ) => {\n\n\t\tmatchEdges( forward, reverse, disjointConnectivityMap, eps );\n\n\t\tif ( forward.length === 0 && reverse.length === 0 ) {\n\n\t\t\tfragmentMap.delete( ray );\n\n\t\t}\n\n\t} );\n\n\treturn {\n\t\tdisjointConnectivityMap,\n\t\tfragmentMap,\n\t};\n\n}\n\n","import { Vector2, Vector3, Vector4 } from 'three';\nimport { hashNumber, hashVertex2, hashVertex3, hashVertex4 } from './utils/hashUtils.js';\nimport { getTriCount } from './utils/geometryUtils.js';\nimport { computeDisjointEdges } from './utils/computeDisjointEdges.js';\n\nconst _vec2 = new Vector2();\nconst _vec3 = new Vector3();\nconst _vec4 = new Vector4();\nconst _hashes = [ '', '', '' ];\n\nexport class HalfEdgeMap {\n\n\tconstructor( geometry = null ) {\n\n\t\t// result data\n\t\tthis.data = null;\n\t\tthis.disjointConnections = null;\n\t\tthis.unmatchedDisjointEdges = null;\n\t\tthis.unmatchedEdges = - 1;\n\t\tthis.matchedEdges = - 1;\n\n\t\t// options\n\t\tthis.useDrawRange = true;\n\t\tthis.useAllAttributes = false;\n\t\tthis.matchDisjointEdges = false;\n\t\tthis.degenerateEpsilon = 1e-8;\n\n\t\tif ( geometry ) {\n\n\t\t\tthis.updateFrom( geometry );\n\n\t\t}\n\n\t}\n\n\tgetSiblingTriangleIndex( triIndex, edgeIndex ) {\n\n\t\tconst otherIndex = this.data[ triIndex * 3 + edgeIndex ];\n\t\treturn otherIndex === - 1 ? - 1 : ~ ~ ( otherIndex / 3 );\n\n\t}\n\n\tgetSiblingEdgeIndex( triIndex, edgeIndex ) {\n\n\t\tconst otherIndex = this.data[ triIndex * 3 + edgeIndex ];\n\t\treturn otherIndex === - 1 ? - 1 : ( otherIndex % 3 );\n\n\t}\n\n\tgetDisjointSiblingTriangleIndices( triIndex, edgeIndex ) {\n\n\t\tconst index = triIndex * 3 + edgeIndex;\n\t\tconst arr = this.disjointConnections.get( index );\n\t\treturn arr ? arr.map( i => ~ ~ ( i / 3 ) ) : [];\n\n\t}\n\n\tgetDisjointSiblingEdgeIndices( triIndex, edgeIndex ) {\n\n\t\tconst index = triIndex * 3 + edgeIndex;\n\t\tconst arr = this.disjointConnections.get( index );\n\t\treturn arr ? arr.map( i => i % 3 ) : [];\n\n\t}\n\n\tisFullyConnected() {\n\n\t\treturn this.unmatchedEdges === 0;\n\n\t}\n\n\tupdateFrom( geometry ) {\n\n\t\tconst { useAllAttributes, useDrawRange, matchDisjointEdges, degenerateEpsilon } = this;\n\t\tconst hashFunction = useAllAttributes ? hashAllAttributes : hashPositionAttribute;\n\n\t\t// runs on the assumption that there is a 1 : 1 match of edges\n\t\tconst map = new Map();\n\n\t\t// attributes\n\t\tconst { attributes } = geometry;\n\t\tconst attrKeys = useAllAttributes ? Object.keys( attributes ) : null;\n\t\tconst indexAttr = geometry.index;\n\t\tconst posAttr = attributes.position;\n\n\t\t// get the potential number of triangles\n\t\tlet triCount = getTriCount( geometry );\n\t\tconst maxTriCount = triCount;\n\n\t\t// get the real number of triangles from the based on the draw range\n\t\tlet offset = 0;\n\t\tif ( useDrawRange ) {\n\n\t\t\toffset = geometry.drawRange.start;\n\t\t\tif ( geometry.drawRange.count !== Infinity ) {\n\n\t\t\t\ttriCount = ~ ~ ( geometry.drawRange.count / 3 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// initialize the connectivity buffer - 1 means no connectivity\n\t\tlet data = this.data;\n\t\tif ( ! data || data.length < 3 * maxTriCount ) {\n\n\t\t\tdata = new Int32Array( 3 * maxTriCount );\n\n\t\t}\n\n\t\tdata.fill( - 1 );\n\n\t\t// iterate over all triangles\n\t\tlet matchedEdges = 0;\n\t\tlet unmatchedSet = new Set();\n\t\tfor ( let i = offset, l = triCount * 3 + offset; i < l; i += 3 ) {\n\n\t\t\tconst i3 = i;\n\t\t\tfor ( let e = 0; e < 3; e ++ ) {\n\n\t\t\t\tlet i0 = i3 + e;\n\t\t\t\tif ( indexAttr ) {\n\n\t\t\t\t\ti0 = indexAttr.getX( i0 );\n\n\t\t\t\t}\n\n\t\t\t\t_hashes[ e ] = hashFunction( i0 );\n\n\t\t\t}\n\n\t\t\tfor ( let e = 0; e < 3; e ++ ) {\n\n\t\t\t\tconst nextE = ( e + 1 ) % 3;\n\t\t\t\tconst vh0 = _hashes[ e ];\n\t\t\t\tconst vh1 = _hashes[ nextE ];\n\n\t\t\t\tconst reverseHash = `${ vh1 }_${ vh0 }`;\n\t\t\t\tif ( map.has( reverseHash ) ) {\n\n\t\t\t\t\t// create a reference between the two triangles and clear the hash\n\t\t\t\t\tconst index = i3 + e;\n\t\t\t\t\tconst otherIndex = map.get( reverseHash );\n\t\t\t\t\tdata[ index ] = otherIndex;\n\t\t\t\t\tdata[ otherIndex ] = index;\n\t\t\t\t\tmap.delete( reverseHash );\n\t\t\t\t\tmatchedEdges += 2;\n\t\t\t\t\tunmatchedSet.delete( otherIndex );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// save the triangle and triangle edge index captured in one value\n\t\t\t\t\t// triIndex = ~ ~ ( i0 / 3 );\n\t\t\t\t\t// edgeIndex = i0 % 3;\n\t\t\t\t\tconst hash = `${ vh0 }_${ vh1 }`;\n\t\t\t\t\tconst index = i3 + e;\n\t\t\t\t\tmap.set( hash, index );\n\t\t\t\t\tunmatchedSet.add( index );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( matchDisjointEdges ) {\n\n\t\t\tconst {\n\t\t\t\tfragmentMap,\n\t\t\t\tdisjointConnectivityMap,\n\t\t\t} = computeDisjointEdges( geometry, unmatchedSet, degenerateEpsilon );\n\n\t\t\tunmatchedSet.clear();\n\t\t\tfragmentMap.forEach( ( { forward, reverse } ) => {\n\n\t\t\t\tforward.forEach( ( { index } ) => unmatchedSet.add( index ) );\n\t\t\t\treverse.forEach( ( { index } ) => unmatchedSet.add( index ) );\n\n\t\t\t} );\n\n\t\t\tthis.unmatchedDisjointEdges = fragmentMap;\n\t\t\tthis.disjointConnections = disjointConnectivityMap;\n\t\t\tmatchedEdges = triCount * 3 - unmatchedSet.size;\n\n\t\t}\n\n\t\tthis.matchedEdges = matchedEdges;\n\t\tthis.unmatchedEdges = unmatchedSet.size;\n\t\tthis.data = data;\n\n\t\tfunction hashPositionAttribute( i ) {\n\n\t\t\t_vec3.fromBufferAttribute( posAttr, i );\n\t\t\treturn hashVertex3( _vec3 );\n\n\t\t}\n\n\t\tfunction hashAllAttributes( i ) {\n\n\t\t\tlet result = '';\n\t\t\tfor ( let k = 0, l = attrKeys.length; k < l; k ++ ) {\n\n\t\t\t\tconst attr = attributes[ attrKeys[ k ] ];\n\t\t\t\tlet str;\n\t\t\t\tswitch ( attr.itemSize ) {\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tstr = hashNumber( attr.getX( i ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tstr = hashVertex2( _vec2.fromBufferAttribute( attr, i ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tstr = hashVertex3( _vec3.fromBufferAttribute( attr, i ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tstr = hashVertex4( _vec4.fromBufferAttribute( attr, i ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( result !== '' ) {\n\n\t\t\t\t\tresult += '|';\n\n\t\t\t\t}\n\n\t\t\t\tresult += str;\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t}\n\n}\n","import { Mesh, Matrix4 } from 'three';\nimport { MeshBVH } from 'three-mesh-bvh';\nimport { HalfEdgeMap } from './HalfEdgeMap.js';\nimport { areSharedArrayBuffersSupported, convertToSharedArrayBuffer, ensureIndex, getTriCount } from './utils/geometryUtils.js';\n\nexport class Brush extends Mesh {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.isBrush = true;\n\t\tthis._previousMatrix = new Matrix4();\n\t\tthis._previousMatrix.elements.fill( 0 );\n\n\t}\n\n\tmarkUpdated() {\n\n\t\tthis._previousMatrix.copy( this.matrix );\n\n\t}\n\n\tisDirty() {\n\n\t\tconst { matrix, _previousMatrix } = this;\n\t\tconst el1 = matrix.elements;\n\t\tconst el2 = _previousMatrix.elements;\n\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\tif ( el1[ i ] !== el2[ i ] ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tprepareGeometry() {\n\n\t\t// generate shared array buffers\n\t\tconst geometry = this.geometry;\n\t\tconst attributes = geometry.attributes;\n\t\tconst useSharedArrayBuffer = areSharedArrayBuffersSupported();\n\t\tif ( useSharedArrayBuffer ) {\n\n\t\t\tfor ( const key in attributes ) {\n\n\t\t\t\tconst attribute = attributes[ key ];\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\tthrow new Error( 'Brush: InterleavedBufferAttributes are not supported.' );\n\n\t\t\t\t}\n\n\t\t\t\tattribute.array = convertToSharedArrayBuffer( attribute.array );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate bounds tree\n\t\tif ( ! geometry.boundsTree ) {\n\n\t\t\tensureIndex( geometry, { useSharedArrayBuffer } );\n\t\t\tgeometry.boundsTree = new MeshBVH( geometry, { maxLeafTris: 3, indirect: true, useSharedArrayBuffer } );\n\n\t\t}\n\n\t\t// generate half edges\n\t\tif ( ! geometry.halfEdges ) {\n\n\t\t\tgeometry.halfEdges = new HalfEdgeMap( geometry );\n\n\t\t}\n\n\t\t// save group indices for materials\n\t\tif ( ! geometry.groupIndices ) {\n\n\t\t\tconst triCount = getTriCount( geometry );\n\t\t\tconst array = new Uint16Array( triCount );\n\t\t\tconst groups = geometry.groups;\n\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\tconst { start, count } = groups[ i ];\n\t\t\t\tfor ( let g = start / 3, lg = ( start + count ) / 3; g < lg; g ++ ) {\n\n\t\t\t\t\tarray[ g ] = i;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.groupIndices = array;\n\n\t\t}\n\n\t}\n\n\tdisposeCacheData() {\n\n\t\tconst { geometry } = this;\n\t\tgeometry.halfEdges = null;\n\t\tgeometry.boundsTree = null;\n\t\tgeometry.groupIndices = null;\n\n\t}\n\n}\n","import { Vector3 } from 'three';\n\nconst EPSILON = 1e-14;\nconst _AB = new Vector3();\nconst _AC = new Vector3();\nconst _CB = new Vector3();\n\nexport function isTriDegenerate( tri, eps = EPSILON ) {\n\n\t// compute angles to determine whether they're degenerate\n\t_AB.subVectors( tri.b, tri.a );\n\t_AC.subVectors( tri.c, tri.a );\n\t_CB.subVectors( tri.b, tri.c );\n\n\tconst angle1 = _AB.angleTo( _AC );\t\t\t\t// AB v AC\n\tconst angle2 = _AB.angleTo( _CB );\t\t\t\t// AB v BC\n\tconst angle3 = Math.PI - angle1 - angle2;\t\t// 180deg - angle1 - angle2\n\n\treturn Math.abs( angle1 ) < eps ||\n\t\tMath.abs( angle2 ) < eps ||\n\t\tMath.abs( angle3 ) < eps ||\n\t\ttri.a.distanceToSquared( tri.b ) < eps ||\n\t\ttri.a.distanceToSquared( tri.c ) < eps ||\n\t\ttri.b.distanceToSquared( tri.c ) < eps;\n\n}\n","import { Triangle, Line3, Vector3, Plane } from 'three';\nimport { ExtendedTriangle } from 'three-mesh-bvh';\nimport { isTriDegenerate } from './utils/triangleUtils.js';\n\n// NOTE: these epsilons likely should all be the same since they're used to measure the\n// distance from a point to a plane which needs to be done consistently\nconst EPSILON = 1e-10;\nconst COPLANAR_EPSILON = 1e-10;\nconst PARALLEL_EPSILON = 1e-10;\nconst _edge = new Line3();\nconst _foundEdge = new Line3();\nconst _vec = new Vector3();\nconst _triangleNormal = new Vector3();\nconst _planeNormal = new Vector3();\nconst _plane = new Plane();\nconst _splittingTriangle = new ExtendedTriangle();\n\n// A pool of triangles to avoid unnecessary triangle creation\nclass TrianglePool {\n\n\tconstructor() {\n\n\t\tthis._pool = [];\n\t\tthis._index = 0;\n\n\t}\n\n\tgetTriangle() {\n\n\t\tif ( this._index >= this._pool.length ) {\n\n\t\t\tthis._pool.push( new Triangle() );\n\n\t\t}\n\n\t\treturn this._pool[ this._index ++ ];\n\n\t}\n\n\tclear() {\n\n\t\tthis._index = 0;\n\n\t}\n\n\treset() {\n\n\t\tthis._pool.length = 0;\n\t\tthis._index = 0;\n\n\t}\n\n}\n\n// Utility class for splitting triangles\nexport class TriangleSplitter {\n\n\tconstructor() {\n\n\t\tthis.trianglePool = new TrianglePool();\n\t\tthis.triangles = [];\n\t\tthis.normal = new Vector3();\n\t\tthis.coplanarTriangleUsed = false;\n\n\t}\n\n\t// initialize the class with a triangle\n\tinitialize( tri ) {\n\n\t\tthis.reset();\n\n\t\tconst { triangles, trianglePool, normal } = this;\n\t\tif ( Array.isArray( tri ) ) {\n\n\t\t\tfor ( let i = 0, l = tri.length; i < l; i ++ ) {\n\n\t\t\t\tconst t = tri[ i ];\n\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\tt.getNormal( normal );\n\n\t\t\t\t} else if ( Math.abs( 1.0 - t.getNormal( _vec ).dot( normal ) ) > EPSILON ) {\n\n\t\t\t\t\tthrow new Error( 'Triangle Splitter: Cannot initialize with triangles that have different normals.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst poolTri = trianglePool.getTriangle();\n\t\t\t\tpoolTri.copy( t );\n\t\t\t\ttriangles.push( poolTri );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\ttri.getNormal( normal );\n\n\t\t\tconst poolTri = trianglePool.getTriangle();\n\t\t\tpoolTri.copy( tri );\n\t\t\ttriangles.push( poolTri );\n\n\t\t}\n\n\t}\n\n\t// Split the current set of triangles by passing a single triangle in. If the triangle is\n\t// coplanar it will attempt to split by the triangle edge planes\n\tsplitByTriangle( triangle ) {\n\n\t\tconst { normal, triangles } = this;\n\t\ttriangle.getNormal( _triangleNormal ).normalize();\n\n\t\tif ( Math.abs( 1.0 - Math.abs( _triangleNormal.dot( normal ) ) ) < PARALLEL_EPSILON ) {\n\n\t\t\tthis.coplanarTriangleUsed = true;\n\n\t\t\tfor ( let i = 0, l = triangles.length; i < l; i ++ ) {\n\n\t\t\t\tconst t = triangles[ i ];\n\t\t\t\tt.coplanarCount = 0;\n\n\t\t\t}\n\n\t\t\t// if the triangle is coplanar then split by the edge planes\n\t\t\tconst arr = [ triangle.a, triangle.b, triangle.c ];\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst nexti = ( i + 1 ) % 3;\n\n\t\t\t\tconst v0 = arr[ i ];\n\t\t\t\tconst v1 = arr[ nexti ];\n\n\t\t\t\t// plane positive direction is toward triangle center\n\t\t\t\t_vec.subVectors( v1, v0 ).normalize();\n\t\t\t\t_planeNormal.crossVectors( _triangleNormal, _vec );\n\t\t\t\t_plane.setFromNormalAndCoplanarPoint( _planeNormal, v0 );\n\n\t\t\t\tthis.splitByPlane( _plane, triangle );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// otherwise split by the triangle plane\n\t\t\ttriangle.getPlane( _plane );\n\t\t\tthis.splitByPlane( _plane, triangle );\n\n\t\t}\n\n\t}\n\n\t// Split the triangles by the given plan. If a triangle is provided then we ensure we\n\t// intersect the triangle before splitting the plane\n\tsplitByPlane( plane, clippingTriangle ) {\n\n\t\tconst { triangles, trianglePool } = this;\n\n\t\t// init our triangle to check for intersection\n\t\t_splittingTriangle.copy( clippingTriangle );\n\t\t_splittingTriangle.needsUpdate = true;\n\n\t\t// try to split every triangle in the class\n\t\tfor ( let i = 0, l = triangles.length; i < l; i ++ ) {\n\n\t\t\tconst tri = triangles[ i ];\n\n\t\t\t// skip the triangle if we don't intersect with it\n\t\t\tif ( ! _splittingTriangle.intersectsTriangle( tri, _edge, true ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst { a, b, c } = tri;\n\t\t\tlet intersects = 0;\n\t\t\tlet vertexSplitEnd = - 1;\n\t\t\tlet coplanarEdge = false;\n\t\t\tlet posSideVerts = [];\n\t\t\tlet negSideVerts = [];\n\t\t\tconst arr = [ a, b, c ];\n\t\t\tfor ( let t = 0; t < 3; t ++ ) {\n\n\t\t\t\t// get the triangle edge\n\t\t\t\tconst tNext = ( t + 1 ) % 3;\n\t\t\t\t_edge.start.copy( arr[ t ] );\n\t\t\t\t_edge.end.copy( arr[ tNext ] );\n\n\t\t\t\t// track if the start point sits on the plane or if it's on the positive side of it\n\t\t\t\t// so we can use that information to determine whether to split later.\n\t\t\t\tconst startDist = plane.distanceToPoint( _edge.start );\n\t\t\t\tconst endDist = plane.distanceToPoint( _edge.end );\n\t\t\t\tif ( Math.abs( startDist ) < COPLANAR_EPSILON && Math.abs( endDist ) < COPLANAR_EPSILON ) {\n\n\t\t\t\t\tcoplanarEdge = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( startDist > 0 ) {\n\n\t\t\t\t\tposSideVerts.push( t );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnegSideVerts.push( t );\n\n\t\t\t\t}\n\n\t\t\t\t// we only don't consider this an intersection if the start points hits the plane\n\t\t\t\tif ( Math.abs( startDist ) < COPLANAR_EPSILON ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// double check the end point since the \"intersectLine\" function sometimes does not\n\t\t\t\t// return it as an intersection (see issue #28)\n\t\t\t\t// Because we ignore the start point intersection above we have to make sure we check the end\n\t\t\t\t// point intersection here.\n\t\t\t\tlet didIntersect = ! ! plane.intersectLine( _edge, _vec );\n\t\t\t\tif ( ! didIntersect && Math.abs( endDist ) < COPLANAR_EPSILON ) {\n\n\t\t\t\t\t_vec.copy( _edge.end );\n\t\t\t\t\tdidIntersect = true;\n\n\t\t\t\t}\n\n\t\t\t\t// check if we intersect the plane (ignoring the start point so we don't double count)\n\t\t\t\tif ( didIntersect && ! ( _vec.distanceTo( _edge.start ) < EPSILON ) ) {\n\n\t\t\t\t\t// if we intersect at the end point then we track that point as one that we\n\t\t\t\t\t// have to split down the middle\n\t\t\t\t\tif ( _vec.distanceTo( _edge.end ) < EPSILON ) {\n\n\t\t\t\t\t\tvertexSplitEnd = t;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// track the split edge\n\t\t\t\t\tif ( intersects === 0 ) {\n\n\t\t\t\t\t\t_foundEdge.start.copy( _vec );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_foundEdge.end.copy( _vec );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tintersects ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// skip splitting if:\n\t\t\t// - we have two points on the plane then the plane intersects the triangle exactly on an edge\n\t\t\t// - the plane does not intersect on 2 points\n\t\t\t// - the intersection edge is too small\n\t\t\t// - we're not along a coplanar edge\n\t\t\tif ( ! coplanarEdge && intersects === 2 && _foundEdge.distance() > COPLANAR_EPSILON ) {\n\n\t\t\t\tif ( vertexSplitEnd !== - 1 ) {\n\n\t\t\t\t\tvertexSplitEnd = ( vertexSplitEnd + 1 ) % 3;\n\n\t\t\t\t\t// we're splitting along a vertex\n\t\t\t\t\tlet otherVert1 = 0;\n\t\t\t\t\tif ( otherVert1 === vertexSplitEnd ) {\n\n\t\t\t\t\t\totherVert1 = ( otherVert1 + 1 ) % 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet otherVert2 = otherVert1 + 1;\n\t\t\t\t\tif ( otherVert2 === vertexSplitEnd ) {\n\n\t\t\t\t\t\totherVert2 = ( otherVert2 + 1 ) % 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst nextTri = trianglePool.getTriangle();\n\t\t\t\t\tnextTri.a.copy( arr[ otherVert2 ] );\n\t\t\t\t\tnextTri.b.copy( _foundEdge.end );\n\t\t\t\t\tnextTri.c.copy( _foundEdge.start );\n\n\t\t\t\t\tif ( ! isTriDegenerate( nextTri ) ) {\n\n\t\t\t\t\t\ttriangles.push( nextTri );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttri.a.copy( arr[ otherVert1 ] );\n\t\t\t\t\ttri.b.copy( _foundEdge.start );\n\t\t\t\t\ttri.c.copy( _foundEdge.end );\n\n\t\t\t\t\t// finish off the adjusted triangle\n\t\t\t\t\tif ( isTriDegenerate( tri ) ) {\n\n\t\t\t\t\t\ttriangles.splice( i, 1 );\n\t\t\t\t\t\ti --;\n\t\t\t\t\t\tl --;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// we're splitting with a quad and a triangle\n\t\t\t\t\t// TODO: what happens when we find that about the pos and negative\n\t\t\t\t\t// sides have only a single vertex?\n\t\t\t\t\tconst singleVert =\n\t\t\t\t\t\tposSideVerts.length >= 2 ?\n\t\t\t\t\t\t\tnegSideVerts[ 0 ] :\n\t\t\t\t\t\t\tposSideVerts[ 0 ];\n\n\t\t\t\t\t// swap the direction of the intersection edge depending on which\n\t\t\t\t\t// side of the plane the single vertex is on to align with the\n\t\t\t\t\t// correct winding order.\n\t\t\t\t\tif ( singleVert === 0 ) {\n\n\t\t\t\t\t\tlet tmp = _foundEdge.start;\n\t\t\t\t\t\t_foundEdge.start = _foundEdge.end;\n\t\t\t\t\t\t_foundEdge.end = tmp;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst nextVert1 = ( singleVert + 1 ) % 3;\n\t\t\t\t\tconst nextVert2 = ( singleVert + 2 ) % 3;\n\n\t\t\t\t\tconst nextTri1 = trianglePool.getTriangle();\n\t\t\t\t\tconst nextTri2 = trianglePool.getTriangle();\n\n\t\t\t\t\t// choose the triangle that has the larger areas (shortest split distance)\n\t\t\t\t\tif ( arr[ nextVert1 ].distanceToSquared( _foundEdge.start ) < arr[ nextVert2 ].distanceToSquared( _foundEdge.end ) ) {\n\n\t\t\t\t\t\tnextTri1.a.copy( arr[ nextVert1 ] );\n\t\t\t\t\t\tnextTri1.b.copy( _foundEdge.start );\n\t\t\t\t\t\tnextTri1.c.copy( _foundEdge.end );\n\n\t\t\t\t\t\tnextTri2.a.copy( arr[ nextVert1 ] );\n\t\t\t\t\t\tnextTri2.b.copy( arr[ nextVert2 ] );\n\t\t\t\t\t\tnextTri2.c.copy( _foundEdge.start );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnextTri1.a.copy( arr[ nextVert2 ] );\n\t\t\t\t\t\tnextTri1.b.copy( _foundEdge.start );\n\t\t\t\t\t\tnextTri1.c.copy( _foundEdge.end );\n\n\t\t\t\t\t\tnextTri2.a.copy( arr[ nextVert1 ] );\n\t\t\t\t\t\tnextTri2.b.copy( arr[ nextVert2 ] );\n\t\t\t\t\t\tnextTri2.c.copy( _foundEdge.end );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttri.a.copy( arr[ singleVert ] );\n\t\t\t\t\ttri.b.copy( _foundEdge.end );\n\t\t\t\t\ttri.c.copy( _foundEdge.start );\n\n\t\t\t\t\t// don't add degenerate triangles to the list\n\t\t\t\t\tif ( ! isTriDegenerate( nextTri1 ) ) {\n\n\t\t\t\t\t\ttriangles.push( nextTri1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! isTriDegenerate( nextTri2 ) ) {\n\n\t\t\t\t\t\ttriangles.push( nextTri2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// finish off the adjusted triangle\n\t\t\t\t\tif ( isTriDegenerate( tri ) ) {\n\n\t\t\t\t\t\ttriangles.splice( i, 1 );\n\t\t\t\t\t\ti --;\n\t\t\t\t\t\tl --;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( intersects === 3 ) {\n\n\t\t\t\tconsole.warn( 'TriangleClipper: Coplanar clip not handled' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treset() {\n\n\t\tthis.triangles.length = 0;\n\t\tthis.trianglePool.clear();\n\t\tthis.coplanarTriangleUsed = false;\n\n\t}\n\n}\n","import { areSharedArrayBuffersSupported } from './utils/geometryUtils.js';\n\nfunction ceilToFourByteStride( byteLength ) {\n\n\tbyteLength = ~ ~ byteLength;\n\treturn byteLength + 4 - byteLength % 4;\n\n}\n\n// Make a new array wrapper class that more easily affords expansion when reaching it's max capacity\nexport class TypeBackedArray {\n\n\tconstructor( type, initialSize = 500 ) {\n\n\n\t\tthis.expansionFactor = 1.5;\n\t\tthis.type = type;\n\t\tthis.length = 0;\n\t\tthis.array = null;\n\n\t\tthis.setSize( initialSize );\n\n\t}\n\n\tsetType( type ) {\n\n\t\tif ( this.length !== 0 ) {\n\n\t\t\tthrow new Error( 'TypeBackedArray: Cannot change the type while there is used data in the buffer.' );\n\n\t\t}\n\n\t\tconst buffer = this.array.buffer;\n\t\tthis.array = new type( buffer );\n\t\tthis.type = type;\n\n\t}\n\n\tsetSize( size ) {\n\n\t\tif ( this.array && size === this.array.length ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// ceil to the nearest 4 bytes so we can replace the array with any type using the same buffer\n\t\tconst type = this.type;\n\t\tconst bufferType = areSharedArrayBuffersSupported() ? SharedArrayBuffer : ArrayBuffer;\n\t\tconst newArray = new type( new bufferType( ceilToFourByteStride( size * type.BYTES_PER_ELEMENT ) ) );\n\t\tif ( this.array ) {\n\n\t\t\tnewArray.set( this.array, 0 );\n\n\t\t}\n\n\t\tthis.array = newArray;\n\n\t}\n\n\texpand() {\n\n\t\tconst { array, expansionFactor } = this;\n\t\tthis.setSize( array.length * expansionFactor );\n\n\t}\n\n\tpush( ...args ) {\n\n\t\tlet { array, length } = this;\n\t\tif ( length + args.length > array.length ) {\n\n\t\t\tthis.expand();\n\t\t\tarray = this.array;\n\n\t\t}\n\n\t\tfor ( let i = 0, l = args.length; i < l; i ++ ) {\n\n\t\t\tarray[ length + i ] = args[ i ];\n\n\t\t}\n\n\t\tthis.length += args.length;\n\n\t}\n\n\tclear() {\n\n\t\tthis.length = 0;\n\n\t}\n\n}\n","import { TypeBackedArray } from './TypeBackedArray.js';\n\n// Utility class for for tracking attribute data in type-backed arrays for a set\n// of groups. The set of attributes is kept for each group and are expected to be the\n// same buffer type.\nexport class TypedAttributeData {\n\n\tconstructor() {\n\n\t\tthis.groupAttributes = [ {} ];\n\t\tthis.groupCount = 0;\n\n\t}\n\n\t// returns the buffer type for the given attribute\n\tgetType( name ) {\n\n\t\treturn this.groupAttributes[ 0 ][ name ].type;\n\n\t}\n\n\tgetItemSize( name ) {\n\n\t\treturn this.groupAttributes[ 0 ][ name ].itemSize;\n\n\t}\n\n\tgetNormalized( name ) {\n\n\t\treturn this.groupAttributes[ 0 ][ name ].normalized;\n\n\t}\n\n\tgetCount( index ) {\n\n\t\tif ( this.groupCount <= index ) {\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst pos = this.getGroupAttrArray( 'position', index );\n\t\treturn pos.length / pos.itemSize;\n\n\t}\n\n\t// returns the total length required for all groups for the given attribute\n\tgetTotalLength( name ) {\n\n\t\tconst { groupCount, groupAttributes } = this;\n\n\t\tlet length = 0;\n\t\tfor ( let i = 0; i < groupCount; i ++ ) {\n\n\t\t\tconst attrSet = groupAttributes[ i ];\n\t\t\tlength += attrSet[ name ].length;\n\n\t\t}\n\n\t\treturn length;\n\n\t}\n\n\tgetGroupAttrSet( index = 0 ) {\n\n\t\t// TODO: can this be abstracted?\n\t\t// Return the exiting group set if necessary\n\t\tconst { groupAttributes } = this;\n\t\tif ( groupAttributes[ index ] ) {\n\n\t\t\tthis.groupCount = Math.max( this.groupCount, index + 1 );\n\t\t\treturn groupAttributes[ index ];\n\n\t\t}\n\n\t\t// add any new group sets required\n\t\tconst refAttrSet = groupAttributes[ 0 ];\n\t\tthis.groupCount = Math.max( this.groupCount, index + 1 );\n\t\twhile ( index >= groupAttributes.length ) {\n\n\t\t\tconst newAttrSet = {};\n\t\t\tgroupAttributes.push( newAttrSet );\n\t\t\tfor ( const key in refAttrSet ) {\n\n\t\t\t\tconst refAttr = refAttrSet[ key ];\n\t\t\t\tconst newAttr = new TypeBackedArray( refAttr.type );\n\t\t\t\tnewAttr.itemSize = refAttr.itemSize;\n\t\t\t\tnewAttr.normalized = refAttr.normalized;\n\t\t\t\tnewAttrSet[ key ] = newAttr;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn groupAttributes[ index ];\n\n\t}\n\n\t// Get the raw array for the group set of data\n\tgetGroupAttrArray( name, index = 0 ) {\n\n\t\t// throw an error if we've never\n\t\tconst { groupAttributes } = this;\n\t\tconst referenceAttrSet = groupAttributes[ 0 ];\n\t\tconst referenceAttr = referenceAttrSet[ name ];\n\t\tif ( ! referenceAttr ) {\n\n\t\t\tthrow new Error( `TypedAttributeData: Attribute with \"${ name }\" has not been initialized` );\n\n\t\t}\n\n\t\treturn this.getGroupAttrSet( index )[ name ];\n\n\t}\n\n\t// initializes an attribute array with the given name, type, and size\n\tinitializeArray( name, type, itemSize, normalized ) {\n\n\t\tconst { groupAttributes } = this;\n\t\tconst referenceAttrSet = groupAttributes[ 0 ];\n\t\tconst referenceAttr = referenceAttrSet[ name ];\n\t\tif ( referenceAttr ) {\n\n\t\t\tif ( referenceAttr.type !== type ) {\n\n\t\t\t\tfor ( let i = 0, l = groupAttributes.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst arr = groupAttributes[ i ][ name ];\n\t\t\t\t\tarr.setType( type );\n\t\t\t\t\tarr.itemSize = itemSize;\n\t\t\t\t\tarr.normalized = normalized;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0, l = groupAttributes.length; i < l; i ++ ) {\n\n\t\t\t\tconst arr = new TypeBackedArray( type );\n\t\t\t\tarr.itemSize = itemSize;\n\t\t\t\tarr.normalized = normalized;\n\t\t\t\tgroupAttributes[ i ][ name ] = arr;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Clear all the data\n\tclear() {\n\n\t\tthis.groupCount = 0;\n\n\t\tconst { groupAttributes } = this;\n\t\tgroupAttributes.forEach( attrSet => {\n\n\t\t\tfor ( const key in attrSet ) {\n\n\t\t\t\tattrSet[ key ].clear();\n\n\t\t\t}\n\n\n\t\t} );\n\n\t}\n\n\t// Remove the given key\n\tdelete( key ) {\n\n\t\tthis.groupAttributes.forEach( attrSet => {\n\n\t\t\tdelete attrSet[ key ];\n\n\t\t} );\n\n\t}\n\n\t// Reset the datasets completely\n\treset() {\n\n\t\tthis.groupAttributes = [];\n\t\tthis.groupCount = 0;\n\n\t}\n\n}\n","export class IntersectionMap {\n\n\tconstructor() {\n\n\t\tthis.intersectionSet = {};\n\t\tthis.ids = [];\n\n\t}\n\n\tadd( id, intersectionId ) {\n\n\t\tconst { intersectionSet, ids } = this;\n\t\tif ( ! intersectionSet[ id ] ) {\n\n\t\t\tintersectionSet[ id ] = [];\n\t\t\tids.push( id );\n\n\t\t}\n\n\t\tintersectionSet[ id ].push( intersectionId );\n\n\t}\n\n}\n","import { Ray, Matrix4, DoubleSide, Vector3, Vector4, Triangle, Line3 } from 'three';\nimport { IntersectionMap } from '../IntersectionMap.js';\nimport {\n\tADDITION,\n\tSUBTRACTION,\n\tREVERSE_SUBTRACTION,\n\tINTERSECTION,\n\tDIFFERENCE,\n\tHOLLOW_SUBTRACTION,\n\tHOLLOW_INTERSECTION,\n} from '../constants.js';\nimport { isTriDegenerate } from '../utils/triangleUtils.js';\n\nconst _ray = new Ray();\nconst _matrix = new Matrix4();\nconst _tri = new Triangle();\nconst _vec3 = new Vector3();\nconst _vec4a = new Vector4();\nconst _vec4b = new Vector4();\nconst _vec4c = new Vector4();\nconst _vec4_0 = new Vector4();\nconst _vec4_1 = new Vector4();\nconst _vec4_2 = new Vector4();\nconst _edge = new Line3();\nconst _normal = new Vector3();\nconst JITTER_EPSILON = 1e-8;\nconst OFFSET_EPSILON = 1e-15;\n\nexport const BACK_SIDE = - 1;\nexport const FRONT_SIDE = 1;\nexport const COPLANAR_OPPOSITE = - 2;\nexport const COPLANAR_ALIGNED = 2;\n\nexport const INVERT_TRI = 0;\nexport const ADD_TRI = 1;\nexport const SKIP_TRI = 2;\n\nconst FLOATING_COPLANAR_EPSILON = 1e-14;\n\nlet _debugContext = null;\nexport function setDebugContext( debugData ) {\n\n\t_debugContext = debugData;\n\n}\n\nexport function getHitSide( tri, bvh ) {\n\n\ttri.getMidpoint( _ray.origin );\n\ttri.getNormal( _ray.direction );\n\n\tconst hit = bvh.raycastFirst( _ray, DoubleSide );\n\tconst hitBackSide = Boolean( hit && _ray.direction.dot( hit.face.normal ) > 0 );\n\treturn hitBackSide ? BACK_SIDE : FRONT_SIDE;\n\n}\n\nexport function getHitSideWithCoplanarCheck( tri, bvh ) {\n\n\t// random function that returns [ - 0.5, 0.5 ];\n\tfunction rand() {\n\n\t\treturn Math.random() - 0.5;\n\n\t}\n\n\t// get the ray the check the triangle for\n\ttri.getNormal( _normal );\n\t_ray.direction.copy( _normal );\n\ttri.getMidpoint( _ray.origin );\n\n\tconst total = 3;\n\tlet count = 0;\n\tlet minDistance = Infinity;\n\tfor ( let i = 0; i < total; i ++ ) {\n\n\t\t// jitter the ray slightly\n\t\t_ray.direction.x += rand() * JITTER_EPSILON;\n\t\t_ray.direction.y += rand() * JITTER_EPSILON;\n\t\t_ray.direction.z += rand() * JITTER_EPSILON;\n\n\t\t// and invert it so we can account for floating point error by checking both directions\n\t\t// to catch coplanar distances\n\t\t_ray.direction.multiplyScalar( - 1 );\n\n\t\t// check if the ray hit the backside\n\t\tconst hit = bvh.raycastFirst( _ray, DoubleSide );\n\t\tlet hitBackSide = Boolean( hit && _ray.direction.dot( hit.face.normal ) > 0 );\n\t\tif ( hitBackSide ) {\n\n\t\t\tcount ++;\n\n\t\t}\n\n\t\tif ( hit !== null ) {\n\n\t\t\tminDistance = Math.min( minDistance, hit.distance );\n\n\t\t}\n\n\t\t// if we're right up against another face then we're coplanar\n\t\tif ( minDistance <= OFFSET_EPSILON ) {\n\n\t\t\treturn hit.face.normal.dot( _normal ) > 0 ? COPLANAR_ALIGNED : COPLANAR_OPPOSITE;\n\n\t\t}\n\n\t\t// if our current casts meet our requirements then early out\n\t\tif ( count / total > 0.5 || ( i - count + 1 ) / total > 0.5 ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\treturn count / total > 0.5 ? BACK_SIDE : FRONT_SIDE;\n\n}\n\n// returns the intersected triangles and returns objects mapping triangle indices to\n// the other triangles intersected\nexport function collectIntersectingTriangles( a, b ) {\n\n\tconst aIntersections = new IntersectionMap();\n\tconst bIntersections = new IntersectionMap();\n\n\t_matrix\n\t\t.copy( a.matrixWorld )\n\t\t.invert()\n\t\t.multiply( b.matrixWorld );\n\n\ta.geometry.boundsTree.bvhcast( b.geometry.boundsTree, _matrix, {\n\n\t\tintersectsTriangles( triangleA, triangleB, ia, ib ) {\n\n\t\t\tif ( ! isTriDegenerate( triangleA ) && ! isTriDegenerate( triangleB ) ) {\n\n\t\t\t\t// due to floating point error it's possible that we can have two overlapping, coplanar triangles\n\t\t\t\t// that are a _tiny_ fraction of a value away from each other. If we find that case then check the\n\t\t\t\t// distance between triangles and if it's small enough consider them intersecting.\n\t\t\t\tlet intersected = triangleA.intersectsTriangle( triangleB, _edge, true );\n\t\t\t\tif ( ! intersected ) {\n\n\t\t\t\t\tconst pa = triangleA.plane;\n\t\t\t\t\tconst pb = triangleB.plane;\n\t\t\t\t\tconst na = pa.normal;\n\t\t\t\t\tconst nb = pb.normal;\n\n\t\t\t\t\tif ( na.dot( nb ) === 1 && Math.abs( pa.constant - pb.constant ) < FLOATING_COPLANAR_EPSILON ) {\n\n\t\t\t\t\t\tintersected = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( intersected ) {\n\n\t\t\t\t\tlet va = a.geometry.boundsTree.resolveTriangleIndex( ia );\n\t\t\t\t\tlet vb = b.geometry.boundsTree.resolveTriangleIndex( ib );\n\t\t\t\t\taIntersections.add( va, vb );\n\t\t\t\t\tbIntersections.add( vb, va );\n\n\t\t\t\t\tif ( _debugContext ) {\n\n\t\t\t\t\t\t_debugContext.addEdge( _edge );\n\t\t\t\t\t\t_debugContext.addIntersectingTriangles( ia, triangleA, ib, triangleB );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\t} );\n\n\treturn { aIntersections, bIntersections };\n\n}\n\n// Add the barycentric interpolated values fro the triangle into the new attribute data\nexport function appendAttributeFromTriangle(\n\ttriIndex,\n\tbaryCoordTri,\n\tgeometry,\n\tmatrixWorld,\n\tnormalMatrix,\n\tattributeData,\n\tinvert = false,\n) {\n\n\tconst attributes = geometry.attributes;\n\tconst indexAttr = geometry.index;\n\tconst i3 = triIndex * 3;\n\tconst i0 = indexAttr.getX( i3 + 0 );\n\tconst i1 = indexAttr.getX( i3 + 1 );\n\tconst i2 = indexAttr.getX( i3 + 2 );\n\n\tfor ( const key in attributeData ) {\n\n\t\t// check if the key we're asking for is in the geometry at all\n\t\tconst attr = attributes[ key ];\n\t\tconst arr = attributeData[ key ];\n\t\tif ( ! ( key in attributes ) ) {\n\n\t\t\tthrow new Error( `CSG Operations: Attribute ${ key } not available on geometry.` );\n\n\t\t}\n\n\t\t// handle normals and positions specially because they require transforming\n\t\t// TODO: handle tangents\n\t\tconst itemSize = attr.itemSize;\n\t\tif ( key === 'position' ) {\n\n\t\t\t_tri.a.fromBufferAttribute( attr, i0 ).applyMatrix4( matrixWorld );\n\t\t\t_tri.b.fromBufferAttribute( attr, i1 ).applyMatrix4( matrixWorld );\n\t\t\t_tri.c.fromBufferAttribute( attr, i2 ).applyMatrix4( matrixWorld );\n\n\t\t\tpushBarycoordInterpolatedValues( _tri.a, _tri.b, _tri.c, baryCoordTri, 3, arr, invert );\n\n\t\t} else if ( key === 'normal' ) {\n\n\t\t\t_tri.a.fromBufferAttribute( attr, i0 ).applyNormalMatrix( normalMatrix );\n\t\t\t_tri.b.fromBufferAttribute( attr, i1 ).applyNormalMatrix( normalMatrix );\n\t\t\t_tri.c.fromBufferAttribute( attr, i2 ).applyNormalMatrix( normalMatrix );\n\n\t\t\tif ( invert ) {\n\n\t\t\t\t_tri.a.multiplyScalar( - 1 );\n\t\t\t\t_tri.b.multiplyScalar( - 1 );\n\t\t\t\t_tri.c.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t\tpushBarycoordInterpolatedValues( _tri.a, _tri.b, _tri.c, baryCoordTri, 3, arr, invert, true );\n\n\t\t} else {\n\n\t\t\t_vec4a.fromBufferAttribute( attr, i0 );\n\t\t\t_vec4b.fromBufferAttribute( attr, i1 );\n\t\t\t_vec4c.fromBufferAttribute( attr, i2 );\n\n\t\t\tpushBarycoordInterpolatedValues( _vec4a, _vec4b, _vec4c, baryCoordTri, itemSize, arr, invert );\n\n\t\t}\n\n\t}\n\n}\n\n// Append all the values of the attributes for the triangle onto the new attribute arrays\nexport function appendAttributesFromIndices(\n\ti0,\n\ti1,\n\ti2,\n\tattributes,\n\tmatrixWorld,\n\tnormalMatrix,\n\tattributeData,\n\tinvert = false,\n) {\n\n\tappendAttributeFromIndex( i0, attributes, matrixWorld, normalMatrix, attributeData, invert );\n\tappendAttributeFromIndex( invert ? i2 : i1, attributes, matrixWorld, normalMatrix, attributeData, invert );\n\tappendAttributeFromIndex( invert ? i1 : i2, attributes, matrixWorld, normalMatrix, attributeData, invert );\n\n}\n\n// Returns the triangle to add when performing an operation\nexport function getOperationAction( operation, hitSide, invert = false ) {\n\n\tswitch ( operation ) {\n\n\t\tcase ADDITION:\n\n\t\t\tif ( hitSide === FRONT_SIDE || ( hitSide === COPLANAR_ALIGNED && ! invert ) ) {\n\n\t\t\t\treturn ADD_TRI;\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase SUBTRACTION:\n\n\t\t\tif ( invert ) {\n\n\t\t\t\tif ( hitSide === BACK_SIDE ) {\n\n\t\t\t\t\treturn INVERT_TRI;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( hitSide === FRONT_SIDE || hitSide === COPLANAR_OPPOSITE ) {\n\n\t\t\t\t\treturn ADD_TRI;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase REVERSE_SUBTRACTION:\n\n\t\t\tif ( invert ) {\n\n\t\t\t\tif ( hitSide === FRONT_SIDE || hitSide === COPLANAR_OPPOSITE ) {\n\n\t\t\t\t\treturn ADD_TRI;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( hitSide === BACK_SIDE ) {\n\n\t\t\t\t\treturn INVERT_TRI;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase DIFFERENCE:\n\n\t\t\tif ( hitSide === BACK_SIDE ) {\n\n\t\t\t\treturn INVERT_TRI;\n\n\t\t\t} else if ( hitSide === FRONT_SIDE ) {\n\n\t\t\t\treturn ADD_TRI;\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase INTERSECTION:\n\t\t\tif ( hitSide === BACK_SIDE || ( hitSide === COPLANAR_ALIGNED && ! invert ) ) {\n\n\t\t\t\treturn ADD_TRI;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase HOLLOW_SUBTRACTION:\n\t\t\tif ( ! invert && ( hitSide === FRONT_SIDE || hitSide === COPLANAR_OPPOSITE ) ) {\n\n\t\t\t\treturn ADD_TRI;\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase HOLLOW_INTERSECTION:\n\t\t\tif ( ! invert && ( hitSide === BACK_SIDE || hitSide === COPLANAR_ALIGNED ) ) {\n\n\t\t\t\treturn ADD_TRI;\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new Error( `Unrecognized CSG operation enum \"${ operation }\".` );\n\n\t}\n\n\treturn SKIP_TRI;\n\n}\n\n// takes a set of barycentric values in the form of a triangle, a set of vectors, number of components,\n// and whether to invert the result and pushes the new values onto the provided attribute array\nfunction pushBarycoordInterpolatedValues( v0, v1, v2, baryCoordTri, itemSize, attrArr, invert = false, normalize = false ) {\n\n\t// adds the appropriate number of values for the vector onto the array\n\tconst addValues = v => {\n\n\t\tattrArr.push( v.x );\n\t\tif ( itemSize > 1 ) attrArr.push( v.y );\n\t\tif ( itemSize > 2 ) attrArr.push( v.z );\n\t\tif ( itemSize > 3 ) attrArr.push( v.w );\n\n\t};\n\n\t// barycentric interpolate the first component\n\t_vec4_0.set( 0, 0, 0, 0 )\n\t\t.addScaledVector( v0, baryCoordTri.a.x )\n\t\t.addScaledVector( v1, baryCoordTri.a.y )\n\t\t.addScaledVector( v2, baryCoordTri.a.z );\n\n\t_vec4_1.set( 0, 0, 0, 0 )\n\t\t.addScaledVector( v0, baryCoordTri.b.x )\n\t\t.addScaledVector( v1, baryCoordTri.b.y )\n\t\t.addScaledVector( v2, baryCoordTri.b.z );\n\n\t_vec4_2.set( 0, 0, 0, 0 )\n\t\t.addScaledVector( v0, baryCoordTri.c.x )\n\t\t.addScaledVector( v1, baryCoordTri.c.y )\n\t\t.addScaledVector( v2, baryCoordTri.c.z );\n\n\tif ( normalize ) {\n\n\t\t_vec4_0.normalize();\n\t\t_vec4_1.normalize();\n\t\t_vec4_2.normalize();\n\n\t}\n\n\t// if the face is inverted then add the values in an inverted order\n\taddValues( _vec4_0 );\n\n\tif ( invert ) {\n\n\t\taddValues( _vec4_2 );\n\t\taddValues( _vec4_1 );\n\n\t} else {\n\n\t\taddValues( _vec4_1 );\n\t\taddValues( _vec4_2 );\n\n\t}\n\n}\n\n// Adds the values for the given vertex index onto the new attribute arrays\nfunction appendAttributeFromIndex(\n\tindex,\n\tattributes,\n\tmatrixWorld,\n\tnormalMatrix,\n\tattributeData,\n\tinvert = false,\n) {\n\n\tfor ( const key in attributeData ) {\n\n\t\t// check if the key we're asking for is in the geometry at all\n\t\tconst attr = attributes[ key ];\n\t\tconst arr = attributeData[ key ];\n\t\tif ( ! ( key in attributes ) ) {\n\n\t\t\tthrow new Error( `CSG Operations: Attribute ${ key } no available on geometry.` );\n\n\t\t}\n\n\t\t// specially handle the position and normal attributes because they require transforms\n\t\t// TODO: handle tangents\n\t\tconst itemSize = attr.itemSize;\n\t\tif ( key === 'position' ) {\n\n\t\t\t_vec3.fromBufferAttribute( attr, index ).applyMatrix4( matrixWorld );\n\t\t\tarr.push( _vec3.x, _vec3.y, _vec3.z );\n\n\t\t} else if ( key === 'normal' ) {\n\n\t\t\t_vec3.fromBufferAttribute( attr, index ).applyNormalMatrix( normalMatrix );\n\t\t\tif ( invert ) {\n\n\t\t\t\t_vec3.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t\tarr.push( _vec3.x, _vec3.y, _vec3.z );\n\n\t\t} else {\n\n\t\t\tarr.push( attr.getX( index ) );\n\t\t\tif ( itemSize > 1 ) arr.push( attr.getY( index ) );\n\t\t\tif ( itemSize > 2 ) arr.push( attr.getZ( index ) );\n\t\t\tif ( itemSize > 3 ) arr.push( attr.getW( index ) );\n\n\t\t}\n\n\t}\n\n}\n","import { Triangle } from 'three';\nimport { setDebugContext } from '../operations/operationsUtils.js';\n\nclass TriangleIntersectData {\n\n\tconstructor( tri ) {\n\n\t\tthis.triangle = new Triangle().copy( tri );\n\t\tthis.intersects = {};\n\n\t}\n\n\taddTriangle( index, tri ) {\n\n\t\tthis.intersects[ index ] = new Triangle().copy( tri );\n\n\t}\n\n\tgetIntersectArray() {\n\n\t\tconst array = [];\n\t\tconst { intersects } = this;\n\t\tfor ( const key in intersects ) {\n\n\t\t\tarray.push( intersects[ key ] );\n\n\t\t}\n\n\t\treturn array;\n\n\t}\n\n}\n\nclass TriangleIntersectionSets {\n\n\tconstructor() {\n\n\t\tthis.data = {};\n\n\t}\n\n\taddTriangleIntersection( ia, triA, ib, triB ) {\n\n\t\tconst { data } = this;\n\t\tif ( ! data[ ia ] ) {\n\n\t\t\tdata[ ia ] = new TriangleIntersectData( triA );\n\n\t\t}\n\n\t\tdata[ ia ].addTriangle( ib, triB );\n\n\t}\n\n\tgetTrianglesAsArray( id = null ) {\n\n\t\tconst { data } = this;\n\t\tconst arr = [];\n\n\t\tif ( id !== null ) {\n\n\t\t\tif ( id in data ) {\n\n\t\t\t\tarr.push( data[ id ].triangle );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( const key in data ) {\n\n\t\t\t\tarr.push( data[ key ].triangle );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn arr;\n\n\t}\n\n\tgetTriangleIndices() {\n\n\t\treturn Object.keys( this.data ).map( i => parseInt( i ) );\n\n\t}\n\n\tgetIntersectionIndices( id ) {\n\n\t\tconst { data } = this;\n\t\tif ( ! data[ id ] ) {\n\n\t\t\treturn [];\n\n\t\t} else {\n\n\t\t\treturn Object.keys( data[ id ].intersects ).map( i => parseInt( i ) );\n\n\n\t\t}\n\n\t}\n\n\tgetIntersectionsAsArray( id = null, id2 = null ) {\n\n\t\tconst { data } = this;\n\t\tconst triSet = new Set();\n\t\tconst arr = [];\n\n\t\tconst addTriangles = key => {\n\n\t\t\tif ( ! data[ key ] ) return;\n\n\t\t\tif ( id2 !== null ) {\n\n\t\t\t\tif ( data[ key ].intersects[ id2 ] ) {\n\n\t\t\t\t\tarr.push( data[ key ].intersects[ id2 ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst intersects = data[ key ].intersects;\n\t\t\t\tfor ( const key2 in intersects ) {\n\n\t\t\t\t\tif ( ! triSet.has( key2 ) ) {\n\n\t\t\t\t\t\ttriSet.add( key2 );\n\t\t\t\t\t\tarr.push( intersects[ key2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tif ( id !== null ) {\n\n\t\t\taddTriangles( id );\n\n\t\t} else {\n\n\t\t\tfor ( const key in data ) {\n\n\t\t\t\taddTriangles( key );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn arr;\n\n\t}\n\n\treset() {\n\n\t\tthis.data = {};\n\n\t}\n\n}\n\nexport class OperationDebugData {\n\n\tconstructor() {\n\n\t\tthis.enabled = false;\n\t\tthis.triangleIntersectsA = new TriangleIntersectionSets();\n\t\tthis.triangleIntersectsB = new TriangleIntersectionSets();\n\t\tthis.intersectionEdges = [];\n\n\t}\n\n\taddIntersectingTriangles( ia, triA, ib, triB ) {\n\n\t\tconst { triangleIntersectsA, triangleIntersectsB } = this;\n\t\ttriangleIntersectsA.addTriangleIntersection( ia, triA, ib, triB );\n\t\ttriangleIntersectsB.addTriangleIntersection( ib, triB, ia, triA );\n\n\t}\n\n\taddEdge( edge ) {\n\n\t\tthis.intersectionEdges.push( edge.clone() );\n\n\t}\n\n\treset() {\n\n\t\tthis.triangleIntersectsA.reset();\n\t\tthis.triangleIntersectsB.reset();\n\t\tthis.intersectionEdges = [];\n\n\t}\n\n\tinit() {\n\n\t\tif ( this.enabled ) {\n\n\t\t\tthis.reset();\n\t\t\tsetDebugContext( this );\n\n\t\t}\n\n\t}\n\n\tcomplete() {\n\n\t\tif ( this.enabled ) {\n\n\t\t\tsetDebugContext( null );\n\n\t\t}\n\n\t}\n\n}\n","import { Matrix4, Matrix3, Triangle } from 'three';\nimport {\n\tgetHitSideWithCoplanarCheck,\n\tgetHitSide,\n\tcollectIntersectingTriangles,\n\tappendAttributeFromTriangle,\n\tappendAttributesFromIndices,\n\tgetOperationAction,\n\tSKIP_TRI, INVERT_TRI,\n} from './operationsUtils.js';\nimport { getTriCount } from '../utils/geometryUtils.js';\nimport { HOLLOW_INTERSECTION, HOLLOW_SUBTRACTION } from '../constants.js';\nimport { isTriDegenerate } from '../utils/triangleUtils.js';\n\nconst _matrix = new Matrix4();\nconst _normalMatrix = new Matrix3();\nconst _triA = new Triangle();\nconst _triB = new Triangle();\nconst _tri = new Triangle();\nconst _barycoordTri = new Triangle();\nconst _attr = [];\nconst _actions = [];\n\nfunction getFirstIdFromSet( set ) {\n\n\tfor ( const id of set ) return id;\n\n}\n\n// runs the given operation against a and b using the splitter and appending data to the\n// attributeData object.\nexport function performOperation(\n\ta,\n\tb,\n\toperations,\n\tsplitter,\n\tattributeData,\n\toptions = {},\n) {\n\n\tconst { useGroups = true } = options;\n\tconst { aIntersections, bIntersections } = collectIntersectingTriangles( a, b );\n\n\tconst resultGroups = [];\n\tlet resultMaterials = null;\n\n\tlet groupOffset;\n\tgroupOffset = useGroups ? 0 : - 1;\n\tperformSplitTriangleOperations( a, b, aIntersections, operations, false, splitter, attributeData, groupOffset );\n\tperformWholeTriangleOperations( a, b, aIntersections, operations, false, attributeData, groupOffset );\n\n\t// find whether the set of operations contains a non-hollow operations. If it does then we need\n\t// to perform the second set of triangle additions\n\tconst nonHollow = operations\n\t\t.findIndex( op => op !== HOLLOW_INTERSECTION && op !== HOLLOW_SUBTRACTION ) !== - 1;\n\n\tif ( nonHollow ) {\n\n\t\tgroupOffset = useGroups ? a.geometry.groups.length || 1 : - 1;\n\t\tperformSplitTriangleOperations( b, a, bIntersections, operations, true, splitter, attributeData, groupOffset );\n\t\tperformWholeTriangleOperations( b, a, bIntersections, operations, true, attributeData, groupOffset );\n\n\t}\n\n\t_attr.length = 0;\n\t_actions.length = 0;\n\n\treturn {\n\t\tgroups: resultGroups,\n\t\tmaterials: resultMaterials\n\t};\n\n}\n\n// perform triangle splitting and CSG operations on the set of split triangles\nfunction performSplitTriangleOperations(\n\ta,\n\tb,\n\tintersectionMap,\n\toperations,\n\tinvert,\n\tsplitter,\n\tattributeData,\n\tgroupOffset = 0,\n) {\n\n\tconst invertedGeometry = a.matrixWorld.determinant() < 0;\n\n\t// transforms into the local frame of matrix b\n\t_matrix\n\t\t.copy( b.matrixWorld )\n\t\t.invert()\n\t\t.multiply( a.matrixWorld );\n\n\t_normalMatrix\n\t\t.getNormalMatrix( a.matrixWorld )\n\t\t.multiplyScalar( invertedGeometry ? - 1 : 1 );\n\n\tconst groupIndices = a.geometry.groupIndices;\n\tconst aIndex = a.geometry.index;\n\tconst aPosition = a.geometry.attributes.position;\n\n\tconst bBVH = b.geometry.boundsTree;\n\tconst bIndex = b.geometry.index;\n\tconst bPosition = b.geometry.attributes.position;\n\tconst splitIds = intersectionMap.ids;\n\tconst intersectionSet = intersectionMap.intersectionSet;\n\n\t// iterate over all split triangle indices\n\tfor ( let i = 0, l = splitIds.length; i < l; i ++ ) {\n\n\t\tconst ia = splitIds[ i ];\n\t\tconst groupIndex = groupOffset === - 1 ? 0 : groupIndices[ ia ] + groupOffset;\n\n\t\t// get the triangle in the geometry B local frame\n\t\tconst ia3 = 3 * ia;\n\t\tconst ia0 = aIndex.getX( ia3 + 0 );\n\t\tconst ia1 = aIndex.getX( ia3 + 1 );\n\t\tconst ia2 = aIndex.getX( ia3 + 2 );\n\t\t_triA.a.fromBufferAttribute( aPosition, ia0 ).applyMatrix4( _matrix );\n\t\t_triA.b.fromBufferAttribute( aPosition, ia1 ).applyMatrix4( _matrix );\n\t\t_triA.c.fromBufferAttribute( aPosition, ia2 ).applyMatrix4( _matrix );\n\n\t\t// initialize the splitter with the triangle from geometry A\n\t\tsplitter.reset();\n\t\tsplitter.initialize( _triA );\n\n\t\t// split the triangle with the intersecting triangles from B\n\t\tconst intersectingIndices = intersectionSet[ ia ];\n\t\tfor ( let ib = 0, l = intersectingIndices.length; ib < l; ib ++ ) {\n\n\t\t\tconst ib3 = 3 * intersectingIndices[ ib ];\n\t\t\tconst ib0 = bIndex.getX( ib3 + 0 );\n\t\t\tconst ib1 = bIndex.getX( ib3 + 1 );\n\t\t\tconst ib2 = bIndex.getX( ib3 + 2 );\n\t\t\t_triB.a.fromBufferAttribute( bPosition, ib0 );\n\t\t\t_triB.b.fromBufferAttribute( bPosition, ib1 );\n\t\t\t_triB.c.fromBufferAttribute( bPosition, ib2 );\n\t\t\tsplitter.splitByTriangle( _triB );\n\n\t\t}\n\n\t\t// for all triangles in the split result\n\t\tconst triangles = splitter.triangles;\n\t\tfor ( let ib = 0, l = triangles.length; ib < l; ib ++ ) {\n\n\t\t\t// get the barycentric coordinates of the clipped triangle to add\n\t\t\tconst clippedTri = triangles[ ib ];\n\n\t\t\t// try to use the side derived from the clipping but if it turns out to be\n\t\t\t// uncertain then fall back to the raycasting approach\n\t\t\tconst hitSide = splitter.coplanarTriangleUsed ?\n\t\t\t\tgetHitSideWithCoplanarCheck( clippedTri, bBVH ) :\n\t\t\t\tgetHitSide( clippedTri, bBVH );\n\n\t\t\t_attr.length = 0;\n\t\t\t_actions.length = 0;\n\t\t\tfor ( let o = 0, lo = operations.length; o < lo; o ++ ) {\n\n\t\t\t\tconst op = getOperationAction( operations[ o ], hitSide, invert );\n\t\t\t\tif ( op !== SKIP_TRI ) {\n\n\t\t\t\t\t_actions.push( op );\n\t\t\t\t\t_attr.push( attributeData[ o ].getGroupAttrSet( groupIndex ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( _attr.length !== 0 ) {\n\n\t\t\t\t_triA.getBarycoord( clippedTri.a, _barycoordTri.a );\n\t\t\t\t_triA.getBarycoord( clippedTri.b, _barycoordTri.b );\n\t\t\t\t_triA.getBarycoord( clippedTri.c, _barycoordTri.c );\n\n\t\t\t\tfor ( let k = 0, lk = _attr.length; k < lk; k ++ ) {\n\n\t\t\t\t\tconst attrSet = _attr[ k ];\n\t\t\t\t\tconst action = _actions[ k ];\n\t\t\t\t\tconst invertTri = action === INVERT_TRI;\n\t\t\t\t\tappendAttributeFromTriangle( ia, _barycoordTri, a.geometry, a.matrixWorld, _normalMatrix, attrSet, invertedGeometry !== invertTri );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn splitIds.length;\n\n}\n\n// perform CSG operations on the set of whole triangles using a half edge structure\n// at the moment this isn't always faster due to overhead of building the half edge structure\n// and degraded connectivity due to split triangles.\n\nfunction performWholeTriangleOperations(\n\ta,\n\tb,\n\tsplitTriSet,\n\toperations,\n\tinvert,\n\tattributeData,\n\tgroupOffset = 0,\n) {\n\n\tconst invertedGeometry = a.matrixWorld.determinant() < 0;\n\n\t// matrix for transforming into the local frame of geometry b\n\t_matrix\n\t\t.copy( b.matrixWorld )\n\t\t.invert()\n\t\t.multiply( a.matrixWorld );\n\n\t_normalMatrix\n\t\t.getNormalMatrix( a.matrixWorld )\n\t\t.multiplyScalar( invertedGeometry ? - 1 : 1 );\n\n\tconst bBVH = b.geometry.boundsTree;\n\tconst groupIndices = a.geometry.groupIndices;\n\tconst aIndex = a.geometry.index;\n\tconst aAttributes = a.geometry.attributes;\n\tconst aPosition = aAttributes.position;\n\n\tconst stack = [];\n\tconst halfEdges = a.geometry.halfEdges;\n\tconst traverseSet = new Set();\n\tconst triCount = getTriCount( a.geometry );\n\tfor ( let i = 0, l = triCount; i < l; i ++ ) {\n\n\t\tif ( ! ( i in splitTriSet.intersectionSet ) ) {\n\n\t\t\ttraverseSet.add( i );\n\n\t\t}\n\n\t}\n\n\twhile ( traverseSet.size > 0 ) {\n\n\t\tconst id = getFirstIdFromSet( traverseSet );\n\t\ttraverseSet.delete( id );\n\n\t\tstack.push( id );\n\n\t\t// get the vertex indices\n\t\tconst i3 = 3 * id;\n\t\tconst i0 = aIndex.getX( i3 + 0 );\n\t\tconst i1 = aIndex.getX( i3 + 1 );\n\t\tconst i2 = aIndex.getX( i3 + 2 );\n\n\t\t// get the vertex position in the frame of geometry b so we can\n\t\t// perform hit testing\n\t\t_tri.a.fromBufferAttribute( aPosition, i0 ).applyMatrix4( _matrix );\n\t\t_tri.b.fromBufferAttribute( aPosition, i1 ).applyMatrix4( _matrix );\n\t\t_tri.c.fromBufferAttribute( aPosition, i2 ).applyMatrix4( _matrix );\n\n\t\t// get the side and decide if we need to cull the triangle based on the operation\n\t\tconst hitSide = getHitSide( _tri, bBVH );\n\n\t\t_actions.length = 0;\n\t\t_attr.length = 0;\n\t\tfor ( let o = 0, lo = operations.length; o < lo; o ++ ) {\n\n\t\t\tconst op = getOperationAction( operations[ o ], hitSide, invert );\n\t\t\tif ( op !== SKIP_TRI ) {\n\n\t\t\t\t_actions.push( op );\n\t\t\t\t_attr.push( attributeData[ o ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\twhile ( stack.length > 0 ) {\n\n\t\t\tconst currId = stack.pop();\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst sid = halfEdges.getSiblingTriangleIndex( currId, i );\n\t\t\t\tif ( sid !== - 1 && traverseSet.has( sid ) ) {\n\n\t\t\t\t\tstack.push( sid );\n\t\t\t\t\ttraverseSet.delete( sid );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( _attr.length !== 0 ) {\n\n\t\t\t\tconst i3 = 3 * currId;\n\t\t\t\tconst i0 = aIndex.getX( i3 + 0 );\n\t\t\t\tconst i1 = aIndex.getX( i3 + 1 );\n\t\t\t\tconst i2 = aIndex.getX( i3 + 2 );\n\t\t\t\tconst groupIndex = groupOffset === - 1 ? 0 : groupIndices[ currId ] + groupOffset;\n\n\t\t\t\t_tri.a.fromBufferAttribute( aPosition, i0 );\n\t\t\t\t_tri.b.fromBufferAttribute( aPosition, i1 );\n\t\t\t\t_tri.c.fromBufferAttribute( aPosition, i2 );\n\t\t\t\tif ( ! isTriDegenerate( _tri ) ) {\n\n\t\t\t\t\tfor ( let k = 0, lk = _attr.length; k < lk; k ++ ) {\n\n\t\t\t\t\t\tconst action = _actions[ k ];\n\t\t\t\t\t\tconst attrSet = _attr[ k ].getGroupAttrSet( groupIndex );\n\t\t\t\t\t\tconst invertTri = action === INVERT_TRI;\n\t\t\t\t\t\tappendAttributesFromIndices( i0, i1, i2, aAttributes, a.matrixWorld, _normalMatrix, attrSet, invertTri !== invertedGeometry );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n","import { BufferAttribute } from 'three';\nimport { TriangleSplitter } from './TriangleSplitter.js';\nimport { TypedAttributeData } from './TypedAttributeData.js';\nimport { OperationDebugData } from './debug/OperationDebugData.js';\nimport { performOperation } from './operations/operations.js';\nimport { Brush } from './Brush.js';\n\n// merges groups with common material indices in place\nfunction joinGroups( groups ) {\n\n\tfor ( let i = 0; i < groups.length - 1; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\t\tconst nextGroup = groups[ i + 1 ];\n\t\tif ( group.materialIndex === nextGroup.materialIndex ) {\n\n\t\t\tconst start = group.start;\n\t\t\tconst end = nextGroup.start + nextGroup.count;\n\t\t\tnextGroup.start = start;\n\t\t\tnextGroup.count = end - start;\n\n\t\t\tgroups.splice( i, 1 );\n\t\t\ti --;\n\n\t\t}\n\n\t}\n\n}\n\n// initialize the target geometry and attribute data to be based on\n// the given reference geometry\nfunction prepareAttributesData( referenceGeometry, targetGeometry, attributeData, relevantAttributes ) {\n\n\tattributeData.clear();\n\n\t// initialize and clear unused data from the attribute buffers and vice versa\n\tconst aAttributes = referenceGeometry.attributes;\n\tfor ( let i = 0, l = relevantAttributes.length; i < l; i ++ ) {\n\n\t\tconst key = relevantAttributes[ i ];\n\t\tconst aAttr = aAttributes[ key ];\n\t\tattributeData.initializeArray( key, aAttr.array.constructor, aAttr.itemSize, aAttr.normalized );\n\n\t}\n\n\tfor ( const key in attributeData.attributes ) {\n\n\t\tif ( ! relevantAttributes.includes( key ) ) {\n\n\t\t\tattributeData.delete( key );\n\n\t\t}\n\n\t}\n\n\tfor ( const key in targetGeometry.attributes ) {\n\n\t\tif ( ! relevantAttributes.includes( key ) ) {\n\n\t\t\ttargetGeometry.deleteAttribute( key );\n\t\t\ttargetGeometry.dispose();\n\n\t\t}\n\n\t}\n\n}\n\n// Assigns the given tracked attribute data to the geometry and returns whether the\n// geometry needs to be disposed of.\nfunction assignBufferData( geometry, attributeData, groupOrder ) {\n\n\tlet needsDisposal = false;\n\tlet drawRange = - 1;\n\n\t// set the data\n\tconst attributes = geometry.attributes;\n\tconst referenceAttrSet = attributeData.groupAttributes[ 0 ];\n\tfor ( const key in referenceAttrSet ) {\n\n\t\tconst requiredLength = attributeData.getTotalLength( key );\n\t\tconst type = attributeData.getType( key );\n\t\tconst itemSize = attributeData.getItemSize( key );\n\t\tconst normalized = attributeData.getNormalized( key );\n\t\tlet geoAttr = attributes[ key ];\n\t\tif ( ! geoAttr || geoAttr.array.length < requiredLength ) {\n\n\t\t\t// create the attribute if it doesn't exist yet\n\t\t\tgeoAttr = new BufferAttribute( new type( requiredLength ), itemSize, normalized );\n\t\t\tgeometry.setAttribute( key, geoAttr );\n\t\t\tneedsDisposal = true;\n\n\t\t}\n\n\t\t// assign the data to the geometry attribute buffers in the provided order\n\t\t// of the groups list\n\t\tlet offset = 0;\n\t\tfor ( let i = 0, l = Math.min( groupOrder.length, attributeData.groupCount ); i < l; i ++ ) {\n\n\t\t\tconst index = groupOrder[ i ].index;\n\t\t\tconst { array, type, length } = attributeData.groupAttributes[ index ][ key ];\n\t\t\tconst trimmedArray = new type( array.buffer, 0, length );\n\t\t\tgeoAttr.array.set( trimmedArray, offset );\n\t\t\toffset += trimmedArray.length;\n\n\t\t}\n\n\t\tgeoAttr.needsUpdate = true;\n\t\tdrawRange = requiredLength / geoAttr.itemSize;\n\n\t}\n\n\t// remove or update the index appropriately\n\tif ( geometry.index ) {\n\n\t\tconst indexArray = geometry.index.array;\n\t\tif ( indexArray.length < drawRange ) {\n\n\t\t\tgeometry.index = null;\n\t\t\tneedsDisposal = true;\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0, l = indexArray.length; i < l; i ++ ) {\n\n\t\t\t\tindexArray[ i ] = i;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// initialize the groups\n\tlet groupOffset = 0;\n\tgeometry.clearGroups();\n\tfor ( let i = 0, l = Math.min( groupOrder.length, attributeData.groupCount ); i < l; i ++ ) {\n\n\t\tconst { index, materialIndex } = groupOrder[ i ];\n\t\tconst vertCount = attributeData.getCount( index );\n\t\tif ( vertCount !== 0 ) {\n\n\t\t\tgeometry.addGroup( groupOffset, vertCount, materialIndex );\n\t\t\tgroupOffset += vertCount;\n\n\t\t}\n\n\t}\n\n\t// update the draw range\n\tgeometry.setDrawRange( 0, drawRange );\n\n\t// remove the bounds tree if it exists because its now out of date\n\t// TODO: can we have this dispose in the same way that a brush does?\n\t// TODO: why are half edges and group indices not removed here?\n\tgeometry.boundsTree = null;\n\n\tif ( needsDisposal ) {\n\n\t\tgeometry.dispose();\n\n\t}\n\n}\n\n// Returns the list of materials used for the given set of groups\nfunction getMaterialList( groups, materials ) {\n\n\tlet result = materials;\n\tif ( ! Array.isArray( materials ) ) {\n\n\t\tresult = [];\n\t\tgroups.forEach( g => {\n\n\t\t\tresult[ g.materialIndex ] = materials;\n\n\t\t} );\n\n\t}\n\n\treturn result;\n\n}\n\n// Utility class for performing CSG operations\nexport class Evaluator {\n\n\tconstructor() {\n\n\t\tthis.triangleSplitter = new TriangleSplitter();\n\t\tthis.attributeData = [];\n\t\tthis.attributes = [ 'position', 'uv', 'normal' ];\n\t\tthis.useGroups = true;\n\t\tthis.consolidateGroups = true;\n\t\tthis.debug = new OperationDebugData();\n\n\t}\n\n\tgetGroupRanges( geometry ) {\n\n\t\treturn ! this.useGroups || geometry.groups.length === 0 ?\n\t\t\t[ { start: 0, count: Infinity, materialIndex: 0 } ] :\n\t\t\tgeometry.groups.map( group => ( { ...group } ) );\n\n\t}\n\n\tevaluate( a, b, operations, targetBrushes = new Brush() ) {\n\n\t\tlet wasArray = true;\n\t\tif ( ! Array.isArray( operations ) ) {\n\n\t\t\toperations = [ operations ];\n\n\t\t}\n\n\t\tif ( ! Array.isArray( targetBrushes ) ) {\n\n\t\t\ttargetBrushes = [ targetBrushes ];\n\t\t\twasArray = false;\n\n\t\t}\n\n\t\tif ( targetBrushes.length !== operations.length ) {\n\n\t\t\tthrow new Error( 'Evaluator: operations and target array passed as different sizes.' );\n\n\t\t}\n\n\t\ta.prepareGeometry();\n\t\tb.prepareGeometry();\n\n\t\tconst {\n\t\t\ttriangleSplitter,\n\t\t\tattributeData,\n\t\t\tattributes,\n\t\t\tuseGroups,\n\t\t\tconsolidateGroups,\n\t\t\tdebug,\n\t\t} = this;\n\n\t\t// expand the attribute data array to the necessary size\n\t\twhile ( attributeData.length < targetBrushes.length ) {\n\n\t\t\tattributeData.push( new TypedAttributeData() );\n\n\t\t}\n\n\t\t// prepare the attribute data buffer information\n\t\ttargetBrushes.forEach( ( brush, i ) => {\n\n\t\t\tprepareAttributesData( a.geometry, brush.geometry, attributeData[ i ], attributes );\n\n\t\t} );\n\n\t\t// run the operation to fill the list of attribute data\n\t\tdebug.init();\n\t\tperformOperation( a, b, operations, triangleSplitter, attributeData, { useGroups } );\n\t\tdebug.complete();\n\n\t\t// get the materials and group ranges\n\t\tconst aGroups = this.getGroupRanges( a.geometry );\n\t\tconst aMaterials = getMaterialList( aGroups, a.material );\n\n\t\tconst bGroups = this.getGroupRanges( b.geometry );\n\t\tconst bMaterials = getMaterialList( bGroups, b.material );\n\t\tbGroups.forEach( g => g.materialIndex += aMaterials.length );\n\n\t\tlet groups = [ ...aGroups, ...bGroups ]\n\t\t\t.map( ( group, index ) => ( { ...group, index } ) );\n\n\t\t// generate the minimum set of materials needed for the list of groups and adjust the groups\n\t\t// if they're needed\n\t\tif ( useGroups ) {\n\n\t\t\tconst allMaterials = [ ...aMaterials, ...bMaterials ];\n\t\t\tif ( consolidateGroups ) {\n\n\t\t\t\tgroups = groups\n\t\t\t\t\t.map( group => {\n\n\t\t\t\t\t\tconst mat = allMaterials[ group.materialIndex ];\n\t\t\t\t\t\tgroup.materialIndex = allMaterials.indexOf( mat );\n\t\t\t\t\t\treturn group;\n\n\t\t\t\t\t} )\n\t\t\t\t\t.sort( ( a, b ) => {\n\n\t\t\t\t\t\treturn a.materialIndex - b.materialIndex;\n\n\t\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\t// create a map from old to new index and remove materials that aren't used\n\t\t\tconst finalMaterials = [];\n\t\t\tfor ( let i = 0, l = allMaterials.length; i < l; i ++ ) {\n\n\t\t\t\tlet foundGroup = false;\n\t\t\t\tfor ( let g = 0, lg = groups.length; g < lg; g ++ ) {\n\n\t\t\t\t\tconst group = groups[ g ];\n\t\t\t\t\tif ( group.materialIndex === i ) {\n\n\t\t\t\t\t\tfoundGroup = true;\n\t\t\t\t\t\tgroup.materialIndex = finalMaterials.length;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( foundGroup ) {\n\n\t\t\t\t\tfinalMaterials.push( allMaterials[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttargetBrushes.forEach( tb => {\n\n\t\t\t\ttb.material = finalMaterials;\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\tgroups = [ { start: 0, count: Infinity, index: 0, materialIndex: 0 } ];\n\t\t\ttargetBrushes.forEach( tb => {\n\n\t\t\t\ttb.material = aMaterials[ 0 ];\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// apply groups and attribute data to the geometry\n\t\ttargetBrushes.forEach( ( brush, i ) => {\n\n\t\t\tconst targetGeometry = brush.geometry;\n\t\t\tassignBufferData( targetGeometry, attributeData[ i ], groups );\n\t\t\tif ( consolidateGroups ) {\n\n\t\t\t\tjoinGroups( targetGeometry.groups );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn wasArray ? targetBrushes : targetBrushes[ 0 ];\n\n\t}\n\n\t// TODO: fix\n\tevaluateHierarchy( root, target = new Brush() ) {\n\n\t\troot.updateMatrixWorld( true );\n\n\t\tconst flatTraverse = ( obj, cb ) => {\n\n\t\t\tconst children = obj.children;\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = children[ i ];\n\t\t\t\tif ( child.isOperationGroup ) {\n\n\t\t\t\t\tflatTraverse( child, cb );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcb( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\n\t\tconst traverse = brush => {\n\n\t\t\tconst children = brush.children;\n\t\t\tlet didChange = false;\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = children[ i ];\n\t\t\t\tdidChange = traverse( child ) || didChange;\n\n\t\t\t}\n\n\t\t\tconst isDirty = brush.isDirty();\n\t\t\tif ( isDirty ) {\n\n\t\t\t\tbrush.markUpdated();\n\n\t\t\t}\n\n\t\t\tif ( didChange && ! brush.isOperationGroup ) {\n\n\t\t\t\tlet result;\n\t\t\t\tflatTraverse( brush, child => {\n\n\t\t\t\t\tif ( ! result ) {\n\n\t\t\t\t\t\tresult = this.evaluate( brush, child, child.operation );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tresult = this.evaluate( result, child, child.operation );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tbrush._cachedGeometry = result.geometry;\n\t\t\t\tbrush._cachedMaterials = result.material;\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn didChange || isDirty;\n\n\t\t\t}\n\n\t\t};\n\n\t\ttraverse( root );\n\n\t\ttarget.geometry = root._cachedGeometry;\n\t\ttarget.material = root._cachedMaterials;\n\n\t\treturn target;\n\n\t}\n\n\treset() {\n\n\t\tthis.triangleSplitter.reset();\n\n\t}\n\n}\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { extend } from '@react-three/fiber';\nimport { Evaluator, ADDITION, Brush, SUBTRACTION, REVERSE_SUBTRACTION, DIFFERENCE, INTERSECTION } from 'three-bvh-csg';\n\nconst TYPES = {\n  subtraction: SUBTRACTION,\n  reverseSubtraction: REVERSE_SUBTRACTION,\n  addition: ADDITION,\n  difference: DIFFERENCE,\n  intersection: INTERSECTION\n};\n\nfunction dispose(geometry) {\n  geometry.dispose();\n  geometry.attributes = {};\n  geometry.groups = [];\n  geometry.boundsTree = geometry.index = geometry.boundingBox = geometry.boundingSphere = null;\n  geometry.drawRange = {\n    start: 0,\n    count: Infinity\n  };\n}\n\nfunction resolve(op) {\n  let currentOp = null;\n\n  if (op instanceof Brush) {\n    op.updateMatrixWorld();\n    currentOp = op;\n  } else {\n    op.traverse(obj => {\n      obj.updateMatrixWorld();\n      if (!currentOp && obj instanceof Brush) currentOp = obj;\n    });\n  }\n\n  return currentOp;\n}\n\nconst csgContext = /*#__PURE__*/React.createContext(null);\nconst Geometry = /*#__PURE__*/React.forwardRef(({\n  children,\n  computeVertexNormals = false,\n  useGroups = false,\n  showOperations = false\n}, fref) => {\n  const geo = React.useRef(null);\n  const operations = React.useRef(null);\n  const ev = React.useMemo(() => Object.assign(new Evaluator(), {\n    useGroups\n  }), [useGroups]);\n  const update = React.useCallback(() => {\n    try {\n      const ops = operations.current.children.slice();\n\n      if (ops.length > 0) {\n        // Dispose old geometry\n        dispose(geo.current); // Set the ops groups matrix to identiy\n\n        operations.current.matrixWorld.identity();\n        let root = resolve(ops.shift());\n\n        if (root) {\n          var _geo$current, _geo$current$__r3f, _geo$current$__r3f$pa;\n\n          while (ops.length) {\n            const op = resolve(ops.shift());\n            if (op) root = ev.evaluate(root, op, TYPES[op.operator] || ADDITION);\n          }\n\n          ;\n          geo.current.boundsTree = root.geometry.boundsTree;\n          geo.current.index = root.geometry.index;\n          geo.current.attributes = root.geometry.attributes;\n          geo.current.groups = root.geometry.groups;\n          geo.current.drawRange = root.geometry.drawRange;\n          if (ev.useGroups && (_geo$current = geo.current) != null && (_geo$current$__r3f = _geo$current.__r3f) != null && (_geo$current$__r3f$pa = _geo$current$__r3f.parent) != null && _geo$current$__r3f$pa.material) geo.current.__r3f.parent.material = root.material;\n          if (computeVertexNormals) geo.current.computeVertexNormals();\n        }\n      }\n    } catch (e) {\n      console.log(e);\n    }\n  }, [computeVertexNormals, ev]);\n  const api = React.useMemo(() => ({\n    computeVertexNormals,\n    showOperations,\n    useGroups,\n    update\n  }), [computeVertexNormals, showOperations, useGroups]);\n  React.useLayoutEffect(() => void update());\n  React.useImperativeHandle(fref, () => ({\n    geometry: geo.current,\n    operations: operations.current,\n    ...api\n  }), [api]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"group\", {\n    matrixAutoUpdate: false,\n    ref: operations\n  }, /*#__PURE__*/React.createElement(csgContext.Provider, {\n    value: api\n  }, children)), /*#__PURE__*/React.createElement(\"bufferGeometry\", {\n    ref: geo\n  }));\n});\nconst Base = /*#__PURE__*/React.forwardRef(({\n  showOperation = false,\n  operator = 'addition',\n  ...props\n}, fref) => {\n  extend({\n    Brush: Brush\n  });\n  const {\n    showOperations\n  } = React.useContext(csgContext);\n  return /*#__PURE__*/React.createElement(\"brush\", _extends({\n    operator: operator,\n    raycast: () => null,\n    visible: showOperation || showOperations,\n    ref: fref\n  }, props));\n});\nconst Addition = /*#__PURE__*/React.forwardRef((props, fref) => /*#__PURE__*/React.createElement(Base, _extends({\n  ref: fref,\n  operator: \"addition\"\n}, props)));\nconst Subtraction = /*#__PURE__*/React.forwardRef((props, fref) => /*#__PURE__*/React.createElement(Base, _extends({\n  ref: fref,\n  operator: \"subtraction\"\n}, props)));\nconst ReverseSubtraction = /*#__PURE__*/React.forwardRef((props, fref) => /*#__PURE__*/React.createElement(Base, _extends({\n  ref: fref,\n  operator: \"reverseSubtraction\"\n}, props)));\nconst Difference = /*#__PURE__*/React.forwardRef((props, fref) => /*#__PURE__*/React.createElement(Base, _extends({\n  ref: fref,\n  operator: \"difference\"\n}, props)));\nconst Intersection = /*#__PURE__*/React.forwardRef((props, fref) => /*#__PURE__*/React.createElement(Base, _extends({\n  ref: fref,\n  operator: \"intersection\"\n}, props)));\nfunction useCSG() {\n  return React.useContext(csgContext);\n}\n\nexport { Addition, Base, Difference, Geometry, Intersection, ReverseSubtraction, Subtraction, useCSG };\n","import * as THREE from 'three';\n\nfunction shaderMaterial(uniforms, vertexShader, fragmentShader, onInit) {\n  const material = class material extends THREE.ShaderMaterial {\n    constructor(parameters = {}) {\n      const entries = Object.entries(uniforms);\n      // Create unforms and shaders\n      super({\n        uniforms: entries.reduce((acc, [name, value]) => {\n          const uniform = THREE.UniformsUtils.clone({\n            [name]: {\n              value\n            }\n          });\n          return {\n            ...acc,\n            ...uniform\n          };\n        }, {}),\n        vertexShader,\n        fragmentShader\n      });\n      // Create getter/setters\n      this.key = '';\n      entries.forEach(([name]) => Object.defineProperty(this, name, {\n        get: () => this.uniforms[name].value,\n        set: v => this.uniforms[name].value = v\n      }));\n\n      // Assign parameters, this might include uniforms\n      Object.assign(this, parameters);\n      // Call onInit\n      if (onInit) onInit(this);\n    }\n  };\n  material.key = THREE.MathUtils.generateUUID();\n  return material;\n}\n\nexport { shaderMaterial };\n","import { shaderMaterial } from '../core/shaderMaterial.js';\n\nconst DiscardMaterial = /* @__PURE__ */shaderMaterial({}, 'void main() { }', 'void main() { gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0); discard;  }');\n\nexport { DiscardMaterial };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useFrame } from '@react-three/fiber';\nimport { useFBO } from './useFBO.js';\nimport { DiscardMaterial } from '../materials/DiscardMaterial.js';\n\nclass MeshTransmissionMaterialImpl extends THREE.MeshPhysicalMaterial {\n  constructor(samples = 6, transmissionSampler = false) {\n    super();\n    this.uniforms = {\n      chromaticAberration: {\n        value: 0.05\n      },\n      // Transmission must always be 0, unless transmissionSampler is being used\n      transmission: {\n        value: 0\n      },\n      // Instead a workaround is used, see below for reasons why\n      _transmission: {\n        value: 1\n      },\n      transmissionMap: {\n        value: null\n      },\n      // Roughness is 1 in THREE.MeshPhysicalMaterial but it makes little sense in a transmission material\n      roughness: {\n        value: 0\n      },\n      thickness: {\n        value: 0\n      },\n      thicknessMap: {\n        value: null\n      },\n      attenuationDistance: {\n        value: Infinity\n      },\n      attenuationColor: {\n        value: new THREE.Color('white')\n      },\n      anisotropicBlur: {\n        value: 0.1\n      },\n      time: {\n        value: 0\n      },\n      distortion: {\n        value: 0.0\n      },\n      distortionScale: {\n        value: 0.5\n      },\n      temporalDistortion: {\n        value: 0.0\n      },\n      buffer: {\n        value: null\n      }\n    };\n    this.onBeforeCompile = shader => {\n      shader.uniforms = {\n        ...shader.uniforms,\n        ...this.uniforms\n      };\n\n      // Fix for r153-r156 anisotropy chunks\n      // https://github.com/mrdoob/three.js/pull/26716\n      if (this.anisotropy > 0) shader.defines.USE_ANISOTROPY = '';\n\n      // If the transmission sampler is active inject a flag\n      if (transmissionSampler) shader.defines.USE_SAMPLER = '';\n      // Otherwise we do use use .transmission and must therefore force USE_TRANSMISSION\n      // because threejs won't inject it for us\n      else shader.defines.USE_TRANSMISSION = '';\n\n      // Head\n      shader.fragmentShader = /*glsl*/`\n      uniform float chromaticAberration;         \n      uniform float anisotropicBlur;      \n      uniform float time;\n      uniform float distortion;\n      uniform float distortionScale;\n      uniform float temporalDistortion;\n      uniform sampler2D buffer;\n\n      vec3 random3(vec3 c) {\n        float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n        vec3 r;\n        r.z = fract(512.0*j);\n        j *= .125;\n        r.x = fract(512.0*j);\n        j *= .125;\n        r.y = fract(512.0*j);\n        return r-0.5;\n      }\n\n      uint hash( uint x ) {\n        x += ( x << 10u );\n        x ^= ( x >>  6u );\n        x += ( x <<  3u );\n        x ^= ( x >> 11u );\n        x += ( x << 15u );\n        return x;\n      }\n\n      // Compound versions of the hashing algorithm I whipped together.\n      uint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\n      uint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\n      uint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n      // Construct a float with half-open range [0:1] using low 23 bits.\n      // All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\n      float floatConstruct( uint m ) {\n        const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n        const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n        m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n        m |= ieeeOne;                          // Add fractional part to 1.0\n        float  f = uintBitsToFloat( m );       // Range [1:2]\n        return f - 1.0;                        // Range [0:1]\n      }\n\n      // Pseudo-random value in half-open range [0:1].\n      float randomBase( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\n      float randomBase( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n      float randomBase( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n      float randomBase( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n      float rand(float seed) {\n        float result = randomBase(vec3(gl_FragCoord.xy, seed));\n        return result;\n      }\n\n      const float F3 =  0.3333333;\n      const float G3 =  0.1666667;\n\n      float snoise(vec3 p) {\n        vec3 s = floor(p + dot(p, vec3(F3)));\n        vec3 x = p - s + dot(s, vec3(G3));\n        vec3 e = step(vec3(0.0), x - x.yzx);\n        vec3 i1 = e*(1.0 - e.zxy);\n        vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n        vec3 x1 = x - i1 + G3;\n        vec3 x2 = x - i2 + 2.0*G3;\n        vec3 x3 = x - 1.0 + 3.0*G3;\n        vec4 w, d;\n        w.x = dot(x, x);\n        w.y = dot(x1, x1);\n        w.z = dot(x2, x2);\n        w.w = dot(x3, x3);\n        w = max(0.6 - w, 0.0);\n        d.x = dot(random3(s), x);\n        d.y = dot(random3(s + i1), x1);\n        d.z = dot(random3(s + i2), x2);\n        d.w = dot(random3(s + 1.0), x3);\n        w *= w;\n        w *= w;\n        d *= w;\n        return dot(d, vec4(52.0));\n      }\n\n      float snoiseFractal(vec3 m) {\n        return 0.5333333* snoise(m)\n              +0.2666667* snoise(2.0*m)\n              +0.1333333* snoise(4.0*m)\n              +0.0666667* snoise(8.0*m);\n      }\\n` + shader.fragmentShader;\n\n      // Remove transmission\n      shader.fragmentShader = shader.fragmentShader.replace('#include <transmission_pars_fragment>', /*glsl*/`\n        #ifdef USE_TRANSMISSION\n          // Transmission code is based on glTF-Sampler-Viewer\n          // https://github.com/KhronosGroup/glTF-Sample-Viewer\n          uniform float _transmission;\n          uniform float thickness;\n          uniform float attenuationDistance;\n          uniform vec3 attenuationColor;\n          #ifdef USE_TRANSMISSIONMAP\n            uniform sampler2D transmissionMap;\n          #endif\n          #ifdef USE_THICKNESSMAP\n            uniform sampler2D thicknessMap;\n          #endif\n          uniform vec2 transmissionSamplerSize;\n          uniform sampler2D transmissionSamplerMap;\n          uniform mat4 modelMatrix;\n          uniform mat4 projectionMatrix;\n          varying vec3 vWorldPosition;\n          vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n            // Direction of refracted light.\n            vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n            // Compute rotation-independant scaling of the model matrix.\n            vec3 modelScale;\n            modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n            modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n            modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n            // The thickness is specified in local space.\n            return normalize( refractionVector ) * thickness * modelScale;\n          }\n          float applyIorToRoughness( const in float roughness, const in float ior ) {\n            // Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n            // an IOR of 1.5 results in the default amount of microfacet refraction.\n            return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n          }\n          vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n            float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );            \n            #ifdef USE_SAMPLER\n              #ifdef texture2DLodEXT\n                return texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod);\n              #else\n                return texture2D(transmissionSamplerMap, fragCoord.xy, framebufferLod);\n              #endif\n            #else\n              return texture2D(buffer, fragCoord.xy);\n            #endif\n          }\n          vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n            if ( isinf( attenuationDistance ) ) {\n              // Attenuation distance is +, i.e. the transmitted color is not attenuated at all.\n              return radiance;\n            } else {\n              // Compute light attenuation using Beer's law.\n              vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n              vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance ); // Beer's law\n              return transmittance * radiance;\n            }\n          }\n          vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n            const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n            const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n            const in vec3 attenuationColor, const in float attenuationDistance ) {\n            vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n            vec3 refractedRayExit = position + transmissionRay;\n            // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n            vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n            vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n            refractionCoords += 1.0;\n            refractionCoords /= 2.0;\n            // Sample framebuffer to get pixel the refracted ray hits.\n            vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n            vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n            // Get the specular component.\n            vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n            return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n          }\n        #endif\\n`);\n\n      // Add refraction\n      shader.fragmentShader = shader.fragmentShader.replace('#include <transmission_fragment>', /*glsl*/`  \n        // Improve the refraction to use the world pos\n        material.transmission = _transmission;\n        material.transmissionAlpha = 1.0;\n        material.thickness = thickness;\n        material.attenuationDistance = attenuationDistance;\n        material.attenuationColor = attenuationColor;\n        #ifdef USE_TRANSMISSIONMAP\n          material.transmission *= texture2D( transmissionMap, vUv ).r;\n        #endif\n        #ifdef USE_THICKNESSMAP\n          material.thickness *= texture2D( thicknessMap, vUv ).g;\n        #endif\n        \n        vec3 pos = vWorldPosition;\n        float runningSeed = 0.0;\n        vec3 v = normalize( cameraPosition - pos );\n        vec3 n = inverseTransformDirection( normal, viewMatrix );\n        vec3 transmission = vec3(0.0);\n        float transmissionR, transmissionB, transmissionG;\n        float randomCoords = rand(runningSeed++);\n        float thickness_smear = thickness * max(pow(roughnessFactor, 0.33), anisotropicBlur);\n        vec3 distortionNormal = vec3(0.0);\n        vec3 temporalOffset = vec3(time, -time, -time) * temporalDistortion;\n        if (distortion > 0.0) {\n          distortionNormal = distortion * vec3(snoiseFractal(vec3((pos * distortionScale + temporalOffset))), snoiseFractal(vec3(pos.zxy * distortionScale - temporalOffset)), snoiseFractal(vec3(pos.yxz * distortionScale + temporalOffset)));\n        }\n        for (float i = 0.0; i < ${samples}.0; i ++) {\n          vec3 sampleNorm = normalize(n + roughnessFactor * roughnessFactor * 2.0 * normalize(vec3(rand(runningSeed++) - 0.5, rand(runningSeed++) - 0.5, rand(runningSeed++) - 0.5)) * pow(rand(runningSeed++), 0.33) + distortionNormal);\n          transmissionR = getIBLVolumeRefraction(\n            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness  + thickness_smear * (i + randomCoords) / float(${samples}),\n            material.attenuationColor, material.attenuationDistance\n          ).r;\n          transmissionG = getIBLVolumeRefraction(\n            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior  * (1.0 + chromaticAberration * (i + randomCoords) / float(${samples})) , material.thickness + thickness_smear * (i + randomCoords) / float(${samples}),\n            material.attenuationColor, material.attenuationDistance\n          ).g;\n          transmissionB = getIBLVolumeRefraction(\n            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior * (1.0 + 2.0 * chromaticAberration * (i + randomCoords) / float(${samples})), material.thickness + thickness_smear * (i + randomCoords) / float(${samples}),\n            material.attenuationColor, material.attenuationDistance\n          ).b;\n          transmission.r += transmissionR;\n          transmission.g += transmissionG;\n          transmission.b += transmissionB;\n        }\n        transmission /= ${samples}.0;\n        totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\\n`);\n    };\n    Object.keys(this.uniforms).forEach(name => Object.defineProperty(this, name, {\n      get: () => this.uniforms[name].value,\n      set: v => this.uniforms[name].value = v\n    }));\n  }\n}\nconst MeshTransmissionMaterial = /* @__PURE__ */React.forwardRef(({\n  buffer,\n  transmissionSampler = false,\n  backside = false,\n  side = THREE.FrontSide,\n  transmission = 1,\n  thickness = 0,\n  backsideThickness = 0,\n  samples = 10,\n  resolution,\n  backsideResolution,\n  background,\n  anisotropy,\n  anisotropicBlur,\n  ...props\n}, fref) => {\n  extend({\n    MeshTransmissionMaterial: MeshTransmissionMaterialImpl\n  });\n  const ref = React.useRef(null);\n  const [discardMaterial] = React.useState(() => new DiscardMaterial());\n  const fboBack = useFBO(backsideResolution || resolution);\n  const fboMain = useFBO(resolution);\n  let oldBg;\n  let oldTone;\n  let parent;\n  useFrame(state => {\n    ref.current.time = state.clock.getElapsedTime();\n    // Render only if the buffer matches the built-in and no transmission sampler is set\n    if (ref.current.buffer === fboMain.texture && !transmissionSampler) {\n      parent = ref.current.__r3f.parent;\n      if (parent) {\n        // Save defaults\n        oldTone = state.gl.toneMapping;\n        oldBg = state.scene.background;\n\n        // Switch off tonemapping lest it double tone maps\n        // Save the current background and set the HDR as the new BG\n        // Use discardmaterial, the parent will be invisible, but it's shadows will still be cast\n        state.gl.toneMapping = THREE.NoToneMapping;\n        if (background) state.scene.background = background;\n        parent.material = discardMaterial;\n        if (backside) {\n          // Render into the backside buffer\n          state.gl.setRenderTarget(fboBack);\n          state.gl.render(state.scene, state.camera);\n          // And now prepare the material for the main render using the backside buffer\n          parent.material = ref.current;\n          parent.material.buffer = fboBack.texture;\n          parent.material.thickness = backsideThickness;\n          parent.material.side = THREE.BackSide;\n        }\n\n        // Render into the main buffer\n        state.gl.setRenderTarget(fboMain);\n        state.gl.render(state.scene, state.camera);\n        parent.material = ref.current;\n        parent.material.thickness = thickness;\n        parent.material.side = side;\n        parent.material.buffer = fboMain.texture;\n\n        // Set old state back\n        state.scene.background = oldBg;\n        state.gl.setRenderTarget(null);\n        state.gl.toneMapping = oldTone;\n      }\n    }\n  });\n\n  // Forward ref\n  React.useImperativeHandle(fref, () => ref.current, []);\n  return /*#__PURE__*/React.createElement(\"meshTransmissionMaterial\", _extends({\n    // Samples must re-compile the shader so we memoize it\n    args: [samples, transmissionSampler],\n    ref: ref\n  }, props, {\n    buffer: buffer || fboMain.texture\n    // @ts-ignore\n    ,\n    _transmission: transmission\n    // In order for this to not incur extra cost \"transmission\" must be set to 0 and treated as a reserved prop.\n    // This is because THREE.WebGLRenderer will check for transmission > 0 and execute extra renders.\n    // The exception is when transmissionSampler is set, in which case we are using three's built in sampler.\n    ,\n    anisotropicBlur: anisotropicBlur !== null && anisotropicBlur !== void 0 ? anisotropicBlur : anisotropy,\n    transmission: transmissionSampler ? transmission : 0,\n    thickness: thickness,\n    side: side\n  }));\n});\n\nexport { MeshTransmissionMaterial };\n","import { BackSide, BoxGeometry, Mesh, ShaderMaterial, UniformsUtils, Vector3 } from 'three'\nimport { version } from '../_polyfill/constants'\n\nconst SkyShader = {\n  uniforms: {\n    turbidity: { value: 2 },\n    rayleigh: { value: 1 },\n    mieCoefficient: { value: 0.005 },\n    mieDirectionalG: { value: 0.8 },\n    sunPosition: { value: new Vector3() },\n    up: { value: new Vector3(0, 1, 0) },\n  },\n\n  vertexShader: /* glsl */ `\n      uniform vec3 sunPosition;\n      uniform float rayleigh;\n      uniform float turbidity;\n      uniform float mieCoefficient;\n      uniform vec3 up;\n\n      varying vec3 vWorldPosition;\n      varying vec3 vSunDirection;\n      varying float vSunfade;\n      varying vec3 vBetaR;\n      varying vec3 vBetaM;\n      varying float vSunE;\n\n      // constants for atmospheric scattering\n      const float e = 2.71828182845904523536028747135266249775724709369995957;\n      const float pi = 3.141592653589793238462643383279502884197169;\n\n      // wavelength of used primaries, according to preetham\n      const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );\n      // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:\n      // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\n      const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );\n\n      // mie stuff\n      // K coefficient for the primaries\n      const float v = 4.0;\n      const vec3 K = vec3( 0.686, 0.678, 0.666 );\n      // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\n      const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );\n\n      // earth shadow hack\n      // cutoffAngle = pi / 1.95;\n      const float cutoffAngle = 1.6110731556870734;\n      const float steepness = 1.5;\n      const float EE = 1000.0;\n\n      float sunIntensity( float zenithAngleCos ) {\n        zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );\n        return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );\n      }\n\n      vec3 totalMie( float T ) {\n        float c = ( 0.2 * T ) * 10E-18;\n        return 0.434 * c * MieConst;\n      }\n\n      void main() {\n\n        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n        vWorldPosition = worldPosition.xyz;\n\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        gl_Position.z = gl_Position.w; // set z to camera.far\n\n        vSunDirection = normalize( sunPosition );\n\n        vSunE = sunIntensity( dot( vSunDirection, up ) );\n\n        vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );\n\n        float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );\n\n      // extinction (absorbtion + out scattering)\n      // rayleigh coefficients\n        vBetaR = totalRayleigh * rayleighCoefficient;\n\n      // mie coefficients\n        vBetaM = totalMie( turbidity ) * mieCoefficient;\n\n      }\n    `,\n\n  fragmentShader: /* glsl */ `\n      varying vec3 vWorldPosition;\n      varying vec3 vSunDirection;\n      varying float vSunfade;\n      varying vec3 vBetaR;\n      varying vec3 vBetaM;\n      varying float vSunE;\n\n      uniform float mieDirectionalG;\n      uniform vec3 up;\n\n      const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );\n\n      // constants for atmospheric scattering\n      const float pi = 3.141592653589793238462643383279502884197169;\n\n      const float n = 1.0003; // refractive index of air\n      const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)\n\n      // optical length at zenith for molecules\n      const float rayleighZenithLength = 8.4E3;\n      const float mieZenithLength = 1.25E3;\n      // 66 arc seconds -> degrees, and the cosine of that\n      const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\n\n      // 3.0 / ( 16.0 * pi )\n      const float THREE_OVER_SIXTEENPI = 0.05968310365946075;\n      // 1.0 / ( 4.0 * pi )\n      const float ONE_OVER_FOURPI = 0.07957747154594767;\n\n      float rayleighPhase( float cosTheta ) {\n        return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );\n      }\n\n      float hgPhase( float cosTheta, float g ) {\n        float g2 = pow( g, 2.0 );\n        float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );\n        return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );\n      }\n\n      void main() {\n\n        vec3 direction = normalize( vWorldPosition - cameraPos );\n\n      // optical length\n      // cutoff angle at 90 to avoid singularity in next formula.\n        float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );\n        float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );\n        float sR = rayleighZenithLength * inverse;\n        float sM = mieZenithLength * inverse;\n\n      // combined extinction factor\n        vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );\n\n      // in scattering\n        float cosTheta = dot( direction, vSunDirection );\n\n        float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );\n        vec3 betaRTheta = vBetaR * rPhase;\n\n        float mPhase = hgPhase( cosTheta, mieDirectionalG );\n        vec3 betaMTheta = vBetaM * mPhase;\n\n        vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );\n        Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );\n\n      // nightsky\n        float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]\n        float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]\n        vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );\n        vec3 L0 = vec3( 0.1 ) * Fex;\n\n      // composition + solar disc\n        float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );\n        L0 += ( vSunE * 19000.0 * Fex ) * sundisk;\n\n        vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );\n\n        vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );\n\n        gl_FragColor = vec4( retColor, 1.0 );\n\n      #include <tonemapping_fragment>\n      #include <${version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n\n      }\n    `,\n}\n\nconst material = new ShaderMaterial({\n  name: 'SkyShader',\n  fragmentShader: SkyShader.fragmentShader,\n  vertexShader: SkyShader.vertexShader,\n  uniforms: UniformsUtils.clone(SkyShader.uniforms),\n  side: BackSide,\n  depthWrite: false,\n})\n\n/**\n * Based on \"A Practical Analytic Model for Daylight\"\n * aka The Preetham Model, the de facto standard analytic skydome model\n * https://www.researchgate.net/publication/220720443_A_Practical_Analytic_Model_for_Daylight\n *\n * First implemented by Simon Wallner\n * http://www.simonwallner.at/projects/atmospheric-scattering\n *\n * Improved by Martin Upitis\n * http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR\n *\n * Three.js integration by zz85 http://twitter.com/blurspline\n */\nclass Sky extends Mesh {\n  constructor() {\n    super(new BoxGeometry(1, 1, 1), material)\n  }\n\n  static SkyShader = SkyShader\n  public static material = material\n}\n\nexport { Sky }\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { Sky as Sky$1 } from 'three-stdlib';\nimport { Vector3 } from 'three';\n\nfunction calcPosFromAngles(inclination, azimuth, vector = new Vector3()) {\n  const theta = Math.PI * (inclination - 0.5);\n  const phi = 2 * Math.PI * (azimuth - 0.5);\n  vector.x = Math.cos(phi);\n  vector.y = Math.sin(theta);\n  vector.z = Math.sin(phi);\n  return vector;\n}\nconst Sky = /* @__PURE__ */React.forwardRef(({\n  inclination = 0.6,\n  azimuth = 0.1,\n  distance = 1000,\n  mieCoefficient = 0.005,\n  mieDirectionalG = 0.8,\n  rayleigh = 0.5,\n  turbidity = 10,\n  sunPosition = calcPosFromAngles(inclination, azimuth),\n  ...props\n}, ref) => {\n  const scale = React.useMemo(() => new Vector3().setScalar(distance), [distance]);\n  const [sky] = React.useState(() => new Sky$1());\n  return /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    object: sky,\n    ref: ref,\n    \"material-uniforms-mieCoefficient-value\": mieCoefficient,\n    \"material-uniforms-mieDirectionalG-value\": mieDirectionalG,\n    \"material-uniforms-rayleigh-value\": rayleigh,\n    \"material-uniforms-sunPosition-value\": sunPosition,\n    \"material-uniforms-turbidity-value\": turbidity,\n    scale: scale\n  }, props));\n});\n\nexport { Sky, calcPosFromAngles };\n","import { REVISION } from 'three'\n\nexport const version = parseInt(REVISION.replace(/\\D+/g, ''))\n","const Cache = {\n\n\tenabled: false,\n\n\tfiles: {},\n\n\tadd: function ( key, file ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\n\t\tthis.files[ key ] = file;\n\n\t},\n\n\tget: function ( key ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\n\t\treturn this.files[ key ];\n\n\t},\n\n\tremove: function ( key ) {\n\n\t\tdelete this.files[ key ];\n\n\t},\n\n\tclear: function () {\n\n\t\tthis.files = {};\n\n\t}\n\n};\n\n\nexport { Cache };\n","class LoadingManager {\n\n\tconstructor( onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tlet isLoading = false;\n\t\tlet itemsLoaded = 0;\n\t\tlet itemsTotal = 0;\n\t\tlet urlModifier = undefined;\n\t\tconst handlers = [];\n\n\t\t// Refer to #5689 for the reason why we don't set .onStart\n\t\t// in the constructor\n\n\t\tthis.onStart = undefined;\n\t\tthis.onLoad = onLoad;\n\t\tthis.onProgress = onProgress;\n\t\tthis.onError = onError;\n\n\t\tthis.itemStart = function ( url ) {\n\n\t\t\titemsTotal ++;\n\n\t\t\tif ( isLoading === false ) {\n\n\t\t\t\tif ( scope.onStart !== undefined ) {\n\n\t\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tisLoading = true;\n\n\t\t};\n\n\t\tthis.itemEnd = function ( url ) {\n\n\t\t\titemsLoaded ++;\n\n\t\t\tif ( scope.onProgress !== undefined ) {\n\n\t\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\n\t\t\t}\n\n\t\t\tif ( itemsLoaded === itemsTotal ) {\n\n\t\t\t\tisLoading = false;\n\n\t\t\t\tif ( scope.onLoad !== undefined ) {\n\n\t\t\t\t\tscope.onLoad();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.itemError = function ( url ) {\n\n\t\t\tif ( scope.onError !== undefined ) {\n\n\t\t\t\tscope.onError( url );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.resolveURL = function ( url ) {\n\n\t\t\tif ( urlModifier ) {\n\n\t\t\t\treturn urlModifier( url );\n\n\t\t\t}\n\n\t\t\treturn url;\n\n\t\t};\n\n\t\tthis.setURLModifier = function ( transform ) {\n\n\t\t\turlModifier = transform;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t\tthis.addHandler = function ( regex, loader ) {\n\n\t\t\thandlers.push( regex, loader );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t\tthis.removeHandler = function ( regex ) {\n\n\t\t\tconst index = handlers.indexOf( regex );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\thandlers.splice( index, 2 );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t};\n\n\t\tthis.getHandler = function ( file ) {\n\n\t\t\tfor ( let i = 0, l = handlers.length; i < l; i += 2 ) {\n\n\t\t\t\tconst regex = handlers[ i ];\n\t\t\t\tconst loader = handlers[ i + 1 ];\n\n\t\t\t\tif ( regex.global ) regex.lastIndex = 0; // see #17920\n\n\t\t\t\tif ( regex.test( file ) ) {\n\n\t\t\t\t\treturn loader;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t};\n\n\t}\n\n}\n\nconst DefaultLoadingManager = /*@__PURE__*/ new LoadingManager();\n\nexport { DefaultLoadingManager, LoadingManager };\n","import { DefaultLoadingManager } from './LoadingManager.js';\n\nclass Loader {\n\n\tconstructor( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t\tthis.crossOrigin = 'anonymous';\n\t\tthis.withCredentials = false;\n\t\tthis.path = '';\n\t\tthis.resourcePath = '';\n\t\tthis.requestHeader = {};\n\n\t}\n\n\tload( /* url, onLoad, onProgress, onError */ ) {}\n\n\tloadAsync( url, onProgress ) {\n\n\t\tconst scope = this;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tscope.load( url, resolve, onProgress, reject );\n\n\t\t} );\n\n\t}\n\n\tparse( /* data */ ) {}\n\n\tsetCrossOrigin( crossOrigin ) {\n\n\t\tthis.crossOrigin = crossOrigin;\n\t\treturn this;\n\n\t}\n\n\tsetWithCredentials( value ) {\n\n\t\tthis.withCredentials = value;\n\t\treturn this;\n\n\t}\n\n\tsetPath( path ) {\n\n\t\tthis.path = path;\n\t\treturn this;\n\n\t}\n\n\tsetResourcePath( resourcePath ) {\n\n\t\tthis.resourcePath = resourcePath;\n\t\treturn this;\n\n\t}\n\n\tsetRequestHeader( requestHeader ) {\n\n\t\tthis.requestHeader = requestHeader;\n\t\treturn this;\n\n\t}\n\n}\n\nexport { Loader };\n","function arrayMin( array ) {\n\n\tif ( array.length === 0 ) return Infinity;\n\n\tlet min = array[ 0 ];\n\n\tfor ( let i = 1, l = array.length; i < l; ++ i ) {\n\n\t\tif ( array[ i ] < min ) min = array[ i ];\n\n\t}\n\n\treturn min;\n\n}\n\nfunction arrayMax( array ) {\n\n\tif ( array.length === 0 ) return - Infinity;\n\n\tlet max = array[ 0 ];\n\n\tfor ( let i = 1, l = array.length; i < l; ++ i ) {\n\n\t\tif ( array[ i ] > max ) max = array[ i ];\n\n\t}\n\n\treturn max;\n\n}\n\nfunction arrayNeedsUint32( array ) {\n\n\t// assumes larger values usually on last\n\n\tfor ( let i = array.length - 1; i >= 0; -- i ) {\n\n\t\tif ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565\n\n\t}\n\n\treturn false;\n\n}\n\nconst TYPED_ARRAYS = {\n\tInt8Array: Int8Array,\n\tUint8Array: Uint8Array,\n\tUint8ClampedArray: Uint8ClampedArray,\n\tInt16Array: Int16Array,\n\tUint16Array: Uint16Array,\n\tInt32Array: Int32Array,\n\tUint32Array: Uint32Array,\n\tFloat32Array: Float32Array,\n\tFloat64Array: Float64Array\n};\n\nfunction getTypedArray( type, buffer ) {\n\n\treturn new TYPED_ARRAYS[ type ]( buffer );\n\n}\n\nfunction createElementNS( name ) {\n\n\treturn document.createElementNS( 'http://www.w3.org/1999/xhtml', name );\n\n}\n\nconst _cache = {};\n\nfunction warnOnce( message ) {\n\n\tif ( message in _cache ) return;\n\n\t_cache[ message ] = true;\n\n\tconsole.warn( message );\n\n}\n\nexport { arrayMin, arrayMax, arrayNeedsUint32, getTypedArray, createElementNS, warnOnce };\n","import { Cache } from './Cache.js';\nimport { Loader } from './Loader.js';\nimport { createElementNS } from '../utils.js';\n\nclass ImageLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tconst scope = this;\n\n\t\tconst cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\tsetTimeout( function () {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\tconst image = createElementNS( 'img' );\n\n\t\tfunction onImageLoad() {\n\n\t\t\tremoveEventListeners();\n\n\t\t\tCache.add( url, this );\n\n\t\t\tif ( onLoad ) onLoad( this );\n\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t}\n\n\t\tfunction onImageError( event ) {\n\n\t\t\tremoveEventListeners();\n\n\t\t\tif ( onError ) onError( event );\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t}\n\n\t\tfunction removeEventListeners() {\n\n\t\t\timage.removeEventListener( 'load', onImageLoad, false );\n\t\t\timage.removeEventListener( 'error', onImageError, false );\n\n\t\t}\n\n\t\timage.addEventListener( 'load', onImageLoad, false );\n\t\timage.addEventListener( 'error', onImageError, false );\n\n\t\tif ( url.slice( 0, 5 ) !== 'data:' ) {\n\n\t\t\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\n\n\t\t}\n\n\t\tscope.manager.itemStart( url );\n\n\t\timage.src = url;\n\n\t\treturn image;\n\n\t}\n\n}\n\n\nexport { ImageLoader };\n","/**\n * https://github.com/mrdoob/eventdispatcher.js/\n */\n\nclass EventDispatcher {\n\n\taddEventListener( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\tconst listeners = this._listeners;\n\n\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\tlisteners[ type ] = [];\n\n\t\t}\n\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\tlisteners[ type ].push( listener );\n\n\t\t}\n\n\t}\n\n\thasEventListener( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return false;\n\n\t\tconst listeners = this._listeners;\n\n\t\treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\n\n\t}\n\n\tremoveEventListener( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[ type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tconst index = listenerArray.indexOf( listener );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tdispatchEvent( event ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[ event.type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tevent.target = this;\n\n\t\t\t// Make a copy, in case listeners are removed while iterating.\n\t\t\tconst array = listenerArray.slice( 0 );\n\n\t\t\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t}\n\n\t\t\tevent.target = null;\n\n\t\t}\n\n\t}\n\n}\n\n\nexport { EventDispatcher };\n","export const REVISION = '153';\n\nexport const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };\nexport const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };\nexport const CullFaceNone = 0;\nexport const CullFaceBack = 1;\nexport const CullFaceFront = 2;\nexport const CullFaceFrontBack = 3;\nexport const BasicShadowMap = 0;\nexport const PCFShadowMap = 1;\nexport const PCFSoftShadowMap = 2;\nexport const VSMShadowMap = 3;\nexport const FrontSide = 0;\nexport const BackSide = 1;\nexport const DoubleSide = 2;\nexport const TwoPassDoubleSide = 2; // r149\nexport const NoBlending = 0;\nexport const NormalBlending = 1;\nexport const AdditiveBlending = 2;\nexport const SubtractiveBlending = 3;\nexport const MultiplyBlending = 4;\nexport const CustomBlending = 5;\nexport const AddEquation = 100;\nexport const SubtractEquation = 101;\nexport const ReverseSubtractEquation = 102;\nexport const MinEquation = 103;\nexport const MaxEquation = 104;\nexport const ZeroFactor = 200;\nexport const OneFactor = 201;\nexport const SrcColorFactor = 202;\nexport const OneMinusSrcColorFactor = 203;\nexport const SrcAlphaFactor = 204;\nexport const OneMinusSrcAlphaFactor = 205;\nexport const DstAlphaFactor = 206;\nexport const OneMinusDstAlphaFactor = 207;\nexport const DstColorFactor = 208;\nexport const OneMinusDstColorFactor = 209;\nexport const SrcAlphaSaturateFactor = 210;\nexport const NeverDepth = 0;\nexport const AlwaysDepth = 1;\nexport const LessDepth = 2;\nexport const LessEqualDepth = 3;\nexport const EqualDepth = 4;\nexport const GreaterEqualDepth = 5;\nexport const GreaterDepth = 6;\nexport const NotEqualDepth = 7;\nexport const MultiplyOperation = 0;\nexport const MixOperation = 1;\nexport const AddOperation = 2;\nexport const NoToneMapping = 0;\nexport const LinearToneMapping = 1;\nexport const ReinhardToneMapping = 2;\nexport const CineonToneMapping = 3;\nexport const ACESFilmicToneMapping = 4;\nexport const CustomToneMapping = 5;\n\nexport const UVMapping = 300;\nexport const CubeReflectionMapping = 301;\nexport const CubeRefractionMapping = 302;\nexport const EquirectangularReflectionMapping = 303;\nexport const EquirectangularRefractionMapping = 304;\nexport const CubeUVReflectionMapping = 306;\nexport const RepeatWrapping = 1000;\nexport const ClampToEdgeWrapping = 1001;\nexport const MirroredRepeatWrapping = 1002;\nexport const NearestFilter = 1003;\nexport const NearestMipmapNearestFilter = 1004;\nexport const NearestMipMapNearestFilter = 1004;\nexport const NearestMipmapLinearFilter = 1005;\nexport const NearestMipMapLinearFilter = 1005;\nexport const LinearFilter = 1006;\nexport const LinearMipmapNearestFilter = 1007;\nexport const LinearMipMapNearestFilter = 1007;\nexport const LinearMipmapLinearFilter = 1008;\nexport const LinearMipMapLinearFilter = 1008;\nexport const UnsignedByteType = 1009;\nexport const ByteType = 1010;\nexport const ShortType = 1011;\nexport const UnsignedShortType = 1012;\nexport const IntType = 1013;\nexport const UnsignedIntType = 1014;\nexport const FloatType = 1015;\nexport const HalfFloatType = 1016;\nexport const UnsignedShort4444Type = 1017;\nexport const UnsignedShort5551Type = 1018;\nexport const UnsignedInt248Type = 1020;\nexport const AlphaFormat = 1021;\nexport const RGBAFormat = 1023;\nexport const LuminanceFormat = 1024;\nexport const LuminanceAlphaFormat = 1025;\nexport const DepthFormat = 1026;\nexport const DepthStencilFormat = 1027;\nexport const RedFormat = 1028;\nexport const RedIntegerFormat = 1029;\nexport const RGFormat = 1030;\nexport const RGIntegerFormat = 1031;\nexport const RGBAIntegerFormat = 1033;\n\nexport const RGB_S3TC_DXT1_Format = 33776;\nexport const RGBA_S3TC_DXT1_Format = 33777;\nexport const RGBA_S3TC_DXT3_Format = 33778;\nexport const RGBA_S3TC_DXT5_Format = 33779;\nexport const RGB_PVRTC_4BPPV1_Format = 35840;\nexport const RGB_PVRTC_2BPPV1_Format = 35841;\nexport const RGBA_PVRTC_4BPPV1_Format = 35842;\nexport const RGBA_PVRTC_2BPPV1_Format = 35843;\nexport const RGB_ETC1_Format = 36196;\nexport const RGB_ETC2_Format = 37492;\nexport const RGBA_ETC2_EAC_Format = 37496;\nexport const RGBA_ASTC_4x4_Format = 37808;\nexport const RGBA_ASTC_5x4_Format = 37809;\nexport const RGBA_ASTC_5x5_Format = 37810;\nexport const RGBA_ASTC_6x5_Format = 37811;\nexport const RGBA_ASTC_6x6_Format = 37812;\nexport const RGBA_ASTC_8x5_Format = 37813;\nexport const RGBA_ASTC_8x6_Format = 37814;\nexport const RGBA_ASTC_8x8_Format = 37815;\nexport const RGBA_ASTC_10x5_Format = 37816;\nexport const RGBA_ASTC_10x6_Format = 37817;\nexport const RGBA_ASTC_10x8_Format = 37818;\nexport const RGBA_ASTC_10x10_Format = 37819;\nexport const RGBA_ASTC_12x10_Format = 37820;\nexport const RGBA_ASTC_12x12_Format = 37821;\nexport const RGBA_BPTC_Format = 36492;\nexport const RED_RGTC1_Format = 36283;\nexport const SIGNED_RED_RGTC1_Format = 36284;\nexport const RED_GREEN_RGTC2_Format = 36285;\nexport const SIGNED_RED_GREEN_RGTC2_Format = 36286;\nexport const LoopOnce = 2200;\nexport const LoopRepeat = 2201;\nexport const LoopPingPong = 2202;\nexport const InterpolateDiscrete = 2300;\nexport const InterpolateLinear = 2301;\nexport const InterpolateSmooth = 2302;\nexport const ZeroCurvatureEnding = 2400;\nexport const ZeroSlopeEnding = 2401;\nexport const WrapAroundEnding = 2402;\nexport const NormalAnimationBlendMode = 2500;\nexport const AdditiveAnimationBlendMode = 2501;\nexport const TrianglesDrawMode = 0;\nexport const TriangleStripDrawMode = 1;\nexport const TriangleFanDrawMode = 2;\n/** @deprecated Use LinearSRGBColorSpace or NoColorSpace in three.js r152+. */\nexport const LinearEncoding = 3000;\n/** @deprecated Use SRGBColorSpace in three.js r152+. */\nexport const sRGBEncoding = 3001;\nexport const BasicDepthPacking = 3200;\nexport const RGBADepthPacking = 3201;\nexport const TangentSpaceNormalMap = 0;\nexport const ObjectSpaceNormalMap = 1;\n\n// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.\nexport const NoColorSpace = '';\nexport const SRGBColorSpace = 'srgb';\nexport const LinearSRGBColorSpace = 'srgb-linear';\nexport const DisplayP3ColorSpace = 'display-p3';\n\nexport const ZeroStencilOp = 0;\nexport const KeepStencilOp = 7680;\nexport const ReplaceStencilOp = 7681;\nexport const IncrementStencilOp = 7682;\nexport const DecrementStencilOp = 7683;\nexport const IncrementWrapStencilOp = 34055;\nexport const DecrementWrapStencilOp = 34056;\nexport const InvertStencilOp = 5386;\n\nexport const NeverStencilFunc = 512;\nexport const LessStencilFunc = 513;\nexport const EqualStencilFunc = 514;\nexport const LessEqualStencilFunc = 515;\nexport const GreaterStencilFunc = 516;\nexport const NotEqualStencilFunc = 517;\nexport const GreaterEqualStencilFunc = 518;\nexport const AlwaysStencilFunc = 519;\n\nexport const NeverCompare = 512;\nexport const LessCompare = 513;\nexport const EqualCompare = 514;\nexport const LessEqualCompare = 515;\nexport const GreaterCompare = 516;\nexport const NotEqualCompare = 517;\nexport const GreaterEqualCompare = 518;\nexport const AlwaysCompare = 519;\n\nexport const StaticDrawUsage = 35044;\nexport const DynamicDrawUsage = 35048;\nexport const StreamDrawUsage = 35040;\nexport const StaticReadUsage = 35045;\nexport const DynamicReadUsage = 35049;\nexport const StreamReadUsage = 35041;\nexport const StaticCopyUsage = 35046;\nexport const DynamicCopyUsage = 35050;\nexport const StreamCopyUsage = 35042;\n\nexport const GLSL1 = '100';\nexport const GLSL3 = '300 es';\n\nexport const _SRGBAFormat = 1035; // fallback for WebGL 1\n\nexport const WebGLCoordinateSystem = 2000;\nexport const WebGPUCoordinateSystem = 2001;\n","const _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];\n\nlet _seed = 1234567;\n\n\nconst DEG2RAD = Math.PI / 180;\nconst RAD2DEG = 180 / Math.PI;\n\n// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\nfunction generateUUID() {\n\n\tconst d0 = Math.random() * 0xffffffff | 0;\n\tconst d1 = Math.random() * 0xffffffff | 0;\n\tconst d2 = Math.random() * 0xffffffff | 0;\n\tconst d3 = Math.random() * 0xffffffff | 0;\n\tconst uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +\n\t\t\t_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];\n\n\t// .toLowerCase() here flattens concatenated strings to save heap memory space.\n\treturn uuid.toLowerCase();\n\n}\n\nfunction clamp( value, min, max ) {\n\n\treturn Math.max( min, Math.min( max, value ) );\n\n}\n\n// compute euclidean modulo of m % n\n// https://en.wikipedia.org/wiki/Modulo_operation\nfunction euclideanModulo( n, m ) {\n\n\treturn ( ( n % m ) + m ) % m;\n\n}\n\n// Linear mapping from range <a1, a2> to range <b1, b2>\nfunction mapLinear( x, a1, a2, b1, b2 ) {\n\n\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n}\n\n// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/\nfunction inverseLerp( x, y, value ) {\n\n\tif ( x !== y ) {\n\n\t\treturn ( value - x ) / ( y - x );\n\n\t} else {\n\n\t\treturn 0;\n\n\t}\n\n}\n\n// https://en.wikipedia.org/wiki/Linear_interpolation\nfunction lerp( x, y, t ) {\n\n\treturn ( 1 - t ) * x + t * y;\n\n}\n\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\nfunction damp( x, y, lambda, dt ) {\n\n\treturn lerp( x, y, 1 - Math.exp( - lambda * dt ) );\n\n}\n\n// https://www.desmos.com/calculator/vcsjnyz7x4\nfunction pingpong( x, length = 1 ) {\n\n\treturn length - Math.abs( euclideanModulo( x, length * 2 ) - length );\n\n}\n\n// http://en.wikipedia.org/wiki/Smoothstep\nfunction smoothstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * ( 3 - 2 * x );\n\n}\n\nfunction smootherstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n}\n\n// Random integer from <low, high> interval\nfunction randInt( low, high ) {\n\n\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n}\n\n// Random float from <low, high> interval\nfunction randFloat( low, high ) {\n\n\treturn low + Math.random() * ( high - low );\n\n}\n\n// Random float from <-range/2, range/2> interval\nfunction randFloatSpread( range ) {\n\n\treturn range * ( 0.5 - Math.random() );\n\n}\n\n// Deterministic pseudo-random float in the interval [ 0, 1 ]\nfunction seededRandom( s ) {\n\n\tif ( s !== undefined ) _seed = s;\n\n\t// Mulberry32 generator\n\n\tlet t = _seed += 0x6D2B79F5;\n\n\tt = Math.imul( t ^ t >>> 15, t | 1 );\n\n\tt ^= t + Math.imul( t ^ t >>> 7, t | 61 );\n\n\treturn ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;\n\n}\n\nfunction degToRad( degrees ) {\n\n\treturn degrees * DEG2RAD;\n\n}\n\nfunction radToDeg( radians ) {\n\n\treturn radians * RAD2DEG;\n\n}\n\nfunction isPowerOfTwo( value ) {\n\n\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n}\n\nfunction ceilPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction floorPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction setQuaternionFromProperEuler( q, a, b, c, order ) {\n\n\t// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\n\n\t// rotations are applied to the axes in the order specified by 'order'\n\t// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'\n\t// angles are in radians\n\n\tconst cos = Math.cos;\n\tconst sin = Math.sin;\n\n\tconst c2 = cos( b / 2 );\n\tconst s2 = sin( b / 2 );\n\n\tconst c13 = cos( ( a + c ) / 2 );\n\tconst s13 = sin( ( a + c ) / 2 );\n\n\tconst c1_3 = cos( ( a - c ) / 2 );\n\tconst s1_3 = sin( ( a - c ) / 2 );\n\n\tconst c3_1 = cos( ( c - a ) / 2 );\n\tconst s3_1 = sin( ( c - a ) / 2 );\n\n\tswitch ( order ) {\n\n\t\tcase 'XYX':\n\t\t\tq.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YZY':\n\t\t\tq.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZXZ':\n\t\t\tq.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'XZX':\n\t\t\tq.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YXY':\n\t\t\tq.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZYZ':\n\t\t\tq.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tconsole.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );\n\n\t}\n\n}\n\nfunction denormalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint32Array:\n\n\t\t\treturn value / 4294967295.0;\n\n\t\tcase Uint16Array:\n\n\t\t\treturn value / 65535.0;\n\n\t\tcase Uint8Array:\n\n\t\t\treturn value / 255.0;\n\n\t\tcase Int32Array:\n\n\t\t\treturn Math.max( value / 2147483647.0, - 1.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.max( value / 32767.0, - 1.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.max( value / 127.0, - 1.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\nfunction normalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint32Array:\n\n\t\t\treturn Math.round( value * 4294967295.0 );\n\n\t\tcase Uint16Array:\n\n\t\t\treturn Math.round( value * 65535.0 );\n\n\t\tcase Uint8Array:\n\n\t\t\treturn Math.round( value * 255.0 );\n\n\t\tcase Int32Array:\n\n\t\t\treturn Math.round( value * 2147483647.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.round( value * 32767.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.round( value * 127.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\nconst MathUtils = {\n\tDEG2RAD: DEG2RAD,\n\tRAD2DEG: RAD2DEG,\n\tgenerateUUID: generateUUID,\n\tclamp: clamp,\n\teuclideanModulo: euclideanModulo,\n\tmapLinear: mapLinear,\n\tinverseLerp: inverseLerp,\n\tlerp: lerp,\n\tdamp: damp,\n\tpingpong: pingpong,\n\tsmoothstep: smoothstep,\n\tsmootherstep: smootherstep,\n\trandInt: randInt,\n\trandFloat: randFloat,\n\trandFloatSpread: randFloatSpread,\n\tseededRandom: seededRandom,\n\tdegToRad: degToRad,\n\tradToDeg: radToDeg,\n\tisPowerOfTwo: isPowerOfTwo,\n\tceilPowerOfTwo: ceilPowerOfTwo,\n\tfloorPowerOfTwo: floorPowerOfTwo,\n\tsetQuaternionFromProperEuler: setQuaternionFromProperEuler,\n\tnormalize: normalize,\n\tdenormalize: denormalize\n};\n\nexport {\n\tDEG2RAD,\n\tRAD2DEG,\n\tgenerateUUID,\n\tclamp,\n\teuclideanModulo,\n\tmapLinear,\n\tinverseLerp,\n\tlerp,\n\tdamp,\n\tpingpong,\n\tsmoothstep,\n\tsmootherstep,\n\trandInt,\n\trandFloat,\n\trandFloatSpread,\n\tseededRandom,\n\tdegToRad,\n\tradToDeg,\n\tisPowerOfTwo,\n\tceilPowerOfTwo,\n\tfloorPowerOfTwo,\n\tsetQuaternionFromProperEuler,\n\tnormalize,\n\tdenormalize,\n\tMathUtils\n};\n","import * as MathUtils from './MathUtils.js';\n\nclass Vector2 {\n\n\tconstructor( x = 0, y = 0 ) {\n\n\t\tVector2.prototype.isVector2 = true;\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t}\n\n\tget width() {\n\n\t\treturn this.x;\n\n\t}\n\n\tset width( value ) {\n\n\t\tthis.x = value;\n\n\t}\n\n\tget height() {\n\n\t\treturn this.y;\n\n\t}\n\n\tset height( value ) {\n\n\t\tthis.y = value;\n\n\t}\n\n\tset( x, y ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y );\n\n\t}\n\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\n\t\treturn this;\n\n\t}\n\n\tadd( v ) {\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\n\t\treturn this;\n\n\t}\n\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\n\t\treturn this;\n\n\t}\n\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( v ) {\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\n\t\treturn this;\n\n\t}\n\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\tdivide( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tconst x = this.x, y = this.y;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];\n\n\t\treturn this;\n\n\t}\n\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\n\t\treturn this;\n\n\t}\n\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\n\t\treturn this;\n\n\t}\n\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = Math.max( minVal, Math.min( maxVal, this.x ) );\n\t\tthis.y = Math.max( minVal, Math.min( maxVal, this.y ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\n\t}\n\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\n\t\treturn this;\n\n\t}\n\n\troundToZero() {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y;\n\n\t}\n\n\tcross( v ) {\n\n\t\treturn this.x * v.y - this.y * v.x;\n\n\t}\n\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\n\t}\n\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\n\t}\n\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\tangle() {\n\n\t\t// computes the angle in radians with respect to the positive x-axis\n\n\t\tconst angle = Math.atan2( - this.y, - this.x ) + Math.PI;\n\n\t\treturn angle;\n\n\t}\n\n\tangleTo( v ) {\n\n\t\tconst denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );\n\n\t\tif ( denominator === 0 ) return Math.PI / 2;\n\n\t\tconst theta = this.dot( v ) / denominator;\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( MathUtils.clamp( theta, - 1, 1 ) );\n\n\t}\n\n\tdistanceTo( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t}\n\n\tdistanceToSquared( v ) {\n\n\t\tconst dx = this.x - v.x, dy = this.y - v.y;\n\t\treturn dx * dx + dy * dy;\n\n\t}\n\n\tmanhattanDistanceTo( v ) {\n\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\n\n\t}\n\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\n\t\treturn this;\n\n\t}\n\n\trotateAround( center, angle ) {\n\n\t\tconst c = Math.cos( angle ), s = Math.sin( angle );\n\n\t\tconst x = this.x - center.x;\n\t\tconst y = this.y - center.y;\n\n\t\tthis.x = x * c - y * s + center.x;\n\t\tthis.y = x * s + y * c + center.y;\n\n\t\treturn this;\n\n\t}\n\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\n\t\treturn this;\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.x;\n\t\tyield this.y;\n\n\t}\n\n}\n\nexport { Vector2 };\n","class Matrix3 {\n\n\tconstructor( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\tMatrix3.prototype.isMatrix3 = true;\n\n\t\tthis.elements = [\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t];\n\n\t\tif ( n11 !== undefined ) {\n\n\t\t\tthis.set( n11, n12, n13, n21, n22, n23, n31, n32, n33 );\n\n\t\t}\n\n\t}\n\n\tset( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\n\t\treturn this;\n\n\t}\n\n\tidentity() {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tcopy( m ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];\n\t\tte[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];\n\t\tte[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];\n\n\t\treturn this;\n\n\t}\n\n\textractBasis( xAxis, yAxis, zAxis ) {\n\n\t\txAxis.setFromMatrix3Column( this, 0 );\n\t\tyAxis.setFromMatrix3Column( this, 1 );\n\t\tzAxis.setFromMatrix3Column( this, 2 );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrix4( m ) {\n\n\t\tconst me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 4 ], me[ 8 ],\n\t\t\tme[ 1 ], me[ 5 ], me[ 9 ],\n\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( m ) {\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t}\n\n\tpremultiply( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t}\n\n\tmultiplyMatrices( a, b ) {\n\n\t\tconst ae = a.elements;\n\t\tconst be = b.elements;\n\t\tconst te = this.elements;\n\n\t\tconst a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];\n\t\tconst a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];\n\t\tconst a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];\n\n\t\tconst b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];\n\t\tconst b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];\n\t\tconst b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;\n\t\tte[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;\n\t\tte[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;\n\t\tte[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;\n\t\tte[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;\n\t\tte[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;\n\t\tte[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( s ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\n\t\treturn this;\n\n\t}\n\n\tdeterminant() {\n\n\t\tconst te = this.elements;\n\n\t\tconst a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\n\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\n\t}\n\n\tinvert() {\n\n\t\tconst te = this.elements,\n\n\t\t\tn11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],\n\t\t\tn12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],\n\t\t\tn13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],\n\n\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\tt13 = n23 * n12 - n22 * n13,\n\n\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\n\t\tif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n\n\t\tconst detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\n\t\tte[ 3 ] = t12 * detInv;\n\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\n\t\tte[ 6 ] = t13 * detInv;\n\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\n\t\treturn this;\n\n\t}\n\n\ttranspose() {\n\n\t\tlet tmp;\n\t\tconst m = this.elements;\n\n\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\n\t\treturn this;\n\n\t}\n\n\tgetNormalMatrix( matrix4 ) {\n\n\t\treturn this.setFromMatrix4( matrix4 ).invert().transpose();\n\n\t}\n\n\ttransposeIntoArray( r ) {\n\n\t\tconst m = this.elements;\n\n\t\tr[ 0 ] = m[ 0 ];\n\t\tr[ 1 ] = m[ 3 ];\n\t\tr[ 2 ] = m[ 6 ];\n\t\tr[ 3 ] = m[ 1 ];\n\t\tr[ 4 ] = m[ 4 ];\n\t\tr[ 5 ] = m[ 7 ];\n\t\tr[ 6 ] = m[ 2 ];\n\t\tr[ 7 ] = m[ 5 ];\n\t\tr[ 8 ] = m[ 8 ];\n\n\t\treturn this;\n\n\t}\n\n\tsetUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {\n\n\t\tconst c = Math.cos( rotation );\n\t\tconst s = Math.sin( rotation );\n\n\t\tthis.set(\n\t\t\tsx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,\n\t\t\t- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,\n\t\t\t0, 0, 1\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\t//\n\n\tscale( sx, sy ) {\n\n\t\tthis.premultiply( _m3.makeScale( sx, sy ) );\n\n\t\treturn this;\n\n\t}\n\n\trotate( theta ) {\n\n\t\tthis.premultiply( _m3.makeRotation( - theta ) );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( tx, ty ) {\n\n\t\tthis.premultiply( _m3.makeTranslation( tx, ty ) );\n\n\t\treturn this;\n\n\t}\n\n\t// for 2D Transforms\n\n\tmakeTranslation( x, y ) {\n\n\t\tif ( x.isVector2 ) {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, x.x,\n\t\t\t\t0, 1, x.y,\n\t\t\t\t0, 0, 1\n\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, x,\n\t\t\t\t0, 1, y,\n\t\t\t\t0, 0, 1\n\n\t\t\t);\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotation( theta ) {\n\n\t\t// counterclockwise\n\n\t\tconst c = Math.cos( theta );\n\t\tconst s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\tc, - s, 0,\n\t\t\ts, c, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeScale( x, y ) {\n\n\t\tthis.set(\n\n\t\t\tx, 0, 0,\n\t\t\t0, y, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\t//\n\n\tequals( matrix ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = matrix.elements;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tconst te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\tarray[ offset + 8 ] = te[ 8 ];\n\n\t\treturn array;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().fromArray( this.elements );\n\n\t}\n\n}\n\nconst _m3 = /*@__PURE__*/ new Matrix3();\n\nexport { Matrix3 };\n","import { SRGBColorSpace, LinearSRGBColorSpace, DisplayP3ColorSpace, } from '../constants.js';\nimport { Matrix3 } from './Matrix3.js';\n\nexport function SRGBToLinear( c ) {\n\n\treturn ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n\n}\n\nexport function LinearToSRGB( c ) {\n\n\treturn ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;\n\n}\n\n/**\n * Matrices converting P3 <-> Rec. 709 primaries, without gamut mapping\n * or clipping. Based on W3C specifications for sRGB and Display P3,\n * and ICC specifications for the D50 connection space. Values in/out\n * are _linear_ sRGB and _linear_ Display P3.\n *\n * Note that both sRGB and Display P3 use the sRGB transfer functions.\n *\n * Reference:\n * - http://www.russellcottrell.com/photo/matrixCalculator.htm\n */\n\nconst LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = /*@__PURE__*/ new Matrix3().fromArray( [\n\t0.8224621, 0.0331941, 0.0170827,\n\t0.1775380, 0.9668058, 0.0723974,\n\t- 0.0000001, 0.0000001, 0.9105199\n] );\n\nconst LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = /*@__PURE__*/ new Matrix3().fromArray( [\n\t1.2249401, - 0.0420569, - 0.0196376,\n\t- 0.2249404, 1.0420571, - 0.0786361,\n\t0.0000001, 0.0000000, 1.0982735\n] );\n\nfunction DisplayP3ToLinearSRGB( color ) {\n\n\t// Display P3 uses the sRGB transfer functions\n\treturn color.convertSRGBToLinear().applyMatrix3( LINEAR_DISPLAY_P3_TO_LINEAR_SRGB );\n\n}\n\nfunction LinearSRGBToDisplayP3( color ) {\n\n\t// Display P3 uses the sRGB transfer functions\n\treturn color.applyMatrix3( LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 ).convertLinearToSRGB();\n\n}\n\n// Conversions from <source> to Linear-sRGB reference space.\nconst TO_LINEAR = {\n\t[ LinearSRGBColorSpace ]: ( color ) => color,\n\t[ SRGBColorSpace ]: ( color ) => color.convertSRGBToLinear(),\n\t[ DisplayP3ColorSpace ]: DisplayP3ToLinearSRGB,\n};\n\n// Conversions to <target> from Linear-sRGB reference space.\nconst FROM_LINEAR = {\n\t[ LinearSRGBColorSpace ]: ( color ) => color,\n\t[ SRGBColorSpace ]: ( color ) => color.convertLinearToSRGB(),\n\t[ DisplayP3ColorSpace ]: LinearSRGBToDisplayP3,\n};\n\nexport const ColorManagement = {\n\n\tenabled: true,\n\n\tget legacyMode() {\n\n\t\tconsole.warn( 'THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.' );\n\n\t\treturn ! this.enabled;\n\n\t},\n\n\tset legacyMode( legacyMode ) {\n\n\t\tconsole.warn( 'THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.' );\n\n\t\tthis.enabled = ! legacyMode;\n\n\t},\n\n\tget workingColorSpace() {\n\n\t\treturn LinearSRGBColorSpace;\n\n\t},\n\n\tset workingColorSpace( colorSpace ) {\n\n\t\tconsole.warn( 'THREE.ColorManagement: .workingColorSpace is readonly.' );\n\n\t},\n\n\tconvert: function ( color, sourceColorSpace, targetColorSpace ) {\n\n\t\tif ( this.enabled === false || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) {\n\n\t\t\treturn color;\n\n\t\t}\n\n\t\tconst sourceToLinear = TO_LINEAR[ sourceColorSpace ];\n\t\tconst targetFromLinear = FROM_LINEAR[ targetColorSpace ];\n\n\t\tif ( sourceToLinear === undefined || targetFromLinear === undefined ) {\n\n\t\t\tthrow new Error( `Unsupported color space conversion, \"${ sourceColorSpace }\" to \"${ targetColorSpace }\".` );\n\n\t\t}\n\n\t\treturn targetFromLinear( sourceToLinear( color ) );\n\n\t},\n\n\tfromWorkingColorSpace: function ( color, targetColorSpace ) {\n\n\t\treturn this.convert( color, this.workingColorSpace, targetColorSpace );\n\n\t},\n\n\ttoWorkingColorSpace: function ( color, sourceColorSpace ) {\n\n\t\treturn this.convert( color, sourceColorSpace, this.workingColorSpace );\n\n\t},\n\n};\n","import { createElementNS } from '../utils.js';\nimport { SRGBToLinear } from '../math/ColorManagement.js';\n\nlet _canvas;\n\nclass ImageUtils {\n\n\tstatic getDataURL( image ) {\n\n\t\tif ( /^data:/i.test( image.src ) ) {\n\n\t\t\treturn image.src;\n\n\t\t}\n\n\t\tif ( typeof HTMLCanvasElement === 'undefined' ) {\n\n\t\t\treturn image.src;\n\n\t\t}\n\n\t\tlet canvas;\n\n\t\tif ( image instanceof HTMLCanvasElement ) {\n\n\t\t\tcanvas = image;\n\n\t\t} else {\n\n\t\t\tif ( _canvas === undefined ) _canvas = createElementNS( 'canvas' );\n\n\t\t\t_canvas.width = image.width;\n\t\t\t_canvas.height = image.height;\n\n\t\t\tconst context = _canvas.getContext( '2d' );\n\n\t\t\tif ( image instanceof ImageData ) {\n\n\t\t\t\tcontext.putImageData( image, 0, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\t}\n\n\t\t\tcanvas = _canvas;\n\n\t\t}\n\n\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\n\n\t\t\tconsole.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );\n\n\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\n\n\t\t} else {\n\n\t\t\treturn canvas.toDataURL( 'image/png' );\n\n\t\t}\n\n\t}\n\n\tstatic sRGBToLinear( image ) {\n\n\t\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {\n\n\t\t\tconst canvas = createElementNS( 'canvas' );\n\n\t\t\tcanvas.width = image.width;\n\t\t\tcanvas.height = image.height;\n\n\t\t\tconst context = canvas.getContext( '2d' );\n\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\tconst imageData = context.getImageData( 0, 0, image.width, image.height );\n\t\t\tconst data = imageData.data;\n\n\t\t\tfor ( let i = 0; i < data.length; i ++ ) {\n\n\t\t\t\tdata[ i ] = SRGBToLinear( data[ i ] / 255 ) * 255;\n\n\t\t\t}\n\n\t\t\tcontext.putImageData( imageData, 0, 0 );\n\n\t\t\treturn canvas;\n\n\t\t} else if ( image.data ) {\n\n\t\t\tconst data = image.data.slice( 0 );\n\n\t\t\tfor ( let i = 0; i < data.length; i ++ ) {\n\n\t\t\t\tif ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) {\n\n\t\t\t\t\tdata[ i ] = Math.floor( SRGBToLinear( data[ i ] / 255 ) * 255 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// assuming float\n\n\t\t\t\t\tdata[ i ] = SRGBToLinear( data[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tdata: data,\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' );\n\t\t\treturn image;\n\n\t\t}\n\n\t}\n\n}\n\nexport { ImageUtils };\n","import { ImageUtils } from '../extras/ImageUtils.js';\nimport * as MathUtils from '../math/MathUtils.js';\n\nlet sourceId = 0;\n\nclass Source {\n\n\tconstructor( data = null ) {\n\n\t\tthis.isSource = true;\n\n\t\tObject.defineProperty( this, 'id', { value: sourceId ++ } );\n\n\t\tthis.uuid = MathUtils.generateUUID();\n\n\t\tthis.data = data;\n\n\t\tthis.version = 0;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( ! isRootObject && meta.images[ this.uuid ] !== undefined ) {\n\n\t\t\treturn meta.images[ this.uuid ];\n\n\t\t}\n\n\t\tconst output = {\n\t\t\tuuid: this.uuid,\n\t\t\turl: ''\n\t\t};\n\n\t\tconst data = this.data;\n\n\t\tif ( data !== null ) {\n\n\t\t\tlet url;\n\n\t\t\tif ( Array.isArray( data ) ) {\n\n\t\t\t\t// cube texture\n\n\t\t\t\turl = [];\n\n\t\t\t\tfor ( let i = 0, l = data.length; i < l; i ++ ) {\n\n\t\t\t\t\tif ( data[ i ].isDataTexture ) {\n\n\t\t\t\t\t\turl.push( serializeImage( data[ i ].image ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\turl.push( serializeImage( data[ i ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// texture\n\n\t\t\t\turl = serializeImage( data );\n\n\t\t\t}\n\n\t\t\toutput.url = url;\n\n\t\t}\n\n\t\tif ( ! isRootObject ) {\n\n\t\t\tmeta.images[ this.uuid ] = output;\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\nfunction serializeImage( image ) {\n\n\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {\n\n\t\t// default images\n\n\t\treturn ImageUtils.getDataURL( image );\n\n\t} else {\n\n\t\tif ( image.data ) {\n\n\t\t\t// images of DataTexture\n\n\t\t\treturn {\n\t\t\t\tdata: Array.from( image.data ),\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height,\n\t\t\t\ttype: image.data.constructor.name\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Texture: Unable to serialize Texture.' );\n\t\t\treturn {};\n\n\t\t}\n\n\t}\n\n}\n\nexport { Source };\n","import { EventDispatcher } from '../core/EventDispatcher.js';\nimport {\n\tMirroredRepeatWrapping,\n\tClampToEdgeWrapping,\n\tRepeatWrapping,\n\tUnsignedByteType,\n\tRGBAFormat,\n\tLinearMipmapLinearFilter,\n\tLinearFilter,\n\tUVMapping,\n\tsRGBEncoding,\n\tSRGBColorSpace,\n\tNoColorSpace,\n\tLinearEncoding\n} from '../constants.js';\nimport * as MathUtils from '../math/MathUtils.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Matrix3 } from '../math/Matrix3.js';\nimport { Source } from './Source.js';\nimport { warnOnce } from '../utils.js';\n\nlet textureId = 0;\n\nclass Texture extends EventDispatcher {\n\n\tconstructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace ) {\n\n\t\tsuper();\n\n\t\tthis.isTexture = true;\n\n\t\tObject.defineProperty( this, 'id', { value: textureId ++ } );\n\n\t\tthis.uuid = MathUtils.generateUUID();\n\n\t\tthis.name = '';\n\n\t\tthis.source = new Source( image );\n\t\tthis.mipmaps = [];\n\n\t\tthis.mapping = mapping;\n\t\tthis.channel = 0;\n\n\t\tthis.wrapS = wrapS;\n\t\tthis.wrapT = wrapT;\n\n\t\tthis.magFilter = magFilter;\n\t\tthis.minFilter = minFilter;\n\n\t\tthis.anisotropy = anisotropy;\n\n\t\tthis.format = format;\n\t\tthis.internalFormat = null;\n\t\tthis.type = type;\n\n\t\tthis.offset = new Vector2( 0, 0 );\n\t\tthis.repeat = new Vector2( 1, 1 );\n\t\tthis.center = new Vector2( 0, 0 );\n\t\tthis.rotation = 0;\n\n\t\tthis.matrixAutoUpdate = true;\n\t\tthis.matrix = new Matrix3();\n\n\t\tthis.generateMipmaps = true;\n\t\tthis.premultiplyAlpha = false;\n\t\tthis.flipY = true;\n\t\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\t\tif ( typeof colorSpace === 'string' ) {\n\n\t\t\tthis.colorSpace = colorSpace;\n\n\t\t} else { // @deprecated, r152\n\n\t\t\twarnOnce( 'THREE.Texture: Property .encoding has been replaced by .colorSpace.' );\n\t\t\tthis.colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : NoColorSpace;\n\n\t\t}\n\n\n\t\tthis.userData = {};\n\n\t\tthis.version = 0;\n\t\tthis.onUpdate = null;\n\n\t\tthis.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not\n\t\tthis.needsPMREMUpdate = false; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)\n\n\t}\n\n\tget image() {\n\n\t\treturn this.source.data;\n\n\t}\n\n\tset image( value = null ) {\n\n\t\tthis.source.data = value;\n\n\t}\n\n\tupdateMatrix() {\n\n\t\tthis.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.source = source.source;\n\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\n\t\tthis.mapping = source.mapping;\n\t\tthis.channel = source.channel;\n\n\t\tthis.wrapS = source.wrapS;\n\t\tthis.wrapT = source.wrapT;\n\n\t\tthis.magFilter = source.magFilter;\n\t\tthis.minFilter = source.minFilter;\n\n\t\tthis.anisotropy = source.anisotropy;\n\n\t\tthis.format = source.format;\n\t\tthis.internalFormat = source.internalFormat;\n\t\tthis.type = source.type;\n\n\t\tthis.offset.copy( source.offset );\n\t\tthis.repeat.copy( source.repeat );\n\t\tthis.center.copy( source.center );\n\t\tthis.rotation = source.rotation;\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\tthis.matrix.copy( source.matrix );\n\n\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\tthis.flipY = source.flipY;\n\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\tthis.colorSpace = source.colorSpace;\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\tthis.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {\n\n\t\t\treturn meta.textures[ this.uuid ];\n\n\t\t}\n\n\t\tconst output = {\n\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Texture',\n\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t},\n\n\t\t\tuuid: this.uuid,\n\t\t\tname: this.name,\n\n\t\t\timage: this.source.toJSON( meta ).uuid,\n\n\t\t\tmapping: this.mapping,\n\t\t\tchannel: this.channel,\n\n\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\tcenter: [ this.center.x, this.center.y ],\n\t\t\trotation: this.rotation,\n\n\t\t\twrap: [ this.wrapS, this.wrapT ],\n\n\t\t\tformat: this.format,\n\t\t\tinternalFormat: this.internalFormat,\n\t\t\ttype: this.type,\n\t\t\tcolorSpace: this.colorSpace,\n\n\t\t\tminFilter: this.minFilter,\n\t\t\tmagFilter: this.magFilter,\n\t\t\tanisotropy: this.anisotropy,\n\n\t\t\tflipY: this.flipY,\n\n\t\t\tgenerateMipmaps: this.generateMipmaps,\n\t\t\tpremultiplyAlpha: this.premultiplyAlpha,\n\t\t\tunpackAlignment: this.unpackAlignment\n\n\t\t};\n\n\t\tif ( Object.keys( this.userData ).length > 0 ) output.userData = this.userData;\n\n\t\tif ( ! isRootObject ) {\n\n\t\t\tmeta.textures[ this.uuid ] = output;\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\ttransformUv( uv ) {\n\n\t\tif ( this.mapping !== UVMapping ) return uv;\n\n\t\tuv.applyMatrix3( this.matrix );\n\n\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\n\t\t\tswitch ( this.wrapS ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\n\t\t\tswitch ( this.wrapT ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.flipY ) {\n\n\t\t\tuv.y = 1 - uv.y;\n\n\t\t}\n\n\t\treturn uv;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.version ++;\n\t\t\tthis.source.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tget encoding() { // @deprecated, r152\n\n\t\twarnOnce( 'THREE.Texture: Property .encoding has been replaced by .colorSpace.' );\n\t\treturn this.colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\n\n\t}\n\n\tset encoding( encoding ) { // @deprecated, r152\n\n\t\twarnOnce( 'THREE.Texture: Property .encoding has been replaced by .colorSpace.' );\n\t\tthis.colorSpace = encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace;\n\n\t}\n\n}\n\nTexture.DEFAULT_IMAGE = null;\nTexture.DEFAULT_MAPPING = UVMapping;\nTexture.DEFAULT_ANISOTROPY = 1;\n\nexport { Texture };\n","import { ImageLoader } from './ImageLoader.js';\nimport { Texture } from '../textures/Texture.js';\nimport { Loader } from './Loader.js';\n\nclass TextureLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst texture = new Texture();\n\n\t\tconst loader = new ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tloader.load( url, function ( image ) {\n\n\t\t\ttexture.image = image;\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\tonLoad( texture );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\treturn texture;\n\n\t}\n\n}\n\n\nexport { TextureLoader };\n"],"names":["ADDITION","SUBTRACTION","REVERSE_SUBTRACTION","INTERSECTION","DIFFERENCE","HOLLOW_SUBTRACTION","HOLLOW_INTERSECTION","CENTER","AVERAGE","SAH","CONTAINED","TRIANGLE_INTERSECT_COST","TRAVERSAL_COST","IS_LEAFNODE_FLAG","FLOAT32_EPSILON","Math","pow","SKIP_GENERATION","Symbol","getTriCount","geo","index","count","attributes","position","getVertexCount","ensureIndex","options","vertexCount","BufferConstructor","arguments","length","undefined","ArrayBuffer","Uint32Array","Uint16Array","getIndexArray","useSharedArrayBuffer","SharedArrayBuffer","setIndex","BufferAttribute","i","getFullGeometryRange","triCount","drawRange","start","end","offset","max","min","floor","getRootIndexRanges","groups","ranges","rangeBoundaries","Set","drawRangeStart","drawRangeEnd","group","groupStart","groupEnd","add","sortedBoundaries","Array","from","values","sort","a","b","push","arrayToBox","nodeIndex32","array","target","x","y","z","getLongestEdgeIndex","bounds","splitDimIdx","splitDist","Infinity","dist","copyBounds","source","set","unionBounds","aVal","bVal","d","d3","expandByTriangleBounds","startIndex","triangleBounds","tCenter","tHalf","tMin","tMax","computeSurfaceArea","d0","d1","d2","getBounds","centroidTarget","minx","miny","minz","maxx","maxy","maxz","cminx","cminy","cminz","cmaxx","cmaxy","cmaxz","includeCentroid","cx","hx","lx","rx","cy","hy","ly","ry","cz","hz","lz","rz","BIN_COUNT","binsSort","candidate","sahBins","fill","map","Float32Array","rightCacheBounds","leftCacheBounds","leftBounds","MeshBVHNode","constructor","partition","indirectBuffer","split","left","right","pos","axisOffset","axis","t0","tb","partition_indirect","t","buildTree","bvh","geometry","indexArray","maxDepth","verbose","maxLeafTris","strategy","onProgress","totalTriangles","_indirectBuffer","reachedMaxDepth","fullBounds","cacheCentroidBoundingData","posAttr","normalized","posArr","bufferOffset","stride","isInterleavedBufferAttribute","data","getters","tri","tri3","tri6","ai","bi","ci","el","c","halfExtents","el2","abs","computeTriangleBounds","partionFunc","indirect","roots","range","root","boundingData","getCentroidBounds","splitNode","triggerProgress","trianglesProcessed","node","centroidBoundingData","depth","console","warn","concat","nodeBoundingData","avg","getAverage","rootSurfaceArea","bestCost","cStart","cEnd","axisLeft","binWidth","truncatedBins","bin","splitCount","splice","center","leftCount","rightCount","rightBounds","leftProb","rightProb","cost","binIndex","lastBin","nextBin","binCount","getOptimalSplit","splitOffset","splitAxis","lstart","lcount","rstart","rcount","buildPackedTree","useUint32","byteCount","buffer","l","generateIndirectBuffer","finalGroup","total","forEach","_ref","hasGroupGaps","float32Array","uint32Array","uint16Array","packedRoots","countNodes","populateBuffer","_roots","byteOffset","stride4Offset","stride2Offset","isLeaf","nextUnusedPointer","Error","SeparatingAxisBounds","this","setFromPointsField","points","field","val","setFromPoints","p","dot","isSeparated","other","prototype","setFromBox","Vector3","box","boxMin","boxMax","cacheSatBounds","closestPointLineToLine","dir1","dir2","v02","l1","l2","result","v0","v10","v2","v32","subVectors","d0232","d3210","d3232","d0210","denom","closestPointsSegmentToSegment","paramResult","Vector2","temp1","temp2","target1","target2","at","closestPointToPoint","p2","closestPoint","closestPoint2","distanceToSquared","copy","sphereIntersectTriangle","closestPointTemp","projectedPointTemp","planeTemp","Plane","lineTemp","Line3","sphere","triangle","radius","distanceTo","plane","getPlane","distanceToPoint","pp","projectPoint","containsPoint","isNearZero","value","ExtendedTriangle","Triangle","super","isExtendedTriangle","satAxes","satBounds","Sphere","needsUpdate","intersectsSphere","update","axis0","sab0","getNormal","axis1","sab1","axis2","sab2","axis3","sab3","setFromNormalAndCoplanarPoint","closestPointToSegment","point1","point2","edge","segment","distSq","closestDistanceSq","nexti","sqrt","intersectsTriangle","saTri2","arr1","arr2","cachedSatBounds","cachedSatBounds2","cachedAxis","dir","tempDir","edge1","edge2","tempPoint","triIntersectPlane","targetEdge","startPointIntersection","delta","startIntersects","normal","doesIntersect","intersectLine","suppressLog","plane1","plane2","satBounds1","satAxes1","sb","sa","satBounds2","satAxes2","sa1","i2","sa2","crossVectors","count1","count2","tmp","s1","e1","s2","e2","point","distanceToTriangle","cornerFields","line1","line2","lineTarget","getCenter","otherVec","thisVec","f11","f12","f21","f22","OrientedBox","matrix","isOrientedBox","Matrix4","invMatrix","alignedSatBounds","v","applyMatrix4","minVec","pi","invert","intersectsBox","aabbBounds","saTri","pointsArr","triSatBounds","triSatAxes","clamp","distanceToBox","xyzFields","segments1","segments2","threshold","threshold2","i1","nextIndex","nextIndex2","index2","p1","f1","f2","f3","PrimitivePool","getNewPrimitive","_getNewPrimitive","_primitives","getPrimitive","primitives","pop","releasePrimitive","primitive","ExtendedTrianglePoolBase","ExtendedTrianglePool","IS_LEAF","n16","OFFSET","n32","COUNT","LEFT_NODE","RIGHT_NODE","SPLIT_AXIS","BufferStack","stack","prevBuffer","setBuffer","clearBuffer","_box1","_box2","boxStack","boxPool","Box3","shapecast","intersectsBounds","intersectsRange","boundsTraverseOrder","shapecastTraverse","intersectsBoundsFunc","intersectsRangeFunc","nodeScoreFunc","nodeIndexByteOffset","nodeIndex16","score1","score2","box1","box2","c1","c2","temp","c1Intersection","c1StopTraversal","getLeftOffset","getRightEndOffset","c2Intersection","c2StopTraversal","_vA","_vB","_vC","_uvA","_uvB","_uvC","_normalA","_normalB","_normalC","_intersectionPoint","checkBufferGeometryIntersection","ray","uv","uv1","side","fromBufferAttribute","intersection","pA","pB","pC","intersect","BackSide","intersectTriangle","DoubleSide","distance","origin","clone","checkIntersection","getInterpolation","direction","multiplyScalar","face","materialIndex","faceIndex","intersectTri","intersections","triOffset","getX","setTriangle","ta","tc","i0","getY","getZ","iterateOverTriangles","intersectsTriangleFunc","contained","refit","nodeIndices","isArray","indexArr","_traverse","byteLength","node32Index","force","node16Index","offsetLeft","offsetRight","forceChildren","includesLeft","includesRight","has","traverseRight","leftChange","rightChange","didChange","lefti","righti","minLeftValue","maxLeftValue","minRightValue","maxRightValue","_boundingBox","intersectRay","intersectBox","_boxIntersection","raycast","intersects","_raycast","intersectTris","leftIndex","rightIndex","_xyzFields","raycastFirst","_raycastFirst","res","intersectClosestTri","xyzAxis","leftToRight","c1Result","c2Result","boundingBox","triangle2","invertedMat","obb","obb2","intersectsGeometry","otherGeometry","geometryToBvh","_intersectsGeometry","cachedObb","computeBoundingBox","thisGeometry","thisIndex","thisPos","boundsTree","tempMatrix","temp3","temp4","closestPointToGeometry","minThreshold","maxThreshold","otherPos","otherIndex","tempTarget1","tempTargetDest1","tempTarget2","tempTargetDest2","closestDistance","closestDistanceTriIndex","closestDistanceOtherTriIndex","score","otherOffset","otherCount","sub","iterateOverTriangles_indirect","resolveTriangleIndex","refit_indirect","j","raycast_indirect","intersectTris_indirect","raycastFirst_indirect","intersectClosestTri_indirect","intersectsGeometry_indirect","ti","closestPointToGeometry_indirect","otherBvh","ti2","_bufferStack1","_bufferStack2","_boxPool","_leftBox1","_rightBox1","_leftBox2","_rightBox2","_active","node1Index32","node2Index32","matrix2to1","matrix1to2","intersectsRangesFunc","bufferStack1","bufferStack2","node1IndexByteOffset","node2IndexByteOffset","depth1","depth2","currBox","reversed","float32Array1","uint32Array1","uint16Array1","float32Array2","uint32Array2","uint16Array2","node2Index16","isLeaf1","isLeaf2","newBox","cl1","cr1","intersectCl1","intersectCr1","cl2","cr2","leftIntersects","rightIntersects","tempBox","MeshBVH","serialize","cloneBuffers","rootData","indexAttribute","getIndex","slice","deserialize","Boolean","newIndex","isBufferGeometry","Object","assign","setBoundingBox","getBoundingBox","traverse","callback","rootIndex","BYTES_PER_NODE","materialOrSide","FrontSide","isMaterial","isArrayMaterial","raycastFunc","materialSide","startCount","jl","closestResult","raycastFirstFunc","geomToMesh","intersectsGeometryFunc","callbacks","iterateFunc","originalIntersectsRange","nodeIndex","bvhcast","matrixToLocal","intersectsRanges","intersectsTriangles","triangle1","indexAttr1","positionAttr1","assignTriangle1","indexAttr2","positionAttr2","assignTriangle2","iterateOverDoubleTriangles","offset1","offset2","index1","originalIntersectsRanges","otherRoots","invMat","il","localBox","boxToMesh","minThresholdSq","maxThresholdSq","triIndex","makeEmpty","union","HASH_WIDTH","HASH_MULTIPLIER","log10","HASH_ADDITION","hashNumber","hashVertex3","hashVertex4","w","toNormalizedRay","v1","normalize","scalar","addScaledVector","areSharedArrayBuffersSupported","convertToSharedArrayBuffer","cons","sharedBuffer","uintArray","Uint8Array","DEGENERATE_EPSILON","_tempVec","toEdgeIndex","sortEdgeFunc","getProjectedDistance","vec","DIST_EPSILON","ANGLE_EPSILON","RaySet","_rays","addRay","findClosestRay","rays","inv","bestScore","bestRay","r","skipRay","rayScore","scoreRays","invScore","r0","r1","distOutOfThreshold","angleTo","originDistance","angleDistance","_v0","_v1","_ray","Ray","computeDisjointEdges","unmatchedSet","eps","indexAttr","disjointConnectivityMap","Map","fragmentMap","edges","edgeIndex","info","commonRay","forward","reverse","get","e0","o","areDistancesDegenerate","isEdgeDegenerate","cleanUpEdgeSet","arr","e","matchEdges","delete","_vec2","_vec3","_vec4","Vector4","_hashes","HalfEdgeMap","disjointConnections","unmatchedDisjointEdges","unmatchedEdges","matchedEdges","useDrawRange","useAllAttributes","matchDisjointEdges","degenerateEpsilon","updateFrom","getSiblingTriangleIndex","getSiblingEdgeIndex","getDisjointSiblingTriangleIndices","getDisjointSiblingEdgeIndices","isFullyConnected","hashFunction","k","attrKeys","attr","str","itemSize","keys","maxTriCount","Int32Array","i3","nextE","vh0","vh1","reverseHash","hash","clear","_ref2","_ref3","size","Brush","Mesh","isBrush","_previousMatrix","elements","markUpdated","isDirty","el1","prepareGeometry","key","attribute","halfEdges","groupIndices","g","lg","disposeCacheData","EPSILON","_AB","_AC","_CB","isTriDegenerate","angle1","angle2","angle3","PI","COPLANAR_EPSILON","_edge","_foundEdge","_vec","_triangleNormal","_planeNormal","_plane","_splittingTriangle","TrianglePool","_pool","_index","getTriangle","reset","TriangleSplitter","trianglePool","triangles","coplanarTriangleUsed","initialize","poolTri","splitByTriangle","coplanarCount","splitByPlane","clippingTriangle","vertexSplitEnd","coplanarEdge","posSideVerts","negSideVerts","tNext","startDist","endDist","didIntersect","otherVert1","otherVert2","nextTri","singleVert","nextVert1","nextVert2","nextTri1","nextTri2","TypeBackedArray","type","initialSize","expansionFactor","setSize","setType","newArray","BYTES_PER_ELEMENT","expand","TypedAttributeData","groupAttributes","groupCount","getType","name","getItemSize","getNormalized","getCount","getGroupAttrArray","getTotalLength","getGroupAttrSet","refAttrSet","newAttrSet","refAttr","newAttr","initializeArray","referenceAttr","attrSet","IntersectionMap","intersectionSet","ids","id","intersectionId","_matrix","_tri","_vec4a","_vec4b","_vec4c","_vec4_0","_vec4_1","_vec4_2","_normal","JITTER_EPSILON","OFFSET_EPSILON","BACK_SIDE","FRONT_SIDE","COPLANAR_OPPOSITE","COPLANAR_ALIGNED","INVERT_TRI","ADD_TRI","SKIP_TRI","FLOATING_COPLANAR_EPSILON","_debugContext","setDebugContext","debugData","getHitSide","getMidpoint","hit","getHitSideWithCoplanarCheck","rand","random","minDistance","appendAttributeFromTriangle","baryCoordTri","matrixWorld","normalMatrix","attributeData","pushBarycoordInterpolatedValues","applyNormalMatrix","appendAttributesFromIndices","appendAttributeFromIndex","getOperationAction","operation","hitSide","attrArr","addValues","getW","TriangleIntersectData","addTriangle","getIntersectArray","TriangleIntersectionSets","addTriangleIntersection","ia","triA","ib","triB","getTrianglesAsArray","getTriangleIndices","parseInt","getIntersectionIndices","getIntersectionsAsArray","id2","triSet","addTriangles","key2","OperationDebugData","enabled","triangleIntersectsA","triangleIntersectsB","intersectionEdges","addIntersectingTriangles","addEdge","init","complete","_normalMatrix","Matrix3","_triA","_triB","_barycoordTri","_attr","_actions","getFirstIdFromSet","performOperation","operations","splitter","useGroups","aIntersections","bIntersections","multiply","triangleA","triangleB","intersected","pa","pb","na","nb","constant","va","vb","collectIntersectingTriangles","groupOffset","performSplitTriangleOperations","performWholeTriangleOperations","findIndex","op","materials","intersectionMap","invertedGeometry","determinant","getNormalMatrix","aIndex","aPosition","bBVH","bIndex","bPosition","splitIds","groupIndex","ia3","ia0","ia1","ia2","intersectingIndices","ib3","ib0","ib1","ib2","clippedTri","lo","getBarycoord","lk","invertTri","splitTriSet","aAttributes","traverseSet","currId","sid","action","getMaterialList","Evaluator","triangleSplitter","consolidateGroups","debug","getGroupRanges","evaluate","targetBrushes","wasArray","brush","referenceGeometry","targetGeometry","relevantAttributes","aAttr","includes","deleteAttribute","dispose","prepareAttributesData","aGroups","aMaterials","material","bGroups","bMaterials","allMaterials","mat","indexOf","finalMaterials","foundGroup","groupOrder","needsDisposal","referenceAttrSet","requiredLength","geoAttr","setAttribute","trimmedArray","clearGroups","vertCount","addGroup","setDrawRange","assignBufferData","nextGroup","joinGroups","evaluateHierarchy","updateMatrixWorld","flatTraverse","obj","cb","children","child","isOperationGroup","_cachedGeometry","_cachedMaterials","TYPES","subtraction","reverseSubtraction","addition","difference","resolve","currentOp","csgContext","React","Geometry","fref","computeVertexNormals","showOperations","ev","ops","current","boundingSphere","identity","shift","_geo$current","_geo$current$__r3f","_geo$current$__r3f$pa","operator","__r3f","parent","log","api","matrixAutoUpdate","ref","Provider","Base","showOperation","props","extend","_extends","visible","Subtraction","shaderMaterial","uniforms","vertexShader","fragmentShader","onInit","THREE","parameters","entries","reduce","acc","defineProperty","generateUUID","DiscardMaterial","MeshTransmissionMaterialImpl","samples","transmissionSampler","chromaticAberration","transmission","_transmission","transmissionMap","roughness","thickness","thicknessMap","attenuationDistance","attenuationColor","anisotropicBlur","time","distortion","distortionScale","temporalDistortion","onBeforeCompile","shader","anisotropy","defines","USE_ANISOTROPY","USE_SAMPLER","USE_TRANSMISSION","replace","MeshTransmissionMaterial","backside","backsideThickness","resolution","backsideResolution","background","discardMaterial","fboBack","useFBO","fboMain","oldBg","oldTone","useFrame","state","clock","getElapsedTime","texture","gl","toneMapping","scene","setRenderTarget","render","camera","args","SkyShader","turbidity","rayleigh","mieCoefficient","mieDirectionalG","sunPosition","up","version","ShaderMaterial","UniformsUtils","depthWrite","Sky","BoxGeometry","calcPosFromAngles","inclination","azimuth","vector","theta","phi","cos","sin","__publicField","scale","setScalar","sky","Sky$1","object","REVISION","Cache","files","file","remove","LoadingManager","onLoad","onError","scope","urlModifier","isLoading","itemsLoaded","itemsTotal","handlers","onStart","itemStart","url","itemEnd","itemError","resolveURL","setURLModifier","transform","addHandler","regex","loader","removeHandler","getHandler","global","lastIndex","test","DefaultLoadingManager","Loader","manager","crossOrigin","withCredentials","path","resourcePath","requestHeader","load","loadAsync","Promise","reject","parse","setCrossOrigin","setWithCredentials","setPath","setResourcePath","setRequestHeader","Int8Array","Uint8ClampedArray","Int16Array","Float64Array","createElementNS","document","_cache","warnOnce","message","ImageLoader","cached","setTimeout","image","onImageLoad","removeEventListeners","onImageError","event","removeEventListener","addEventListener","src","EventDispatcher","listener","_listeners","listeners","hasEventListener","listenerArray","dispatchEvent","call","ClampToEdgeWrapping","sRGBEncoding","SRGBColorSpace","_lut","toLowerCase","isVector2","width","height","setX","setY","setComponent","getComponent","addScalar","s","addVectors","subScalar","divide","divideScalar","applyMatrix3","m","clampScalar","minVal","maxVal","clampLength","ceil","round","roundToZero","negate","cross","lengthSq","manhattanLength","angle","atan2","denominator","acos","MathUtils","dx","dy","manhattanDistanceTo","setLength","lerp","alpha","lerpVectors","equals","fromArray","toArray","rotateAround","iterator","n11","n12","n13","n21","n22","n23","n31","n33","isMatrix3","te","me","extractBasis","xAxis","yAxis","zAxis","setFromMatrix3Column","setFromMatrix4","multiplyMatrices","premultiply","ae","be","a11","a12","a13","a21","a22","a23","a31","a32","a33","b11","b12","b13","b21","b22","b23","b31","b32","b33","f","h","t11","t12","t13","det","detInv","transpose","matrix4","transposeIntoArray","setUvTransform","tx","ty","sx","sy","rotation","_m3","makeScale","rotate","makeRotation","translate","makeTranslation","SRGBToLinear","_canvas","ImageUtils","getDataURL","HTMLCanvasElement","canvas","context","getContext","ImageData","putImageData","drawImage","toDataURL","sRGBToLinear","HTMLImageElement","ImageBitmap","imageData","getImageData","sourceId","Source","isSource","uuid","toJSON","meta","isRootObject","images","output","isDataTexture","serializeImage","textureId","Texture","DEFAULT_IMAGE","mapping","DEFAULT_MAPPING","wrapS","wrapT","magFilter","minFilter","format","DEFAULT_ANISOTROPY","colorSpace","isTexture","mipmaps","channel","internalFormat","repeat","generateMipmaps","premultiplyAlpha","flipY","unpackAlignment","userData","onUpdate","isRenderTargetTexture","needsPMREMUpdate","updateMatrix","JSON","stringify","textures","metadata","generator","wrap","transformUv","encoding","TextureLoader"],"sourceRoot":""}