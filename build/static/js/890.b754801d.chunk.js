"use strict";(self.webpackChunkdoor=self.webpackChunkdoor||[]).push([[890],{1940:(t,e,n)=>{n.d(e,{C:()=>u});var r=n(8168),o=n(5043),i=n(9408),a=n(7551);class s extends i.BufferGeometry{constructor(t,e,n,r){super();const o=[],a=[],s=[],c=new i.Vector3,u=new i.Matrix4;u.makeRotationFromEuler(n),u.setPosition(e);const d=new i.Matrix4;function p(e,n,r){n.applyMatrix4(t.matrixWorld),n.applyMatrix4(d),r.transformDirection(t.matrixWorld),e.push(new l(n.clone(),r.clone()))}function f(t,e){const n=[],o=.5*Math.abs(r.dot(e));for(let r=0;r<t.length;r+=3){let i,a,s,l,c,u,d,p=0;switch(i=t[r+0].position.dot(e)-o>0,a=t[r+1].position.dot(e)-o>0,s=t[r+2].position.dot(e)-o>0,p=(i?1:0)+(a?1:0)+(s?1:0),p){case 0:n.push(t[r]),n.push(t[r+1]),n.push(t[r+2]);break;case 1:if(i&&(l=t[r+1],c=t[r+2],u=m(t[r],l,e,o),d=m(t[r],c,e,o)),a){l=t[r],c=t[r+2],u=m(t[r+1],l,e,o),d=m(t[r+1],c,e,o),n.push(u),n.push(c.clone()),n.push(l.clone()),n.push(c.clone()),n.push(u.clone()),n.push(d);break}s&&(l=t[r],c=t[r+1],u=m(t[r+2],l,e,o),d=m(t[r+2],c,e,o)),n.push(l.clone()),n.push(c.clone()),n.push(u),n.push(d),n.push(u.clone()),n.push(c.clone());break;case 2:i||(l=t[r].clone(),c=m(l,t[r+1],e,o),u=m(l,t[r+2],e,o),n.push(l),n.push(c),n.push(u)),a||(l=t[r+1].clone(),c=m(l,t[r+2],e,o),u=m(l,t[r],e,o),n.push(l),n.push(c),n.push(u)),s||(l=t[r+2].clone(),c=m(l,t[r],e,o),u=m(l,t[r+1],e,o),n.push(l),n.push(c),n.push(u))}}return n}function m(t,e,n,r){const o=t.position.dot(n)-r,a=o/(o-(e.position.dot(n)-r));return new l(new i.Vector3(t.position.x+a*(e.position.x-t.position.x),t.position.y+a*(e.position.y-t.position.y),t.position.z+a*(e.position.z-t.position.z)),new i.Vector3(t.normal.x+a*(e.normal.x-t.normal.x),t.normal.y+a*(e.normal.y-t.normal.y),t.normal.z+a*(e.normal.z-t.normal.z)))}d.copy(u).invert(),function(){let e,n=[];const l=new i.Vector3,d=new i.Vector3;if(!0===t.geometry.isGeometry)return void console.error("THREE.DecalGeometry no longer supports THREE.Geometry. Use BufferGeometry instead.");const m=t.geometry,h=m.attributes.position,y=m.attributes.normal;if(null!==m.index){const t=m.index;for(e=0;e<t.count;e++)l.fromBufferAttribute(h,t.getX(e)),d.fromBufferAttribute(y,t.getX(e)),p(n,l,d)}else for(e=0;e<h.count;e++)l.fromBufferAttribute(h,e),d.fromBufferAttribute(y,e),p(n,l,d);for(n=f(n,c.set(1,0,0)),n=f(n,c.set(-1,0,0)),n=f(n,c.set(0,1,0)),n=f(n,c.set(0,-1,0)),n=f(n,c.set(0,0,1)),n=f(n,c.set(0,0,-1)),e=0;e<n.length;e++){const t=n[e];s.push(.5+t.position.x/r.x,.5+t.position.y/r.y),t.position.applyMatrix4(u),o.push(t.position.x,t.position.y,t.position.z),a.push(t.normal.x,t.normal.y,t.normal.z)}}(),this.setAttribute("position",new i.Float32BufferAttribute(o,3)),this.setAttribute("normal",new i.Float32BufferAttribute(a,3)),this.setAttribute("uv",new i.Float32BufferAttribute(s,2))}}class l{constructor(t,e){this.position=t,this.normal=e}clone(){return new this.constructor(this.position.clone(),this.normal.clone())}}function c(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[0,0,0];return function(t){return Array.isArray(t)}(t)?t:t instanceof i.Vector3||t instanceof i.Euler?[t.x,t.y,t.z]:[t,t,t]}const u=o.forwardRef((function(t,e){let{debug:n,depthTest:l=!1,polygonOffsetFactor:u=-10,map:d,mesh:p,children:f,position:m,rotation:h,scale:y,...x}=t;const v=o.useRef(null);o.useImperativeHandle(e,(()=>v.current));const g=o.useRef(null);return o.useLayoutEffect((()=>{const t=(null==p?void 0:p.current)||v.current.parent,e=v.current;if(!(t instanceof i.Mesh))throw new Error('Decal must have a Mesh as parent or specify its "mesh" prop');const n={position:new i.Vector3,rotation:new i.Euler,scale:new i.Vector3(1,1,1)};if(t){(0,a.j)(n,{position:m,scale:y});const r=t.matrixWorld.clone();if(t.matrixWorld.identity(),h&&"number"!==typeof h)(0,a.j)(n,{rotation:h});else{const e=new i.Object3D;e.position.copy(n.position),e.lookAt(t.position),"number"===typeof h&&e.rotateZ(h),(0,a.j)(n,{rotation:e.rotation})}return e.geometry=new s(t,n.position,n.rotation,n.scale),g.current&&((0,a.j)(g.current,n),g.current.traverse((t=>t.raycast=()=>null))),t.matrixWorld=r,()=>{e.geometry.dispose()}}}),[p,...c(m),...c(y),...c(h)]),o.createElement("mesh",(0,r.A)({ref:v,"material-transparent":!0,"material-polygonOffset":!0,"material-polygonOffsetFactor":u,"material-depthTest":l,"material-map":d},x),f,n&&o.createElement("mesh",{ref:g},o.createElement("boxGeometry",null),o.createElement("meshNormalMaterial",{wireframe:!0}),o.createElement("axesHelper",null)))}))},2029:(t,e,n)=>{n.d(e,{z:()=>b,F:()=>f});var r=n(5043),o=n(7551),i=n(9408),a=n(8168);const s=function(t){return function(e){t.forEach((function(t){"function"===typeof t?t(e):null!=t&&(t.current=e)}))}};var l=n(9211);const c=r.forwardRef(((t,e)=>{let{envMap:n,resolution:i=256,frames:c=1/0,children:u,makeDefault:d,...p}=t;const f=(0,o.A)((t=>{let{set:e}=t;return e})),m=(0,o.A)((t=>{let{camera:e}=t;return e})),h=(0,o.A)((t=>{let{size:e}=t;return e})),y=r.useRef(null),x=r.useRef(null),v=(0,l.j)(i);r.useLayoutEffect((()=>{p.manual||y.current.updateProjectionMatrix()}),[h,p]),r.useLayoutEffect((()=>{y.current.updateProjectionMatrix()})),r.useLayoutEffect((()=>{if(d){const t=m;return f((()=>({camera:y.current}))),()=>f((()=>({camera:t})))}}),[y,d,f]);let g=0,w=null;const b="function"===typeof u;return(0,o.C)((t=>{b&&(c===1/0||g<c)&&(x.current.visible=!1,t.gl.setRenderTarget(v),w=t.scene.background,n&&(t.scene.background=n),t.gl.render(t.scene,y.current),t.scene.background=w,t.gl.setRenderTarget(null),x.current.visible=!0,g++)})),r.createElement(r.Fragment,null,r.createElement("orthographicCamera",(0,a.A)({left:h.width/-2,right:h.width/2,top:h.height/2,bottom:h.height/-2,ref:s([y,e])},p),!b&&u),r.createElement("group",{ref:x},b&&u(v.texture)))}));function u(t){let{defaultScene:e,defaultCamera:n,renderPriority:i=1}=t;const{gl:a,scene:s,camera:l}=(0,o.A)();let c;return(0,o.C)((()=>{c=a.autoClear,1===i&&(a.autoClear=!0,a.render(e,n)),a.autoClear=!1,a.clearDepth(),a.render(s,l),a.autoClear=c}),i),r.createElement("group",{onPointerOver:()=>null})}function d(t){let{children:e,renderPriority:n=1}=t;const{scene:a,camera:s}=(0,o.A)(),[l]=r.useState((()=>new i.Scene));return r.createElement(r.Fragment,null,(0,o.g)(r.createElement(r.Fragment,null,e,r.createElement(u,{defaultScene:a,defaultCamera:s,renderPriority:n})),l,{events:{priority:n+1}}))}const p=r.createContext({}),f=()=>r.useContext(p),m=2*Math.PI,h=new i.Object3D,y=new i.Matrix4,[x,v]=[new i.Quaternion,new i.Quaternion],g=new i.Vector3,w=new i.Vector3,b=t=>{let{alignment:e="bottom-right",margin:n=[80,80],renderPriority:a=1,onUpdate:s,onTarget:l,children:u}=t;const f=(0,o.A)((t=>t.size)),b=(0,o.A)((t=>t.camera)),E=(0,o.A)((t=>t.controls)),S=(0,o.A)((t=>t.invalidate)),M=r.useRef(null),A=r.useRef(null),P=r.useRef(!1),C=r.useRef(0),z=r.useRef(new i.Vector3(0,0,0)),L=r.useRef(new i.Vector3(0,0,0));r.useEffect((()=>{L.current.copy(b.up)}),[b]);const R=r.useCallback((t=>{P.current=!0,(E||l)&&(z.current=(null==E?void 0:E.target)||(null==l?void 0:l())),C.current=b.position.distanceTo(g),x.copy(b.quaternion),w.copy(t).multiplyScalar(C.current).add(g),h.lookAt(w),h.up.copy(b.up),v.copy(h.quaternion),S()}),[E,b,l,S]);(0,o.C)(((t,e)=>{if(A.current&&M.current){var n;if(P.current)if(x.angleTo(v)<.01)P.current=!1,"minPolarAngle"in E&&b.up.copy(L.current);else{const t=e*m;x.rotateTowards(v,t),b.position.set(0,0,1).applyQuaternion(x).multiplyScalar(C.current).add(z.current),b.up.set(0,1,0).applyQuaternion(x).normalize(),b.quaternion.copy(x),s?s():E&&E.update(),S()}y.copy(b.matrix).invert(),null==(n=M.current)||n.quaternion.setFromRotationMatrix(y)}}));const _=r.useMemo((()=>({tweenCamera:R})),[R]),[T,D]=n,O=e.endsWith("-center")?0:e.endsWith("-left")?-f.width/2+T:f.width/2-T,B=e.startsWith("center-")?0:e.startsWith("top-")?f.height/2-D:-f.height/2+D;return r.createElement(d,{renderPriority:a},r.createElement(p.Provider,{value:_},r.createElement(c,{makeDefault:!0,ref:A,position:[0,0,200]}),r.createElement("group",{ref:M,position:[O,B,0]},u)))}},4315:(t,e,n)=>{n.d(e,{t:()=>u});var r=n(8168),o=n(5043),i=n(7551),a=n(9408),s=n(2029);function l(t){let{scale:e=[.8,.05,.05],color:n,rotation:r}=t;return o.createElement("group",{rotation:r},o.createElement("mesh",{position:[.4,0,0]},o.createElement("boxGeometry",{args:e}),o.createElement("meshBasicMaterial",{color:n,toneMapped:!1})))}function c(t){let{onClick:e,font:n,disabled:s,arcStyle:l,label:c,labelColor:u,axisHeadScale:d=1,...p}=t;const f=(0,i.A)((t=>t.gl)),m=o.useMemo((()=>{const t=document.createElement("canvas");t.width=64,t.height=64;const e=t.getContext("2d");return e.beginPath(),e.arc(32,32,16,0,2*Math.PI),e.closePath(),e.fillStyle=l,e.fill(),c&&(e.font=n,e.textAlign="center",e.fillStyle=u,e.fillText(c,32,41)),new a.CanvasTexture(t)}),[l,c,u,n]),[h,y]=o.useState(!1),x=(c?1:.75)*(h?1.2:1)*d;return o.createElement("sprite",(0,r.A)({scale:x,onPointerOver:s?void 0:t=>{t.stopPropagation(),y(!0)},onPointerOut:s?void 0:e||(t=>{t.stopPropagation(),y(!1)})},p),o.createElement("spriteMaterial",{map:m,"map-anisotropy":f.capabilities.getMaxAnisotropy()||1,alphaTest:.3,opacity:c?1:.75,toneMapped:!1}))}const u=t=>{let{hideNegativeAxes:e,hideAxisHeads:n,disabled:i,font:a="18px Inter var, Arial, sans-serif",axisColors:u=["#ff2060","#20df80","#2080ff"],axisHeadScale:d=1,axisScale:p,labels:f=["X","Y","Z"],labelColor:m="#000",onClick:h,...y}=t;const[x,v,g]=u,{tweenCamera:w}=(0,s.F)(),b={font:a,disabled:i,labelColor:m,onClick:h,axisHeadScale:d,onPointerDown:i?void 0:t=>{w(t.object.position),t.stopPropagation()}};return o.createElement("group",(0,r.A)({scale:40},y),o.createElement(l,{color:x,rotation:[0,0,0],scale:p}),o.createElement(l,{color:v,rotation:[0,0,Math.PI/2],scale:p}),o.createElement(l,{color:g,rotation:[0,-Math.PI/2,0],scale:p}),!n&&o.createElement(o.Fragment,null,o.createElement(c,(0,r.A)({arcStyle:x,position:[1,0,0],label:f[0]},b)),o.createElement(c,(0,r.A)({arcStyle:v,position:[0,1,0],label:f[1]},b)),o.createElement(c,(0,r.A)({arcStyle:g,position:[0,0,1],label:f[2]},b)),!e&&o.createElement(o.Fragment,null,o.createElement(c,(0,r.A)({arcStyle:x,position:[-1,0,0]},b)),o.createElement(c,(0,r.A)({arcStyle:v,position:[0,-1,0]},b)),o.createElement(c,(0,r.A)({arcStyle:g,position:[0,0,-1]},b)))))}},9211:(t,e,n)=>{n.d(e,{j:()=>a});var r=n(5043),o=n(9408),i=n(7551);function a(t,e,n){const a=(0,i.A)((t=>t.size)),s=(0,i.A)((t=>t.viewport)),l="number"===typeof t?t:a.width*s.dpr,c="number"===typeof e?e:a.height*s.dpr,u=("number"===typeof t?n:t)||{},{samples:d=0,depth:p,...f}=u,m=r.useMemo((()=>{const t=new o.WebGLRenderTarget(l,c,{minFilter:o.LinearFilter,magFilter:o.LinearFilter,type:o.HalfFloatType,...f});return p&&(t.depthTexture=new o.DepthTexture(l,c,o.FloatType)),t.samples=d,t}),[]);return r.useLayoutEffect((()=>{m.setSize(l,c),d&&(m.samples=d)}),[d,m,l,c]),r.useEffect((()=>()=>m.dispose()),[]),m}},2201:(t,e,n)=>{n.d(e,{z:()=>s});var r=n(9408),o=n(7551),i=n(5043);const a=t=>t===Object(t)&&!Array.isArray(t)&&"function"!==typeof t;function s(t,e){const n=(0,o.A)((t=>t.gl)),s=(0,o.F)(r.TextureLoader,a(t)?Object.values(t):t);if((0,i.useLayoutEffect)((()=>{null==e||e(s)}),[e]),(0,i.useEffect)((()=>{if("initTexture"in n){(Array.isArray(s)?s:[s]).forEach(n.initTexture)}}),[n,s]),a(t)){const e={};let n=0;for(const r in t)e[r]=s[n++];return e}return s}s.preload=t=>o.F.preload(r.TextureLoader,t),s.clear=t=>o.F.clear(r.TextureLoader,t)},2309:(t,e,n)=>{n.d(e,{E:()=>x});var r=n(8168),o=n(5043),i=n(4391),a=n(9408),s=n(7551);const l=new a.Vector3,c=new a.Vector3,u=new a.Vector3;function d(t,e,n){const r=l.setFromMatrixPosition(t.matrixWorld);r.project(e);const o=n.width/2,i=n.height/2;return[r.x*o+o,-r.y*i+i]}const p=t=>Math.abs(t)<1e-10?0:t;function f(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"",r="matrix3d(";for(let o=0;16!==o;o++)r+=p(e[o]*t.elements[o])+(15!==o?",":")");return n+r}const m=(h=[1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1],t=>f(t,h));var h;const y=(t,e)=>{return f(t,[1/(n=e),1/n,1/n,1,-1/n,-1/n,-1/n,-1,1/n,1/n,1/n,1,1,1,1,1],"translate(-50%,-50%)");var n};const x=o.forwardRef(((t,e)=>{let{children:n,eps:f=.001,style:h,className:x,prepend:v,center:g,fullscreen:w,portal:b,distanceFactor:E,sprite:S=!1,transform:M=!1,occlude:A,onOcclude:P,castShadow:C,receiveShadow:z,material:L,geometry:R,zIndexRange:_=[16777271,0],calculatePosition:T=d,as:D="div",wrapperClass:O,pointerEvents:B="auto",...U}=t;const{gl:V,camera:W,scene:F,size:I,raycaster:k,events:j,viewport:H}=(0,s.A)(),[N]=o.useState((()=>document.createElement(D))),G=o.useRef(),q=o.useRef(null),Q=o.useRef(0),X=o.useRef([0,0]),Z=o.useRef(null),J=o.useRef(null),K=(null==b?void 0:b.current)||j.connected||V.domElement.parentNode,Y=o.useRef(null),$=o.useRef(!1),tt=o.useMemo((()=>A&&"blending"!==A||Array.isArray(A)&&A.length&&function(t){return t&&"object"===typeof t&&"current"in t}(A[0])),[A]);o.useLayoutEffect((()=>{const t=V.domElement;A&&"blending"===A?(t.style.zIndex="".concat(Math.floor(_[0]/2)),t.style.position="absolute",t.style.pointerEvents="none"):(t.style.zIndex=null,t.style.position=null,t.style.pointerEvents=null)}),[A]),o.useLayoutEffect((()=>{if(q.current){const t=G.current=i.createRoot(N);if(F.updateMatrixWorld(),M)N.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const t=T(q.current,W,I);N.style.cssText="position:absolute;top:0;left:0;transform:translate3d(".concat(t[0],"px,").concat(t[1],"px,0);transform-origin:0 0;")}return K&&(v?K.prepend(N):K.appendChild(N)),()=>{K&&K.removeChild(N),t.unmount()}}}),[K,M]),o.useLayoutEffect((()=>{O&&(N.className=O)}),[O]);const et=o.useMemo((()=>M?{position:"absolute",top:0,left:0,width:I.width,height:I.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:g?"translate3d(-50%,-50%,0)":"none",...w&&{top:-I.height/2,left:-I.width/2,width:I.width,height:I.height},...h}),[h,g,w,I,M]),nt=o.useMemo((()=>({position:"absolute",pointerEvents:B})),[B]);o.useLayoutEffect((()=>{var t,r;($.current=!1,M)?null==(t=G.current)||t.render(o.createElement("div",{ref:Z,style:et},o.createElement("div",{ref:J,style:nt},o.createElement("div",{ref:e,className:x,style:h,children:n})))):null==(r=G.current)||r.render(o.createElement("div",{ref:e,style:et,className:x,children:n}))}));const rt=o.useRef(!0);(0,s.C)((t=>{if(q.current){W.updateMatrixWorld(),q.current.updateWorldMatrix(!0,!1);const t=M?X.current:T(q.current,W,I);if(M||Math.abs(Q.current-W.zoom)>f||Math.abs(X.current[0]-t[0])>f||Math.abs(X.current[1]-t[1])>f){const e=function(t,e){const n=l.setFromMatrixPosition(t.matrixWorld),r=c.setFromMatrixPosition(e.matrixWorld),o=n.sub(r),i=e.getWorldDirection(u);return o.angleTo(i)>Math.PI/2}(q.current,W);let n=!1;tt&&(Array.isArray(A)?n=A.map((t=>t.current)):"blending"!==A&&(n=[F]));const r=rt.current;if(n){const t=function(t,e,n,r){const o=l.setFromMatrixPosition(t.matrixWorld),i=o.clone();i.project(e),n.setFromCamera(i,e);const a=n.intersectObjects(r,!0);if(a.length){const t=a[0].distance;return o.distanceTo(n.ray.origin)<t}return!0}(q.current,W,k,n);rt.current=t&&!e}else rt.current=!e;r!==rt.current&&(P?P(!rt.current):N.style.display=rt.current?"block":"none");const o=Math.floor(_[0]/2),i=A?tt?[_[0],o]:[o-1,0]:_;if(N.style.zIndex="".concat(function(t,e,n){if(e instanceof a.PerspectiveCamera||e instanceof a.OrthographicCamera){const r=l.setFromMatrixPosition(t.matrixWorld),o=c.setFromMatrixPosition(e.matrixWorld),i=r.distanceTo(o),a=(n[1]-n[0])/(e.far-e.near),s=n[1]-a*e.far;return Math.round(a*i+s)}}(q.current,W,i)),M){const[t,e]=[I.width/2,I.height/2],n=W.projectionMatrix.elements[5]*e,{isOrthographicCamera:r,top:o,left:i,bottom:a,right:s}=W,l=m(W.matrixWorldInverse),c=r?"scale(".concat(n,")translate(").concat(p(-(s+i)/2),"px,").concat(p((o+a)/2),"px)"):"translateZ(".concat(n,"px)");let u=q.current.matrixWorld;S&&(u=W.matrixWorldInverse.clone().transpose().copyPosition(u).scale(q.current.scale),u.elements[3]=u.elements[7]=u.elements[11]=0,u.elements[15]=1),N.style.width=I.width+"px",N.style.height=I.height+"px",N.style.perspective=r?"":"".concat(n,"px"),Z.current&&J.current&&(Z.current.style.transform="".concat(c).concat(l,"translate(").concat(t,"px,").concat(e,"px)"),J.current.style.transform=y(u,1/((E||10)/400)))}else{const e=void 0===E?1:function(t,e){if(e instanceof a.OrthographicCamera)return e.zoom;if(e instanceof a.PerspectiveCamera){const n=l.setFromMatrixPosition(t.matrixWorld),r=c.setFromMatrixPosition(e.matrixWorld),o=e.fov*Math.PI/180,i=n.distanceTo(r);return 1/(2*Math.tan(o/2)*i)}return 1}(q.current,W)*E;N.style.transform="translate3d(".concat(t[0],"px,").concat(t[1],"px,0) scale(").concat(e,")")}X.current=t,Q.current=W.zoom}}if(!tt&&Y.current&&!$.current)if(M){if(Z.current){const t=Z.current.children[0];if(null!=t&&t.clientWidth&&null!=t&&t.clientHeight){const{isOrthographicCamera:e}=W;if(e||R)U.scale&&(Array.isArray(U.scale)?U.scale instanceof a.Vector3?Y.current.scale.copy(U.scale.clone().divideScalar(1)):Y.current.scale.set(1/U.scale[0],1/U.scale[1],1/U.scale[2]):Y.current.scale.setScalar(1/U.scale));else{const e=(E||10)/400,n=t.clientWidth*e,r=t.clientHeight*e;Y.current.scale.set(n,r,1)}$.current=!0}}}else{const e=N.children[0];if(null!=e&&e.clientWidth&&null!=e&&e.clientHeight){const t=1/H.factor,n=e.clientWidth*t,r=e.clientHeight*t;Y.current.scale.set(n,r,1),$.current=!0}Y.current.lookAt(t.camera.position)}}));const ot=o.useMemo((()=>({vertexShader:M?void 0:'\n          /*\n            This shader is from the THREE\'s SpriteMaterial.\n            We need to turn the backing plane into a Sprite\n            (make it always face the camera) if "transfrom" \n            is false. \n          */\n          #include <common>\n\n          void main() {\n            vec2 center = vec2(0., 1.);\n            float rotation = 0.0;\n            \n            // This is somewhat arbitrary, but it seems to work well\n            // Need to figure out how to derive this dynamically if it even matters\n            float size = 0.03;\n\n            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n            vec2 scale;\n            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\n            bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n            if ( isPerspective ) scale *= - mvPosition.z;\n\n            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;\n            vec2 rotatedPosition;\n            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n            mvPosition.xy += rotatedPosition;\n\n            gl_Position = projectionMatrix * mvPosition;\n          }\n      ',fragmentShader:"\n        void main() {\n          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      "})),[M]);return o.createElement("group",(0,r.A)({},U,{ref:q}),A&&!tt&&o.createElement("mesh",{castShadow:C,receiveShadow:z,ref:Y},R||o.createElement("planeGeometry",null),L||o.createElement("shaderMaterial",{side:a.DoubleSide,vertexShader:ot.vertexShader,fragmentShader:ot.fragmentShader})))}))},6569:(t,e,n)=>{n.d(e,{n:()=>gt});var r=n(8168),o=n(7551),i=n(5043),a=n(9408);const s=new a.Box3,l=new a.Vector3;class c extends a.InstancedBufferGeometry{constructor(){super(),this.isLineSegmentsGeometry=!0,this.type="LineSegmentsGeometry";this.setIndex([0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5]),this.setAttribute("position",new a.Float32BufferAttribute([-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],3)),this.setAttribute("uv",new a.Float32BufferAttribute([-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],2))}applyMatrix4(t){const e=this.attributes.instanceStart,n=this.attributes.instanceEnd;return void 0!==e&&(e.applyMatrix4(t),n.applyMatrix4(t),e.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}setPositions(t){let e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));const n=new a.InstancedInterleavedBuffer(e,6,1);return this.setAttribute("instanceStart",new a.InterleavedBufferAttribute(n,3,0)),this.setAttribute("instanceEnd",new a.InterleavedBufferAttribute(n,3,3)),this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(t){let e,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));const r=new a.InstancedInterleavedBuffer(e,2*n,1);return this.setAttribute("instanceColorStart",new a.InterleavedBufferAttribute(r,n,0)),this.setAttribute("instanceColorEnd",new a.InterleavedBufferAttribute(r,n,n)),this}fromWireframeGeometry(t){return this.setPositions(t.attributes.position.array),this}fromEdgesGeometry(t){return this.setPositions(t.attributes.position.array),this}fromMesh(t){return this.fromWireframeGeometry(new a.WireframeGeometry(t.geometry)),this}fromLineSegments(t){const e=t.geometry;return this.setPositions(e.attributes.position.array),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new a.Box3);const t=this.attributes.instanceStart,e=this.attributes.instanceEnd;void 0!==t&&void 0!==e&&(this.boundingBox.setFromBufferAttribute(t),s.setFromBufferAttribute(e),this.boundingBox.union(s))}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new a.Sphere),null===this.boundingBox&&this.computeBoundingBox();const t=this.attributes.instanceStart,e=this.attributes.instanceEnd;if(void 0!==t&&void 0!==e){const n=this.boundingSphere.center;this.boundingBox.getCenter(n);let r=0;for(let o=0,i=t.count;o<i;o++)l.fromBufferAttribute(t,o),r=Math.max(r,n.distanceToSquared(l)),l.fromBufferAttribute(e,o),r=Math.max(r,n.distanceToSquared(l));this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}applyMatrix(t){return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."),this.applyMatrix4(t)}}class u extends a.ShaderMaterial{constructor(t){super({type:"LineMaterial",uniforms:a.UniformsUtils.clone(a.UniformsUtils.merge([a.UniformsLib.common,a.UniformsLib.fog,{worldUnits:{value:1},linewidth:{value:1},resolution:{value:new a.Vector2(1,1)},dashOffset:{value:0},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1}}])),vertexShader:"\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t\t#include <clipping_planes_pars_vertex>\n\n\t\t\t\tuniform float linewidth;\n\t\t\t\tuniform vec2 resolution;\n\n\t\t\t\tattribute vec3 instanceStart;\n\t\t\t\tattribute vec3 instanceEnd;\n\n\t\t\t\t#ifdef USE_COLOR\n\t\t\t\t\t#ifdef USE_LINE_COLOR_ALPHA\n\t\t\t\t\t\tvarying vec4 vLineColor;\n\t\t\t\t\t\tattribute vec4 instanceColorStart;\n\t\t\t\t\t\tattribute vec4 instanceColorEnd;\n\t\t\t\t\t#else\n\t\t\t\t\t\tvarying vec3 vLineColor;\n\t\t\t\t\t\tattribute vec3 instanceColorStart;\n\t\t\t\t\t\tattribute vec3 instanceColorEnd;\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\tvarying vec4 worldPos;\n\t\t\t\t\tvarying vec3 worldStart;\n\t\t\t\t\tvarying vec3 worldEnd;\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#else\n\n\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\tuniform float dashScale;\n\t\t\t\t\tattribute float instanceDistanceStart;\n\t\t\t\t\tattribute float instanceDistanceEnd;\n\t\t\t\t\tvarying float vLineDistance;\n\n\t\t\t\t#endif\n\n\t\t\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t\t\t// conservative estimate of the near plane\n\t\t\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#ifdef USE_COLOR\n\n\t\t\t\t\t\tvLineColor = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\t\t\tvUv = uv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t\t\t// camera space\n\t\t\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\t\tworldStart = start.xyz;\n\t\t\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tvUv = uv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\t\t\tif ( perspective ) {\n\n\t\t\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// clip space\n\t\t\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t\t\t// ndc space\n\t\t\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t\t\t// direction\n\t\t\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t\t\t// account for clip-space aspect ratio\n\t\t\t\t\tdir.x *= aspect;\n\t\t\t\t\tdir = normalize( dir );\n\n\t\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\t\t\tvec3 offset;\n\t\t\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// sign flip\n\t\t\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// endcaps\n\t\t\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// adjust for linewidth\n\t\t\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t\t\t// set the world position\n\t\t\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t\t\t// project the worldpos\n\t\t\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t\t\t// segments overlap neatly\n\t\t\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\t\t\tdir.x /= aspect;\n\t\t\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t\t\t// sign flip\n\t\t\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t\t\t// endcaps\n\t\t\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\t\t\toffset += - dir;\n\n\t\t\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\t\t\toffset += dir;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// adjust for linewidth\n\t\t\t\t\t\toffset *= linewidth;\n\n\t\t\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t\t\t// select end\n\t\t\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t\t\t// back to clip space\n\t\t\t\t\t\toffset *= clip.w;\n\n\t\t\t\t\t\tclip.xy += offset;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tgl_Position = clip;\n\n\t\t\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t\t#include <clipping_planes_vertex>\n\t\t\t\t\t#include <fog_vertex>\n\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\t\t\t\tuniform vec3 diffuse;\n\t\t\t\tuniform float opacity;\n\t\t\t\tuniform float linewidth;\n\n\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\tuniform float dashOffset;\n\t\t\t\t\tuniform float dashSize;\n\t\t\t\t\tuniform float gapSize;\n\n\t\t\t\t#endif\n\n\t\t\t\tvarying float vLineDistance;\n\n\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\tvarying vec4 worldPos;\n\t\t\t\t\tvarying vec3 worldStart;\n\t\t\t\t\tvarying vec3 worldEnd;\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#else\n\n\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t#endif\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <clipping_planes_pars_fragment>\n\n\t\t\t\t#ifdef USE_COLOR\n\t\t\t\t\t#ifdef USE_LINE_COLOR_ALPHA\n\t\t\t\t\t\tvarying vec4 vLineColor;\n\t\t\t\t\t#else\n\t\t\t\t\t\tvarying vec3 vLineColor;\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\n\t\t\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\t\t\tfloat mua;\n\t\t\t\t\tfloat mub;\n\n\t\t\t\t\tvec3 p13 = p1 - p3;\n\t\t\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\t\t\tmua = numer / denom;\n\t\t\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\t\t\treturn vec2( mua, mub );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tfloat alpha = opacity;\n\n\t\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\t\t\tfloat len = length( delta );\n\t\t\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\t\t\t\t\t#ifdef USE_COLOR\n\t\t\t\t\t\t#ifdef USE_LINE_COLOR_ALPHA\n\t\t\t\t\t\t\tdiffuseColor *= vLineColor;\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tdiffuseColor.rgb *= vLineColor;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\t\t\tgl_FragColor = diffuseColor;\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <".concat(parseInt(a.REVISION.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment",">\n\t\t\t\t\t#include <fog_fragment>\n\t\t\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t\t\t}\n\t\t\t"),clipping:!0}),this.isLineMaterial=!0,this.onBeforeCompile=function(){this.transparent?this.defines.USE_LINE_COLOR_ALPHA="1":delete this.defines.USE_LINE_COLOR_ALPHA},Object.defineProperties(this,{color:{enumerable:!0,get:function(){return this.uniforms.diffuse.value},set:function(t){this.uniforms.diffuse.value=t}},worldUnits:{enumerable:!0,get:function(){return"WORLD_UNITS"in this.defines},set:function(t){!0===t?this.defines.WORLD_UNITS="":delete this.defines.WORLD_UNITS}},linewidth:{enumerable:!0,get:function(){return this.uniforms.linewidth.value},set:function(t){this.uniforms.linewidth.value=t}},dashed:{enumerable:!0,get:function(){return Boolean("USE_DASH"in this.defines)},set(t){Boolean(t)!==Boolean("USE_DASH"in this.defines)&&(this.needsUpdate=!0),!0===t?this.defines.USE_DASH="":delete this.defines.USE_DASH}},dashScale:{enumerable:!0,get:function(){return this.uniforms.dashScale.value},set:function(t){this.uniforms.dashScale.value=t}},dashSize:{enumerable:!0,get:function(){return this.uniforms.dashSize.value},set:function(t){this.uniforms.dashSize.value=t}},dashOffset:{enumerable:!0,get:function(){return this.uniforms.dashOffset.value},set:function(t){this.uniforms.dashOffset.value=t}},gapSize:{enumerable:!0,get:function(){return this.uniforms.gapSize.value},set:function(t){this.uniforms.gapSize.value=t}},opacity:{enumerable:!0,get:function(){return this.uniforms.opacity.value},set:function(t){this.uniforms.opacity.value=t}},resolution:{enumerable:!0,get:function(){return this.uniforms.resolution.value},set:function(t){this.uniforms.resolution.value.copy(t)}},alphaToCoverage:{enumerable:!0,get:function(){return Boolean("USE_ALPHA_TO_COVERAGE"in this.defines)},set:function(t){Boolean(t)!==Boolean("USE_ALPHA_TO_COVERAGE"in this.defines)&&(this.needsUpdate=!0),!0===t?(this.defines.USE_ALPHA_TO_COVERAGE="",this.extensions.derivatives=!0):(delete this.defines.USE_ALPHA_TO_COVERAGE,this.extensions.derivatives=!1)}}}),this.setValues(t)}}const d=new a.Vector3,p=new a.Vector3,f=new a.Vector4,m=new a.Vector4,h=new a.Vector4,y=new a.Vector3,x=new a.Matrix4,v=new a.Line3,g=new a.Vector3,w=new a.Box3,b=new a.Sphere,E=new a.Vector4;let S,M,A,P;function C(t,e,n){return E.set(0,0,-e,1).applyMatrix4(t.projectionMatrix),E.multiplyScalar(1/E.w),E.x=P/n.width,E.y=P/n.height,E.applyMatrix4(t.projectionMatrixInverse),E.multiplyScalar(1/E.w),Math.abs(Math.max(E.x,E.y))}class z extends a.Mesh{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:new c,arguments.length>1&&void 0!==arguments[1]?arguments[1]:new u({color:16777215*Math.random()})),this.isLineSegments2=!0,this.type="LineSegments2"}computeLineDistances(){const t=this.geometry,e=t.attributes.instanceStart,n=t.attributes.instanceEnd,r=new Float32Array(2*e.count);for(let i=0,a=0,s=e.count;i<s;i++,a+=2)d.fromBufferAttribute(e,i),p.fromBufferAttribute(n,i),r[a]=0===a?0:r[a-1],r[a+1]=r[a]+d.distanceTo(p);const o=new a.InstancedInterleavedBuffer(r,2,1);return t.setAttribute("instanceDistanceStart",new a.InterleavedBufferAttribute(o,1,0)),t.setAttribute("instanceDistanceEnd",new a.InterleavedBufferAttribute(o,1,1)),this}raycast(t,e){const n=this.material.worldUnits,r=t.camera;null!==r||n||console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');const o=void 0!==t.params.Line2&&t.params.Line2.threshold||0;S=t.ray;const i=this.matrixWorld,s=this.geometry,l=this.material;let c,u;if(P=l.linewidth+o,M=s.attributes.instanceStart,A=s.attributes.instanceEnd,null===s.boundingSphere&&s.computeBoundingSphere(),b.copy(s.boundingSphere).applyMatrix4(i),n)c=.5*P;else{c=C(r,Math.max(r.near,b.distanceToPoint(S.origin)),l.resolution)}if(b.radius+=c,!1!==S.intersectsSphere(b)){if(null===s.boundingBox&&s.computeBoundingBox(),w.copy(s.boundingBox).applyMatrix4(i),n)u=.5*P;else{u=C(r,Math.max(r.near,w.distanceToPoint(S.origin)),l.resolution)}w.expandByScalar(u),!1!==S.intersectsBox(w)&&(n?function(t,e){for(let n=0,r=M.count;n<r;n++){v.start.fromBufferAttribute(M,n),v.end.fromBufferAttribute(A,n);const r=new a.Vector3,o=new a.Vector3;S.distanceSqToSegment(v.start,v.end,o,r),o.distanceTo(r)<.5*P&&e.push({point:o,pointOnLine:r,distance:S.origin.distanceTo(o),object:t,face:null,faceIndex:n,uv:null,uv2:null})}}(this,e):function(t,e,n){const r=e.projectionMatrix,o=t.material.resolution,i=t.matrixWorld,s=t.geometry,l=s.attributes.instanceStart,c=s.attributes.instanceEnd,u=-e.near;S.at(1,h),h.w=1,h.applyMatrix4(e.matrixWorldInverse),h.applyMatrix4(r),h.multiplyScalar(1/h.w),h.x*=o.x/2,h.y*=o.y/2,h.z=0,y.copy(h),x.multiplyMatrices(e.matrixWorldInverse,i);for(let d=0,p=l.count;d<p;d++){if(f.fromBufferAttribute(l,d),m.fromBufferAttribute(c,d),f.w=1,m.w=1,f.applyMatrix4(x),m.applyMatrix4(x),f.z>u&&m.z>u)continue;if(f.z>u){const t=f.z-m.z,e=(f.z-u)/t;f.lerp(m,e)}else if(m.z>u){const t=m.z-f.z,e=(m.z-u)/t;m.lerp(f,e)}f.applyMatrix4(r),m.applyMatrix4(r),f.multiplyScalar(1/f.w),m.multiplyScalar(1/m.w),f.x*=o.x/2,f.y*=o.y/2,m.x*=o.x/2,m.y*=o.y/2,v.start.copy(f),v.start.z=0,v.end.copy(m),v.end.z=0;const e=v.closestPointToPointParameter(y,!0);v.at(e,g);const s=a.MathUtils.lerp(f.z,m.z,e),p=s>=-1&&s<=1,h=y.distanceTo(g)<.5*P;if(p&&h){v.start.fromBufferAttribute(l,d),v.end.fromBufferAttribute(c,d),v.start.applyMatrix4(i),v.end.applyMatrix4(i);const e=new a.Vector3,r=new a.Vector3;S.distanceSqToSegment(v.start,v.end,r,e),n.push({point:r,pointOnLine:e,distance:S.origin.distanceTo(r),object:t,face:null,faceIndex:d,uv:null,uv2:null})}}}(this,r,e))}}}class L extends c{constructor(){super(),this.isLineGeometry=!0,this.type="LineGeometry"}setPositions(t){const e=t.length-3,n=new Float32Array(2*e);for(let r=0;r<e;r+=3)n[2*r]=t[r],n[2*r+1]=t[r+1],n[2*r+2]=t[r+2],n[2*r+3]=t[r+3],n[2*r+4]=t[r+4],n[2*r+5]=t[r+5];return super.setPositions(n),this}setColors(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;const n=t.length-e,r=new Float32Array(2*n);if(3===e)for(let o=0;o<n;o+=e)r[2*o]=t[o],r[2*o+1]=t[o+1],r[2*o+2]=t[o+2],r[2*o+3]=t[o+3],r[2*o+4]=t[o+4],r[2*o+5]=t[o+5];else for(let o=0;o<n;o+=e)r[2*o]=t[o],r[2*o+1]=t[o+1],r[2*o+2]=t[o+2],r[2*o+3]=t[o+3],r[2*o+4]=t[o+4],r[2*o+5]=t[o+5],r[2*o+6]=t[o+6],r[2*o+7]=t[o+7];return super.setColors(r,e),this}fromLine(t){const e=t.geometry;return this.setPositions(e.attributes.position.array),this}}class R extends z{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:new L,arguments.length>1&&void 0!==arguments[1]?arguments[1]:new u({color:16777215*Math.random()})),this.isLine2=!0,this.type="Line2"}}const _=i.forwardRef((function(t,e){let{points:n,color:s=16777215,vertexColors:l,linewidth:d,lineWidth:p,segments:f,dashed:m,...h}=t;var y;const x=(0,o.A)((t=>t.size)),v=i.useMemo((()=>f?new z:new R),[f]),[g]=i.useState((()=>new u)),w=4===(null==l||null==(y=l[0])?void 0:y.length)?4:3,b=i.useMemo((()=>{const t=f?new c:new L,e=n.map((t=>{const e=Array.isArray(t);return t instanceof a.Vector3||t instanceof a.Vector4?[t.x,t.y,t.z]:t instanceof a.Vector2?[t.x,t.y,0]:e&&3===t.length?[t[0],t[1],t[2]]:e&&2===t.length?[t[0],t[1],0]:t}));if(t.setPositions(e.flat()),l){s=16777215;const e=l.map((t=>t instanceof a.Color?t.toArray():t));t.setColors(e.flat(),w)}return t}),[n,f,l,w]);return i.useLayoutEffect((()=>{v.computeLineDistances()}),[n,v]),i.useLayoutEffect((()=>{m?g.defines.USE_DASH="":delete g.defines.USE_DASH,g.needsUpdate=!0}),[m,g]),i.useEffect((()=>()=>b.dispose()),[b]),i.createElement("primitive",(0,r.A)({object:v,ref:e},h),i.createElement("primitive",{object:b,attach:"geometry"}),i.createElement("primitive",(0,r.A)({object:g,attach:"material",color:s,vertexColors:Boolean(l),resolution:[x.width,x.height],linewidth:null!==d&&void 0!==d?d:p,dashed:m,transparent:4===w},h)))}));var T=n(2309);const D=i.createContext(null),O=new a.Vector3,B=new a.Vector3,U=new a.Vector3(0,1,0),V=new a.Matrix4,W=t=>{let{direction:e,axis:n}=t;const{translation:r,translationLimits:s,annotations:l,annotationsClass:c,depthTest:u,scale:d,lineWidth:p,fixed:f,axisColors:m,hoveredColor:h,opacity:y,onDragStart:x,onDrag:v,onDragEnd:g,userData:w}=i.useContext(D),b=(0,o.A)((t=>t.controls)),E=i.useRef(null),S=i.useRef(null),M=i.useRef(null),A=i.useRef(0),[P,C]=i.useState(!1),z=i.useCallback((t=>{l&&(E.current.innerText="".concat(r.current[n].toFixed(2)),E.current.style.display="block"),t.stopPropagation();const o=(new a.Matrix4).extractRotation(S.current.matrixWorld),i=t.point.clone(),s=(new a.Vector3).setFromMatrixPosition(S.current.matrixWorld),c=e.clone().applyMatrix4(o).normalize();M.current={clickPoint:i,dir:c},A.current=r.current[n],x({component:"Arrow",axis:n,origin:s,directions:[c]}),b&&(b.enabled=!1),t.target.setPointerCapture(t.pointerId)}),[l,e,b,x,r,n]),L=i.useCallback((t=>{if(t.stopPropagation(),P||C(!0),M.current){const{clickPoint:e,dir:o}=M.current,[i,a]=(null==s?void 0:s[n])||[void 0,void 0];let c=((t,e,n,r)=>{const o=e.dot(e),i=e.dot(t)-e.dot(n),a=e.dot(r);return 0===a?-i/o:(O.copy(r).multiplyScalar(o/a).sub(e),B.copy(r).multiplyScalar(i/a).add(n).sub(t),-O.dot(B)/O.dot(O))})(e,o,t.ray.origin,t.ray.direction);void 0!==i&&(c=Math.max(c,i-A.current)),void 0!==a&&(c=Math.min(c,a-A.current)),r.current[n]=A.current+c,l&&(E.current.innerText="".concat(r.current[n].toFixed(2))),V.makeTranslation(o.x*c,o.y*c,o.z*c),v(V)}}),[l,v,P,r,s,n]),R=i.useCallback((t=>{l&&(E.current.style.display="none"),t.stopPropagation(),M.current=null,g(),b&&(b.enabled=!0),t.target.releasePointerCapture(t.pointerId)}),[l,b,g]),W=i.useCallback((t=>{t.stopPropagation(),C(!1)}),[]),{cylinderLength:F,coneWidth:I,coneLength:k,matrixL:j}=i.useMemo((()=>{const t=f?p/d*1.6:d/20,n=f?.2:d/5,r=f?1-n:d-n,o=(new a.Quaternion).setFromUnitVectors(U,e.clone().normalize());return{cylinderLength:r,coneWidth:t,coneLength:n,matrixL:(new a.Matrix4).makeRotationFromQuaternion(o)}}),[e,d,p,f]),H=P?h:m[n];return i.createElement("group",{ref:S},i.createElement("group",{matrix:j,matrixAutoUpdate:!1,onPointerDown:z,onPointerMove:L,onPointerUp:R,onPointerOut:W},l&&i.createElement(T.E,{position:[0,-k,0]},i.createElement("div",{style:{display:"none",background:"#151520",color:"white",padding:"6px 8px",borderRadius:7,whiteSpace:"nowrap"},className:c,ref:E})),i.createElement("mesh",{visible:!1,position:[0,(F+k)/2,0],userData:w},i.createElement("cylinderGeometry",{args:[1.4*I,1.4*I,F+k,8,1]})),i.createElement(_,{transparent:!0,raycast:()=>null,depthTest:u,points:[0,0,0,0,F,0],lineWidth:p,color:H,opacity:y,polygonOffset:!0,renderOrder:1,polygonOffsetFactor:-10,fog:!1}),i.createElement("mesh",{raycast:()=>null,position:[0,F+k/2,0],renderOrder:500},i.createElement("coneGeometry",{args:[I,k,24,1]}),i.createElement("meshBasicMaterial",{transparent:!0,depthTest:u,color:H,opacity:y,polygonOffset:!0,polygonOffsetFactor:-10,fog:!1}))))},F=new a.Vector3,I=new a.Vector3,k=t=>180*t/Math.PI,j=t=>{let e=((t,e)=>{let n=Math.floor(t/e);return n=n<0?n+1:n,t-n*e})(t,2*Math.PI);return Math.abs(e)<1e-6?0:(e<0&&(e+=2*Math.PI),e)},H=new a.Matrix4,N=new a.Vector3,G=new a.Ray,q=new a.Vector3,Q=t=>{let{dir1:e,dir2:n,axis:r}=t;const{rotationLimits:s,annotations:l,annotationsClass:c,depthTest:u,scale:d,lineWidth:p,fixed:f,axisColors:m,hoveredColor:h,opacity:y,onDragStart:x,onDrag:v,onDragEnd:g,userData:w}=i.useContext(D),b=(0,o.A)((t=>t.controls)),E=i.useRef(null),S=i.useRef(null),M=i.useRef(0),A=i.useRef(0),P=i.useRef(null),[C,z]=i.useState(!1),L=i.useCallback((t=>{l&&(E.current.innerText="".concat(k(A.current).toFixed(0),"\xba"),E.current.style.display="block"),t.stopPropagation();const e=t.point.clone(),n=(new a.Vector3).setFromMatrixPosition(S.current.matrixWorld),o=(new a.Vector3).setFromMatrixColumn(S.current.matrixWorld,0).normalize(),i=(new a.Vector3).setFromMatrixColumn(S.current.matrixWorld,1).normalize(),s=(new a.Vector3).setFromMatrixColumn(S.current.matrixWorld,2).normalize(),c=(new a.Plane).setFromNormalAndCoplanarPoint(s,n);P.current={clickPoint:e,origin:n,e1:o,e2:i,normal:s,plane:c},x({component:"Rotator",axis:r,origin:n,directions:[o,i,s]}),b&&(b.enabled=!1),t.target.setPointerCapture(t.pointerId)}),[l,b,x,r]),R=i.useCallback((t=>{if(t.stopPropagation(),C||z(!0),P.current){const{clickPoint:e,origin:n,e1:o,e2:i,normal:c,plane:u}=P.current,[d,p]=(null==s?void 0:s[r])||[void 0,void 0];G.copy(t.ray),G.intersectPlane(u,q),G.direction.negate(),G.intersectPlane(u,q);let f=((t,e,n,r,o)=>{F.copy(t).sub(n),I.copy(e).sub(n);const i=r.dot(r),a=o.dot(o),s=F.dot(r)/i,l=F.dot(o)/a,c=I.dot(r)/i,u=I.dot(o)/a,d=Math.atan2(l,s);return Math.atan2(u,c)-d})(e,q,n,o,i),m=k(f);t.shiftKey&&(m=10*Math.round(m/10),f=(t=>t*Math.PI/180)(m)),void 0!==d&&void 0!==p&&p-d<2*Math.PI?(f=j(f),f=f>Math.PI?f-2*Math.PI:f,f=a.MathUtils.clamp(f,d-M.current,p-M.current),A.current=M.current+f):(A.current=j(M.current+f),A.current=A.current>Math.PI?A.current-2*Math.PI:A.current),l&&(m=k(A.current),E.current.innerText="".concat(m.toFixed(0),"\xba")),H.makeRotationAxis(c,f),N.copy(n).applyMatrix4(H).sub(n).negate(),H.setPosition(N),v(H)}}),[l,v,C,s,r]),O=i.useCallback((t=>{l&&(E.current.style.display="none"),t.stopPropagation(),M.current=A.current,P.current=null,g(),b&&(b.enabled=!0),t.target.releasePointerCapture(t.pointerId)}),[l,b,g]),B=i.useCallback((t=>{t.stopPropagation(),z(!1)}),[]),U=i.useMemo((()=>{const t=e.clone().normalize(),r=n.clone().normalize();return(new a.Matrix4).makeBasis(t,r,t.clone().cross(r))}),[e,n]),V=f?.65:.65*d,W=i.useMemo((()=>{const t=[];for(let e=0;e<=32;e++){const n=e*(Math.PI/2)/32;t.push(new a.Vector3(Math.cos(n)*V,Math.sin(n)*V,0))}return t}),[V]);return i.createElement("group",{ref:S,onPointerDown:L,onPointerMove:R,onPointerUp:O,onPointerOut:B,matrix:U,matrixAutoUpdate:!1},l&&i.createElement(T.E,{position:[V,V,0]},i.createElement("div",{style:{display:"none",background:"#151520",color:"white",padding:"6px 8px",borderRadius:7,whiteSpace:"nowrap"},className:c,ref:E})),i.createElement(_,{points:W,lineWidth:4*p,visible:!1,userData:w}),i.createElement(_,{transparent:!0,raycast:()=>null,depthTest:u,points:W,lineWidth:p,color:C?h:m[r],opacity:y,polygonOffset:!0,polygonOffsetFactor:-10,fog:!1}))},X=new a.Ray,Z=new a.Vector3,J=new a.Matrix4,K=t=>{let{dir1:e,dir2:n,axis:r}=t;const{translation:s,translationLimits:l,annotations:c,annotationsClass:u,depthTest:d,scale:p,lineWidth:f,fixed:m,axisColors:h,hoveredColor:y,opacity:x,onDragStart:v,onDrag:g,onDragEnd:w,userData:b}=i.useContext(D),E=(0,o.A)((t=>t.controls)),S=i.useRef(null),M=i.useRef(null),A=i.useRef(null),P=i.useRef(0),C=i.useRef(0),[z,L]=i.useState(!1),R=i.useCallback((t=>{c&&(S.current.innerText="".concat(s.current[(r+1)%3].toFixed(2),", ").concat(s.current[(r+2)%3].toFixed(2)),S.current.style.display="block"),t.stopPropagation();const e=t.point.clone(),n=(new a.Vector3).setFromMatrixPosition(M.current.matrixWorld),o=(new a.Vector3).setFromMatrixColumn(M.current.matrixWorld,0).normalize(),i=(new a.Vector3).setFromMatrixColumn(M.current.matrixWorld,1).normalize(),l=(new a.Vector3).setFromMatrixColumn(M.current.matrixWorld,2).normalize(),u=(new a.Plane).setFromNormalAndCoplanarPoint(l,n);A.current={clickPoint:e,e1:o,e2:i,plane:u},P.current=s.current[(r+1)%3],C.current=s.current[(r+2)%3],v({component:"Slider",axis:r,origin:n,directions:[o,i,l]}),E&&(E.enabled=!1),t.target.setPointerCapture(t.pointerId)}),[c,E,v,r]),O=i.useCallback((t=>{if(t.stopPropagation(),z||L(!0),A.current){const{clickPoint:e,e1:n,e2:o,plane:i}=A.current,[a,u]=(null==l?void 0:l[(r+1)%3])||[void 0,void 0],[d,p]=(null==l?void 0:l[(r+2)%3])||[void 0,void 0];X.copy(t.ray),X.intersectPlane(i,Z),X.direction.negate(),X.intersectPlane(i,Z),Z.sub(e);let[f,m]=((t,e,n)=>{const r=Math.abs(t.x)>=Math.abs(t.y)&&Math.abs(t.x)>=Math.abs(t.z)?0:Math.abs(t.y)>=Math.abs(t.x)&&Math.abs(t.y)>=Math.abs(t.z)?1:2,o=[0,1,2].sort(((t,n)=>Math.abs(e.getComponent(n))-Math.abs(e.getComponent(t)))),i=r===o[0]?o[1]:o[0],a=t.getComponent(r),s=t.getComponent(i),l=e.getComponent(r),c=e.getComponent(i),u=n.getComponent(r),d=(n.getComponent(i)-u*(s/a))/(c-l*(s/a));return[(u-d*l)/a,d]})(n,o,Z);void 0!==a&&(f=Math.max(f,a-P.current)),void 0!==u&&(f=Math.min(f,u-P.current)),void 0!==d&&(m=Math.max(m,d-C.current)),void 0!==p&&(m=Math.min(m,p-C.current)),s.current[(r+1)%3]=P.current+f,s.current[(r+2)%3]=C.current+m,c&&(S.current.innerText="".concat(s.current[(r+1)%3].toFixed(2),", ").concat(s.current[(r+2)%3].toFixed(2))),J.makeTranslation(f*n.x+m*o.x,f*n.y+m*o.y,f*n.z+m*o.z),g(J)}}),[c,g,z,s,l,r]),B=i.useCallback((t=>{c&&(S.current.style.display="none"),t.stopPropagation(),A.current=null,w(),E&&(E.enabled=!0),t.target.releasePointerCapture(t.pointerId)}),[c,E,w]),U=i.useCallback((t=>{t.stopPropagation(),L(!1)}),[]),V=i.useMemo((()=>{const t=e.clone().normalize(),r=n.clone().normalize();return(new a.Matrix4).makeBasis(t,r,t.clone().cross(r))}),[e,n]),W=m?1/7:p/7,F=m?.225:.225*p,I=z?y:h[r],k=i.useMemo((()=>[new a.Vector3(0,0,0),new a.Vector3(0,F,0),new a.Vector3(F,F,0),new a.Vector3(F,0,0),new a.Vector3(0,0,0)]),[F]);return i.createElement("group",{ref:M,matrix:V,matrixAutoUpdate:!1},c&&i.createElement(T.E,{position:[0,0,0]},i.createElement("div",{style:{display:"none",background:"#151520",color:"white",padding:"6px 8px",borderRadius:7,whiteSpace:"nowrap"},className:u,ref:S})),i.createElement("group",{position:[1.7*W,1.7*W,0]},i.createElement("mesh",{visible:!0,onPointerDown:R,onPointerMove:O,onPointerUp:B,onPointerOut:U,scale:F,userData:b},i.createElement("planeGeometry",null),i.createElement("meshBasicMaterial",{transparent:!0,depthTest:d,color:I,polygonOffset:!0,polygonOffsetFactor:-10,side:a.DoubleSide,fog:!1})),i.createElement(_,{position:[-F/2,-F/2,0],transparent:!0,depthTest:d,points:k,lineWidth:f,color:I,opacity:x,polygonOffset:!0,polygonOffsetFactor:-10,userData:b,fog:!1})))},Y=new a.Vector3,$=new a.Vector3,tt=new a.Vector3,et=function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;const o=Y.set(t.x/n.width*2-1,-t.y/n.height*2+1,r);return o.unproject(e),o},nt=new a.Matrix4,rt=new a.Matrix4,ot=new a.Matrix4,it=new a.Matrix4,at=new a.Matrix4,st=new a.Matrix4,lt=new a.Matrix4,ct=new a.Matrix4,ut=new a.Box3,dt=new a.Box3,pt=new a.Vector3,ft=new a.Vector3,mt=new a.Vector3,ht=new a.Vector3,yt=new a.Vector3(1,0,0),xt=new a.Vector3(0,1,0),vt=new a.Vector3(0,0,1),gt=i.forwardRef(((t,e)=>{let{matrix:n,onDragStart:s,onDrag:l,onDragEnd:c,autoTransform:u=!0,anchor:d,disableAxes:p=!1,disableSliders:f=!1,disableRotations:m=!1,activeAxes:h=[!0,!0,!0],offset:y=[0,0,0],rotation:x=[0,0,0],scale:v=1,lineWidth:g=4,fixed:w=!1,translationLimits:b,rotationLimits:E,depthTest:S=!0,axisColors:M=["#ff2060","#20df80","#2080ff"],hoveredColor:A="#ffff40",annotations:P=!1,annotationsClass:C,opacity:z=1,visible:L=!0,userData:R,children:_,...T}=t;const O=(0,o.A)((t=>t.invalidate)),B=i.useRef(null),U=i.useRef(null),V=i.useRef(null),F=i.useRef(null),I=i.useRef([0,0,0]);i.useLayoutEffect((()=>{d&&(F.current.updateWorldMatrix(!0,!0),it.copy(F.current.matrixWorld).invert(),ut.makeEmpty(),F.current.traverse((t=>{t.geometry&&(t.geometry.boundingBox||t.geometry.computeBoundingBox(),st.copy(t.matrixWorld).premultiply(it),dt.copy(t.geometry.boundingBox),dt.applyMatrix4(st),ut.union(dt))})),pt.copy(ut.max).add(ut.min).multiplyScalar(.5),ft.copy(ut.max).sub(ut.min).multiplyScalar(.5),mt.copy(ft).multiply(new a.Vector3(...d)).add(pt),ht.set(...y).add(mt),V.current.position.copy(ht),O())}));const k=i.useMemo((()=>({onDragStart:t=>{nt.copy(U.current.matrix),rt.copy(U.current.matrixWorld),s&&s(t),O()},onDrag:t=>{ot.copy(B.current.matrixWorld),it.copy(ot).invert(),at.copy(rt).premultiply(t),st.copy(at).premultiply(it),lt.copy(nt).invert(),ct.copy(st).multiply(lt),u&&U.current.matrix.copy(st),l&&l(st,ct,at,t),O()},onDragEnd:()=>{c&&c(),O()},translation:I,translationLimits:b,rotationLimits:E,axisColors:M,hoveredColor:A,opacity:z,scale:v,lineWidth:g,fixed:w,depthTest:S,userData:R,annotations:P,annotationsClass:C})),[s,l,c,I,b,E,S,v,g,w,...M,A,z,R,u,P,C]),j=new a.Vector3;return(0,o.C)((t=>{if(w){const o=((t,e,n,r)=>{const o=((t,e,n)=>{const r=n.width/2,o=n.height/2;e.updateMatrixWorld(!1);const i=t.project(e);return i.x=i.x*r+r,i.y=-i.y*o+o,i})(tt.copy(t),n,r);let i=0;for(let a=0;a<2;++a){const s=$.copy(o).setComponent(a,o.getComponent(a)+e),l=et(s,n,r,s.z);i=Math.max(i,t.distanceTo(l))}return i})(V.current.getWorldPosition(j),v,t.camera,t.size);var e,n,r;if(V.current)(null==(e=V.current)?void 0:e.scale.x)===o&&(null==(n=V.current)?void 0:n.scale.y)===o&&(null==(r=V.current)?void 0:r.scale.z)===o||(V.current.scale.setScalar(o),t.invalidate())}})),i.useImperativeHandle(e,(()=>U.current),[]),i.useLayoutEffect((()=>{n&&n instanceof a.Matrix4&&(U.current.matrix=n)}),[n]),i.createElement(D.Provider,{value:k},i.createElement("group",{ref:B},i.createElement("group",(0,r.A)({ref:U,matrix:n,matrixAutoUpdate:!1},T),i.createElement("group",{visible:L,ref:V,position:y,rotation:x},!p&&h[0]&&i.createElement(W,{axis:0,direction:yt}),!p&&h[1]&&i.createElement(W,{axis:1,direction:xt}),!p&&h[2]&&i.createElement(W,{axis:2,direction:vt}),!f&&h[0]&&h[1]&&i.createElement(K,{axis:2,dir1:yt,dir2:xt}),!f&&h[0]&&h[2]&&i.createElement(K,{axis:1,dir1:vt,dir2:yt}),!f&&h[2]&&h[1]&&i.createElement(K,{axis:0,dir1:xt,dir2:vt}),!m&&h[0]&&h[1]&&i.createElement(Q,{axis:2,dir1:yt,dir2:xt}),!m&&h[0]&&h[2]&&i.createElement(Q,{axis:1,dir1:vt,dir2:yt}),!m&&h[2]&&h[1]&&i.createElement(Q,{axis:0,dir1:xt,dir2:vt})),i.createElement("group",{ref:F},_))))}))}}]);
//# sourceMappingURL=890.b754801d.chunk.js.map