"use strict";(self.webpackChunkdoor=self.webpackChunkdoor||[]).push([[285],{4569:(t,e,n)=>{n.d(e,{C6:()=>Cr,V2:()=>Ir,ZO:()=>Vr});var r=n(8168),i=n(5043),o=n(7551);const s=0,a=1,c=2,l=3,u=4,h=5,d=6;var f=n(9408);const p=0,m=1,g=2,y=2,x=1.25,v=1,w=65535,b=Math.pow(2,-24),M=Symbol("SKIP_GENERATION");function A(t){return function(t){return t.index?t.index.count:t.attributes.position.count}(t)/3}function B(t,e){if(!t.index){const n=t.attributes.position.count,r=function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ArrayBuffer;return t>65535?new Uint32Array(new e(4*t)):new Uint16Array(new e(2*t))}(n,e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer);t.setIndex(new f.BufferAttribute(r,1));for(let t=0;t<n;t++)r[t]=t}}function T(t){const e=A(t),n=t.drawRange,r=n.start/3,i=(n.start+n.count)/3,o=Math.max(0,r),s=Math.min(e,i)-o;return[{offset:Math.floor(o),count:Math.floor(s)}]}function S(t){if(!t.groups||!t.groups.length)return T(t);const e=[],n=new Set,r=t.drawRange,i=r.start/3,o=(r.start+r.count)/3;for(const a of t.groups){const t=a.start/3,e=(a.start+a.count)/3;n.add(Math.max(i,t)),n.add(Math.min(o,e))}const s=Array.from(n.values()).sort(((t,e)=>t-e));for(let a=0;a<s.length-1;a++){const t=s[a],n=s[a+1];e.push({offset:Math.floor(t),count:Math.floor(n-t)})}return e}function P(t,e,n){return n.min.x=e[t],n.min.y=e[t+1],n.min.z=e[t+2],n.max.x=e[t+3],n.max.y=e[t+4],n.max.z=e[t+5],n}function E(t){let e=-1,n=-1/0;for(let r=0;r<3;r++){const i=t[r+3]-t[r];i>n&&(n=i,e=r)}return e}function I(t,e){e.set(t)}function C(t,e,n){let r,i;for(let o=0;o<3;o++){const s=o+3;r=t[o],i=e[o],n[o]=r<i?r:i,r=t[s],i=e[s],n[s]=r>i?r:i}}function V(t,e,n){for(let r=0;r<3;r++){const i=e[t+2*r],o=e[t+2*r+1],s=i-o,a=i+o;s<n[r]&&(n[r]=s),a>n[r+3]&&(n[r+3]=a)}}function U(t){const e=t[3]-t[0],n=t[4]-t[1],r=t[5]-t[2];return 2*(e*n+n*r+r*e)}function _(t,e,n,r){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,o=1/0,s=1/0,a=1/0,c=-1/0,l=-1/0,u=-1/0,h=1/0,d=1/0,f=1/0,p=-1/0,m=-1/0,g=-1/0;const y=null!==i;for(let x=6*e,v=6*(e+n);x<v;x+=6){const e=t[x+0],n=t[x+1],r=e-n,i=e+n;r<o&&(o=r),i>c&&(c=i),y&&e<h&&(h=e),y&&e>p&&(p=e);const v=t[x+2],w=t[x+3],b=v-w,M=v+w;b<s&&(s=b),M>l&&(l=M),y&&v<d&&(d=v),y&&v>m&&(m=v);const A=t[x+4],B=t[x+5],T=A-B,S=A+B;T<a&&(a=T),S>u&&(u=S),y&&A<f&&(f=A),y&&A>g&&(g=A)}r[0]=o,r[1]=s,r[2]=a,r[3]=c,r[4]=l,r[5]=u,y&&(i[0]=h,i[1]=d,i[2]=f,i[3]=p,i[4]=m,i[5]=g)}const F=32,R=(t,e)=>t.candidate-e.candidate,z=new Array(F).fill().map((()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0}))),D=new Float32Array(6);class k{constructor(){}}function L(t,e,n,r,i,o){let s=r,a=r+i-1;const c=o.pos,l=2*o.axis;for(;;){for(;s<=a&&n[6*s+l]<c;)s++;for(;s<=a&&n[6*a+l]>=c;)a--;if(!(s<a))return s;for(let t=0;t<3;t++){let n=e[3*s+t];e[3*s+t]=e[3*a+t],e[3*a+t]=n}for(let t=0;t<6;t++){let e=n[6*s+t];n[6*s+t]=n[6*a+t],n[6*a+t]=e}s++,a--}}function O(t,e,n,r,i,o){let s=r,a=r+i-1;const c=o.pos,l=2*o.axis;for(;;){for(;s<=a&&n[6*s+l]<c;)s++;for(;s<=a&&n[6*a+l]>=c;)a--;if(!(s<a))return s;{let e=t[s];t[s]=t[a],t[a]=e;for(let t=0;t<6;t++){let e=n[6*s+t];n[6*s+t]=n[6*a+t],n[6*a+t]=e}s++,a--}}}function N(t,e){const n=t.geometry,r=n.index?n.index.array:null,i=e.maxDepth,o=e.verbose,s=e.maxLeafTris,a=e.strategy,c=e.onProgress,l=A(n),u=t._indirectBuffer;let h=!1;const d=new Float32Array(6),f=new Float32Array(6),y=function(t,e){var n;(n=e)[0]=n[1]=n[2]=1/0,n[3]=n[4]=n[5]=-1/0;const r=t.attributes.position,i=t.index?t.index.array:null,o=A(t),s=new Float32Array(6*o),a=r.normalized,c=r.array,l=r.offset||0;let u=3;r.isInterleavedBufferAttribute&&(u=r.data.stride);const h=["getX","getY","getZ"];for(let d=0;d<o;d++){const t=3*d,n=6*d;let o=t+0,f=t+1,p=t+2;i&&(o=i[o],f=i[f],p=i[p]),a||(o=o*u+l,f=f*u+l,p=p*u+l);for(let i=0;i<3;i++){let t,l,u;a?(t=r[h[i]](o),l=r[h[i]](f),u=r[h[i]](p)):(t=c[o+i],l=c[f+i],u=c[p+i]);let d=t;l<d&&(d=l),u<d&&(d=u);let m=t;l>m&&(m=l),u>m&&(m=u);const g=(m-d)/2,y=2*i;s[n+y+0]=d+g,s[n+y+1]=g+(Math.abs(d)+g)*b,d<e[i]&&(e[i]=d),m>e[i+3]&&(e[i+3]=m)}}return s}(n,d),w=e.indirect?O:L,M=[],B=e.indirect?T(n):S(n);if(1===B.length){const t=B[0],e=new k;e.boundingData=d,function(t,e,n,r){let i=1/0,o=1/0,s=1/0,a=-1/0,c=-1/0,l=-1/0;for(let u=6*e,h=6*(e+n);u<h;u+=6){const e=t[u+0];e<i&&(i=e),e>a&&(a=e);const n=t[u+2];n<o&&(o=n),n>c&&(c=n);const r=t[u+4];r<s&&(s=r),r>l&&(l=r)}r[0]=i,r[1]=o,r[2]=s,r[3]=a,r[4]=c,r[5]=l}(y,t.offset,t.count,f),N(e,t.offset,t.count,f),M.push(e)}else for(let p of B){const t=new k;t.boundingData=new Float32Array(6),_(y,p.offset,p.count,t.boundingData,f),N(t,p.offset,p.count,f),M.push(t)}return M;function P(t){c&&c(t/l)}function N(t,e,c){let l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,d=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;if(!h&&d>=i&&(h=!0,o&&(console.warn("MeshBVH: Max depth of ".concat(i," reached when generating BVH. Consider increasing maxDepth.")),console.warn(n))),c<=s||d>=i)return P(e+c),t.offset=e,t.count=c,t;const b=function(t,e,n,r,i,o){let s=-1,a=0;if(o===p)s=E(e),-1!==s&&(a=(e[s]+e[s+3])/2);else if(o===m)s=E(t),-1!==s&&(a=function(t,e,n,r){let i=0;for(let o=e,s=e+n;o<s;o++)i+=t[6*o+2*r];return i/n}(n,r,i,s));else if(o===g){const o=U(t);let c=x*i;const l=6*r,u=6*(r+i);for(let t=0;t<3;t++){const r=e[t],h=(e[t+3]-r)/F;if(i<F/4){const e=[...z];e.length=i;let r=0;for(let i=l;i<u;i+=6,r++){const o=e[r];o.candidate=n[i+2*t],o.count=0;const{bounds:s,leftCacheBounds:a,rightCacheBounds:c}=o;for(let t=0;t<3;t++)c[t]=1/0,c[t+3]=-1/0,a[t]=1/0,a[t+3]=-1/0,s[t]=1/0,s[t+3]=-1/0;V(i,n,s)}e.sort(R);let h=i;for(let t=0;t<h;t++){const n=e[t];for(;t+1<h&&e[t+1].candidate===n.candidate;)e.splice(t+1,1),h--}for(let i=l;i<u;i+=6){const r=n[i+2*t];for(let t=0;t<h;t++){const o=e[t];r>=o.candidate?V(i,n,o.rightCacheBounds):(V(i,n,o.leftCacheBounds),o.count++)}}for(let n=0;n<h;n++){const r=e[n],l=r.count,u=i-r.count,h=r.leftCacheBounds,d=r.rightCacheBounds;let f=0;0!==l&&(f=U(h)/o);let p=0;0!==u&&(p=U(d)/o);const m=v+x*(f*l+p*u);m<c&&(s=t,c=m,a=r.candidate)}}else{for(let t=0;t<F;t++){const e=z[t];e.count=0,e.candidate=r+h+t*h;const n=e.bounds;for(let t=0;t<3;t++)n[t]=1/0,n[t+3]=-1/0}for(let i=l;i<u;i+=6){let e=~~((n[i+2*t]-r)/h);e>=F&&(e=F-1);const o=z[e];o.count++,V(i,n,o.bounds)}const e=z[F-1];I(e.bounds,e.rightCacheBounds);for(let t=F-2;t>=0;t--){const e=z[t],n=z[t+1];C(e.bounds,n.rightCacheBounds,e.rightCacheBounds)}let d=0;for(let n=0;n<F-1;n++){const e=z[n],r=e.count,l=e.bounds,u=z[n+1].rightCacheBounds;0!==r&&(0===d?I(l,D):C(l,D,D)),d+=r;let h=0,f=0;0!==d&&(h=U(D)/o);const p=i-d;0!==p&&(f=U(u)/o);const m=v+x*(h*d+f*p);m<c&&(s=t,c=m,a=e.candidate)}}}}else console.warn("MeshBVH: Invalid build strategy value ".concat(o," used."));return{axis:s,pos:a}}(t.boundingData,l,y,e,c,a);if(-1===b.axis)return P(e+c),t.offset=e,t.count=c,t;const M=w(u,r,y,e,c,b);if(M===e||M===e+c)P(e+c),t.offset=e,t.count=c;else{t.splitAxis=b.axis;const n=new k,r=e,i=M-e;t.left=n,n.boundingData=new Float32Array(6),_(y,r,i,n.boundingData,f),N(n,r,i,f,d+1);const o=new k,s=M,a=c-i;t.right=o,o.boundingData=new Float32Array(6),_(y,s,a,o.boundingData,f),N(o,s,a,f,d+1)}return t}}function G(t,e){const n=t.geometry;e.indirect&&(t._indirectBuffer=function(t,e){const n=(t.index?t.index.count:t.attributes.position.count)/3,r=n>65536,i=r?4:2,o=e?new SharedArrayBuffer(n*i):new ArrayBuffer(n*i),s=r?new Uint32Array(o):new Uint16Array(o);for(let a=0,c=s.length;a<c;a++)s[a]=a;return s}(n,e.useSharedArrayBuffer),function(t){if(0===t.groups.length)return!1;const e=A(t),n=S(t).sort(((t,e)=>t.offset-e.offset)),r=n[n.length-1];r.count=Math.min(e-r.offset,r.count);let i=0;return n.forEach((t=>{let{count:e}=t;return i+=e})),e!==i}(n)&&!e.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),t._indirectBuffer||B(n,e);const r=N(t,e);let i,o,s;const a=[],c=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let h=0;h<r.length;h++){const t=r[h];const e=new c(32*l(t));i=new Float32Array(e),o=new Uint32Array(e),s=new Uint16Array(e),u(0,t),a.push(e)}return void(t._roots=a);function l(t){return t.count?1:1+l(t.left)+l(t.right)}function u(t,e){const n=t/4,r=t/2,a=!!e.count,c=e.boundingData;for(let o=0;o<6;o++)i[n+o]=c[o];if(a){const i=e.offset,a=e.count;return o[n+6]=i,s[r+14]=a,s[r+15]=w,t+32}{const r=e.left,i=e.right,s=e.splitAxis;let a;if(a=u(t+32,r),a/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return o[n+6]=a/4,a=u(a,i),o[n+7]=s,a}}}class j{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,r=-1/0;for(let i=0,o=t.length;i<o;i++){const o=t[i][e];n=o<n?o:n,r=o>r?o:r}this.min=n,this.max=r}setFromPoints(t,e){let n=1/0,r=-1/0;for(let i=0,o=e.length;i<o;i++){const o=e[i],s=t.dot(o);n=s<n?s:n,r=s>r?s:r}this.min=n,this.max=r}isSeparated(t){return this.min>t.max||t.min>this.max}}j.prototype.setFromBox=function(){const t=new f.Vector3;return function(e,n){const r=n.min,i=n.max;let o=1/0,s=-1/0;for(let a=0;a<=1;a++)for(let n=0;n<=1;n++)for(let c=0;c<=1;c++){t.x=r.x*a+i.x*(1-a),t.y=r.y*n+i.y*(1-n),t.z=r.z*c+i.z*(1-c);const l=e.dot(t);o=Math.min(l,o),s=Math.max(l,s)}this.min=o,this.max=s}}();!function(){const t=new j}();const H=function(){const t=new f.Vector3,e=new f.Vector3,n=new f.Vector3;return function(r,i,o){const s=r.start,a=t,c=i.start,l=e;n.subVectors(s,c),t.subVectors(r.end,r.start),e.subVectors(i.end,i.start);const u=n.dot(l),h=l.dot(a),d=l.dot(l),f=n.dot(a),p=a.dot(a)*d-h*h;let m,g;m=0!==p?(u*h-f*d)/p:0,g=(u+m*h)/d,o.x=m,o.y=g}}(),q=function(){const t=new f.Vector2,e=new f.Vector3,n=new f.Vector3;return function(r,i,o,s){H(r,i,t);let a=t.x,c=t.y;if(a>=0&&a<=1&&c>=0&&c<=1)return r.at(a,o),void i.at(c,s);if(a>=0&&a<=1)return c<0?i.at(0,s):i.at(1,s),void r.closestPointToPoint(s,!0,o);if(c>=0&&c<=1)return a<0?r.at(0,o):r.at(1,o),void i.closestPointToPoint(o,!0,s);{let t,l;t=a<0?r.start:r.end,l=c<0?i.start:i.end;const u=e,h=n;return r.closestPointToPoint(l,!0,e),i.closestPointToPoint(t,!0,n),u.distanceToSquared(l)<=h.distanceToSquared(t)?(o.copy(u),void s.copy(l)):(o.copy(t),void s.copy(h))}}}(),X=function(){const t=new f.Vector3,e=new f.Vector3,n=new f.Plane,r=new f.Line3;return function(i,o){const{radius:s,center:a}=i,{a:c,b:l,c:u}=o;r.start=c,r.end=l;if(r.closestPointToPoint(a,!0,t).distanceTo(a)<=s)return!0;r.start=c,r.end=u;if(r.closestPointToPoint(a,!0,t).distanceTo(a)<=s)return!0;r.start=l,r.end=u;if(r.closestPointToPoint(a,!0,t).distanceTo(a)<=s)return!0;const h=o.getPlane(n);if(Math.abs(h.distanceToPoint(a))<=s){const t=h.projectPoint(a,e);if(o.containsPoint(t))return!0}return!1}}();function W(t){return Math.abs(t)<1e-15}class Y extends f.Triangle{constructor(){super(...arguments),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map((()=>new f.Vector3)),this.satBounds=new Array(4).fill().map((()=>new j)),this.points=[this.a,this.b,this.c],this.sphere=new f.Sphere,this.plane=new f.Plane,this.needsUpdate=!0}intersectsSphere(t){return X(t,this)}update(){const t=this.a,e=this.b,n=this.c,r=this.points,i=this.satAxes,o=this.satBounds,s=i[0],a=o[0];this.getNormal(s),a.setFromPoints(s,r);const c=i[1],l=o[1];c.subVectors(t,e),l.setFromPoints(c,r);const u=i[2],h=o[2];u.subVectors(e,n),h.setFromPoints(u,r);const d=i[3],f=o[3];d.subVectors(n,t),f.setFromPoints(d,r),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(s,t),this.needsUpdate=!1}}Y.prototype.closestPointToSegment=function(){const t=new f.Vector3,e=new f.Vector3,n=new f.Line3;return function(r){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;const{start:s,end:a}=r,c=this.points;let l,u=1/0;for(let h=0;h<3;h++){const s=(h+1)%3;n.start.copy(c[h]),n.end.copy(c[s]),q(n,r,t,e),l=t.distanceToSquared(e),l<u&&(u=l,i&&i.copy(t),o&&o.copy(e))}return this.closestPointToPoint(s,t),l=s.distanceToSquared(t),l<u&&(u=l,i&&i.copy(t),o&&o.copy(s)),this.closestPointToPoint(a,t),l=a.distanceToSquared(t),l<u&&(u=l,i&&i.copy(t),o&&o.copy(a)),Math.sqrt(u)}}(),Y.prototype.intersectsTriangle=function(){const t=new Y,e=new Array(3),n=new Array(3),r=new j,i=new j,o=new f.Vector3,s=new f.Vector3,a=new f.Vector3,c=new f.Vector3,l=new f.Vector3,u=new f.Line3,h=new f.Line3,d=new f.Line3,p=new f.Vector3;function m(t,e,n){const r=t.points;let i=0,o=-1;for(let a=0;a<3;a++){const{start:t,end:c}=u;t.copy(r[a]),c.copy(r[(a+1)%3]),u.delta(s);const l=W(e.distanceToPoint(t));if(W(e.normal.dot(s))&&l){n.copy(u),i=2;break}const h=e.intersectLine(u,p);if(!h&&l&&p.copy(t),(h||l)&&!W(p.distanceTo(c))){if(i<=1){(1===i?n.start:n.end).copy(p),l&&(o=i)}else if(i>=2){(1===o?n.start:n.end).copy(p),i=2;break}if(i++,2===i&&-1===o)break}}return i}return function(s){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,f=arguments.length>2&&void 0!==arguments[2]&&arguments[2];this.needsUpdate&&this.update(),s.isExtendedTriangle?s.needsUpdate&&s.update():(t.copy(s),t.update(),s=t);const p=this.plane,g=s.plane;if(Math.abs(p.normal.dot(g.normal))>1-1e-10){const t=this.satBounds,a=this.satAxes;n[0]=s.a,n[1]=s.b,n[2]=s.c;for(let e=0;e<4;e++){const i=t[e],o=a[e];if(r.setFromPoints(o,n),i.isSeparated(r))return!1}const c=s.satBounds,l=s.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let n=0;n<4;n++){const t=c[n],i=l[n];if(r.setFromPoints(i,e),t.isSeparated(r))return!1}for(let s=0;s<4;s++){const t=a[s];for(let s=0;s<4;s++){const a=l[s];if(o.crossVectors(t,a),r.setFromPoints(o,e),i.setFromPoints(o,n),r.isSeparated(i))return!1}}return u&&(f||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),u.start.set(0,0,0),u.end.set(0,0,0)),!0}{const t=m(this,g,h);if(1===t&&s.containsPoint(h.end))return u&&(u.start.copy(h.end),u.end.copy(h.end)),!0;if(2!==t)return!1;const e=m(s,p,d);if(1===e&&this.containsPoint(d.end))return u&&(u.start.copy(d.end),u.end.copy(d.end)),!0;if(2!==e)return!1;if(h.delta(a),d.delta(c),a.dot(c)<0){let t=d.start;d.start=d.end,d.end=t}const n=h.start.dot(a),r=h.end.dot(a),i=d.start.dot(a),o=d.end.dot(a);return(n===o||i===r||r<i!==n<o)&&(u&&(l.subVectors(h.start,d.start),l.dot(a)>0?u.start.copy(h.start):u.start.copy(d.start),l.subVectors(h.end,d.end),l.dot(a)<0?u.end.copy(h.end):u.end.copy(d.end)),!0)}}}(),Y.prototype.distanceToPoint=function(){const t=new f.Vector3;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),Y.prototype.distanceToTriangle=function(){const t=new f.Vector3,e=new f.Vector3,n=["a","b","c"],r=new f.Line3,i=new f.Line3;return function(o){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;const c=s||a?r:null;if(this.intersectsTriangle(o,c))return(s||a)&&(s&&c.getCenter(s),a&&c.getCenter(a)),0;let l=1/0;for(let e=0;e<3;e++){let r;const i=n[e],c=o[i];this.closestPointToPoint(c,t),r=c.distanceToSquared(t),r<l&&(l=r,s&&s.copy(t),a&&a.copy(c));const u=this[i];o.closestPointToPoint(u,t),r=u.distanceToSquared(t),r<l&&(l=r,s&&s.copy(u),a&&a.copy(t))}for(let u=0;u<3;u++){const c=n[u],h=n[(u+1)%3];r.set(this[c],this[h]);for(let u=0;u<3;u++){const c=n[u],h=n[(u+1)%3];i.set(o[c],o[h]),q(r,i,t,e);const d=t.distanceToSquared(e);d<l&&(l=d,s&&s.copy(t),a&&a.copy(e))}}return Math.sqrt(l)}}();class Z{constructor(t,e,n){this.isOrientedBox=!0,this.min=new f.Vector3,this.max=new f.Vector3,this.matrix=new f.Matrix4,this.invMatrix=new f.Matrix4,this.points=new Array(8).fill().map((()=>new f.Vector3)),this.satAxes=new Array(3).fill().map((()=>new f.Vector3)),this.satBounds=new Array(3).fill().map((()=>new j)),this.alignedSatBounds=new Array(3).fill().map((()=>new j)),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),n&&this.matrix.copy(n)}set(t,e,n){this.min.copy(t),this.max.copy(e),this.matrix.copy(n),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}Z.prototype.update=function(){const t=this.matrix,e=this.min,n=this.max,r=this.points;for(let c=0;c<=1;c++)for(let i=0;i<=1;i++)for(let o=0;o<=1;o++){const s=r[1*c|2*i|4*o];s.x=c?n.x:e.x,s.y=i?n.y:e.y,s.z=o?n.z:e.z,s.applyMatrix4(t)}const i=this.satBounds,o=this.satAxes,s=r[0];for(let c=0;c<3;c++){const t=o[c],e=i[c],n=r[1<<c];t.subVectors(s,n),e.setFromPoints(t,r)}const a=this.alignedSatBounds;a[0].setFromPointsField(r,"x"),a[1].setFromPointsField(r,"y"),a[2].setFromPointsField(r,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1},Z.prototype.intersectsBox=function(){const t=new j;return function(e){this.needsUpdate&&this.update();const n=e.min,r=e.max,i=this.satBounds,o=this.satAxes,s=this.alignedSatBounds;if(t.min=n.x,t.max=r.x,s[0].isSeparated(t))return!1;if(t.min=n.y,t.max=r.y,s[1].isSeparated(t))return!1;if(t.min=n.z,t.max=r.z,s[2].isSeparated(t))return!1;for(let a=0;a<3;a++){const n=o[a],r=i[a];if(t.setFromBox(n,e),r.isSeparated(t))return!1}return!0}}(),Z.prototype.intersectsTriangle=function(){const t=new Y,e=new Array(3),n=new j,r=new j,i=new f.Vector3;return function(o){this.needsUpdate&&this.update(),o.isExtendedTriangle?o.needsUpdate&&o.update():(t.copy(o),t.update(),o=t);const s=this.satBounds,a=this.satAxes;e[0]=o.a,e[1]=o.b,e[2]=o.c;for(let t=0;t<3;t++){const r=s[t],i=a[t];if(n.setFromPoints(i,e),r.isSeparated(n))return!1}const c=o.satBounds,l=o.satAxes,u=this.points;for(let t=0;t<3;t++){const e=c[t],r=l[t];if(n.setFromPoints(r,u),e.isSeparated(n))return!1}for(let t=0;t<3;t++){const o=a[t];for(let t=0;t<4;t++){const s=l[t];if(i.crossVectors(o,s),n.setFromPoints(i,e),r.setFromPoints(i,u),n.isSeparated(r))return!1}}return!0}}(),Z.prototype.closestPointToPoint=function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e},Z.prototype.distanceToPoint=function(){const t=new f.Vector3;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),Z.prototype.distanceToBox=function(){const t=["x","y","z"],e=new Array(12).fill().map((()=>new f.Line3)),n=new Array(12).fill().map((()=>new f.Line3)),r=new f.Vector3,i=new f.Vector3;return function(o){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;if(this.needsUpdate&&this.update(),this.intersectsBox(o))return(a||c)&&(o.getCenter(i),this.closestPointToPoint(i,r),o.closestPointToPoint(r,i),a&&a.copy(r),c&&c.copy(i)),0;const l=s*s,u=o.min,h=o.max,d=this.points;let f=1/0;for(let t=0;t<8;t++){const e=d[t];i.copy(e).clamp(u,h);const n=e.distanceToSquared(i);if(n<f&&(f=n,a&&a.copy(e),c&&c.copy(i),n<l))return Math.sqrt(n)}let p=0;for(let r=0;r<3;r++)for(let i=0;i<=1;i++)for(let o=0;o<=1;o++){const s=(r+1)%3,a=(r+2)%3,c=1<<r|i<<s|o<<a,l=d[i<<s|o<<a],f=d[c];e[p].set(l,f);const m=t[r],g=t[s],y=t[a],x=n[p],v=x.start,w=x.end;v[m]=u[m],v[g]=i?u[g]:h[g],v[y]=o?u[y]:h[g],w[m]=h[m],w[g]=i?u[g]:h[g],w[y]=o?u[y]:h[g],p++}for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)for(let n=0;n<=1;n++){i.x=t?h.x:u.x,i.y=e?h.y:u.y,i.z=n?h.z:u.z,this.closestPointToPoint(i,r);const o=i.distanceToSquared(r);if(o<f&&(f=o,a&&a.copy(r),c&&c.copy(i),o<l))return Math.sqrt(o)}for(let t=0;t<12;t++){const o=e[t];for(let t=0;t<12;t++){const e=n[t];q(o,e,r,i);const s=r.distanceToSquared(i);if(s<f&&(f=s,a&&a.copy(r),c&&c.copy(i),s<l))return Math.sqrt(s)}}return Math.sqrt(f)}}();class K{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return 0===t.length?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class J extends K{constructor(){super((()=>new Y))}}const $=new J;function Q(t,e){return 65535===e[t+15]}function tt(t,e){return e[t+6]}function et(t,e){return e[t+14]}function nt(t){return t+8}function rt(t,e){return e[t+6]}function it(t,e){return e[t+7]}const ot=new class{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=n=>{e&&t.push(e),e=n,this.float32Array=new Float32Array(n),this.uint16Array=new Uint16Array(n),this.uint32Array=new Uint32Array(n)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,0!==t.length&&this.setBuffer(t.pop())}}};let st,at;const ct=[],lt=new K((()=>new f.Box3));function ut(t,e,n,r,i,o){st=lt.getPrimitive(),at=lt.getPrimitive(),ct.push(st,at),ot.setBuffer(t._roots[e]);const s=ht(0,t.geometry,n,r,i,o);ot.clearBuffer(),lt.releasePrimitive(st),lt.releasePrimitive(at),ct.pop(),ct.pop();const a=ct.length;return a>0&&(at=ct[a-1],st=ct[a-2]),s}function ht(t,e,n,r){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const{float32Array:a,uint16Array:c,uint32Array:l}=ot;let u=2*t;if(Q(u,c)){const h=tt(t,l),d=et(u,c);return P(t,a,st),r(h,d,!1,s,o+t,st)}{const f=nt(t),p=rt(t,l);let m,g,x,v,w=f,b=p;if(i&&(x=st,v=at,P(w,a,x),P(b,a,v),m=i(x),g=i(v),g<m)){w=p,b=f;const I=m;m=g,g=I,x=v}x||(x=st,P(w,a,x));const M=n(x,Q(2*w,c),m,s+1,o+w);let A;if(M===y){const C=S(w);A=r(C,E(w)-C,!0,s+1,o+w,x)}else A=M&&ht(w,e,n,r,i,o,s+1);if(A)return!0;v=at,P(b,a,v);const B=n(v,Q(2*b,c),g,s+1,o+b);let T;if(B===y){const V=S(b);T=r(V,E(b)-V,!0,s+1,o+b,v)}else T=B&&ht(b,e,n,r,i,o,s+1);return!!T;function S(t){const{uint16Array:e,uint32Array:n}=ot;let r=2*t;for(;!Q(r,e);)r=2*(t=nt(t));return tt(t,n)}function E(t){const{uint16Array:e,uint32Array:n}=ot;let r=2*t;for(;!Q(r,e);)r=2*(t=rt(t,n));return tt(t,n)+et(r,e)}}}const dt=new f.Vector3,ft=new f.Vector3;const pt=new f.Vector3,mt=new f.Vector3,gt=new f.Vector3,yt=new f.Vector2,xt=new f.Vector2,vt=new f.Vector2,wt=new f.Vector3,bt=new f.Vector3,Mt=new f.Vector3,At=new f.Vector3;function Bt(t,e,n,r,i,o,s,a,c){pt.fromBufferAttribute(e,o),mt.fromBufferAttribute(e,s),gt.fromBufferAttribute(e,a);const l=function(t,e,n,r,i,o){let s;return s=o===f.BackSide?t.intersectTriangle(r,n,e,!0,i):t.intersectTriangle(e,n,r,o!==f.DoubleSide,i),null===s?null:{distance:t.origin.distanceTo(i),point:i.clone()}}(t,pt,mt,gt,At,c);if(l){r&&(yt.fromBufferAttribute(r,o),xt.fromBufferAttribute(r,s),vt.fromBufferAttribute(r,a),l.uv=f.Triangle.getInterpolation(At,pt,mt,gt,yt,xt,vt,new f.Vector2)),i&&(yt.fromBufferAttribute(i,o),xt.fromBufferAttribute(i,s),vt.fromBufferAttribute(i,a),l.uv1=f.Triangle.getInterpolation(At,pt,mt,gt,yt,xt,vt,new f.Vector2)),n&&(wt.fromBufferAttribute(n,o),bt.fromBufferAttribute(n,s),Mt.fromBufferAttribute(n,a),l.normal=f.Triangle.getInterpolation(At,pt,mt,gt,wt,bt,Mt,new f.Vector3),l.normal.dot(t.direction)>0&&l.normal.multiplyScalar(-1));const e={a:o,b:s,c:a,normal:new f.Vector3,materialIndex:0};f.Triangle.getNormal(pt,mt,gt,e.normal),l.face=e,l.faceIndex=o}return l}function Tt(t,e,n,r,i){const o=3*r;let s=o+0,a=o+1,c=o+2;const l=t.index;t.index&&(s=l.getX(s),a=l.getX(a),c=l.getX(c));const{position:u,normal:h,uv:d,uv1:f}=t.attributes,p=Bt(n,u,h,d,f,s,a,c,e);return p?(p.faceIndex=r,i&&i.push(p),p):null}function St(t,e,n,r){const i=t.a,o=t.b,s=t.c;let a=e,c=e+1,l=e+2;n&&(a=n.getX(a),c=n.getX(c),l=n.getX(l)),i.x=r.getX(a),i.y=r.getY(a),i.z=r.getZ(a),o.x=r.getX(c),o.y=r.getY(c),o.z=r.getZ(c),s.x=r.getX(l),s.y=r.getY(l),s.z=r.getZ(l)}function Pt(t,e,n,r,i,o,s){const{geometry:a}=n,{index:c}=a,l=a.attributes.position;for(let u=t,h=e+t;u<h;u++){let t;if(t=u,St(s,3*t,c,l),s.needsUpdate=!0,r(s,t,i,o))return!0}return!1}function Et(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;e&&Array.isArray(e)&&(e=new Set(e));const n=t.geometry,r=n.index?n.index.array:null,i=n.attributes.position;let o,s,a,c,l=0;const u=t._roots;for(let d=0,f=u.length;d<f;d++)o=u[d],s=new Uint32Array(o),a=new Uint16Array(o),c=new Float32Array(o),h(0,l),l+=o.byteLength;function h(t,n){let o=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const l=2*t;if(a[l+15]===w){const e=s[t+6];let n=1/0,o=1/0,u=1/0,h=-1/0,d=-1/0,f=-1/0;for(let t=3*e,s=3*(e+a[l+14]);t<s;t++){let e=r[t];const s=i.getX(e),a=i.getY(e),c=i.getZ(e);s<n&&(n=s),s>h&&(h=s),a<o&&(o=a),a>d&&(d=a),c<u&&(u=c),c>f&&(f=c)}return(c[t+0]!==n||c[t+1]!==o||c[t+2]!==u||c[t+3]!==h||c[t+4]!==d||c[t+5]!==f)&&(c[t+0]=n,c[t+1]=o,c[t+2]=u,c[t+3]=h,c[t+4]=d,c[t+5]=f,!0)}{const r=t+8,i=s[t+6],a=r+n,l=i+n;let u=o,d=!1,f=!1;e?u||(d=e.has(a),f=e.has(l),u=!d&&!f):(d=!0,f=!0);const p=u||f;let m=!1;(u||d)&&(m=h(r,n,u));let g=!1;p&&(g=h(i,n,u));const y=m||g;if(y)for(let e=0;e<3;e++){const n=r+e,o=i+e,s=c[n],a=c[n+3],l=c[o],u=c[o+3];c[t+e]=s<l?s:l,c[t+e+3]=a>u?a:u}return y}}}const It=new f.Box3;function Ct(t,e,n,r){return P(t,e,It),n.intersectBox(It,r)}const Vt=new f.Vector3;function Ut(t,e,n,r,i){ot.setBuffer(t._roots[e]),_t(0,t,n,r,i),ot.clearBuffer()}function _t(t,e,n,r,i){const{float32Array:o,uint16Array:s,uint32Array:a}=ot,c=2*t;if(Q(c,s)){!function(t,e,n,r,i,o){const{geometry:s,_indirectBuffer:a}=t;for(let c=r,l=r+i;c<l;c++)Tt(s,e,n,c,o)}(e,n,r,tt(t,a),et(c,s),i)}else{const s=nt(t);Ct(s,o,r,Vt)&&_t(s,e,n,r,i);const c=rt(t,a);Ct(c,o,r,Vt)&&_t(c,e,n,r,i)}}const Ft=new f.Vector3,Rt=["x","y","z"];function zt(t,e,n,r){ot.setBuffer(t._roots[e]);const i=Dt(0,t,n,r);return ot.clearBuffer(),i}function Dt(t,e,n,r){const{float32Array:i,uint16Array:o,uint32Array:s}=ot;let a=2*t;if(Q(a,o)){return function(t,e,n,r,i){const{geometry:o,_indirectBuffer:s}=t;let a=1/0,c=null;for(let l=r,u=r+i;l<u;l++){let t;t=Tt(o,e,n,l),t&&t.distance<a&&(c=t,a=t.distance)}return c}(e,n,r,tt(t,s),et(a,o))}{const o=it(t,s),a=Rt[o],c=r.direction[a]>=0;let l,u;c?(l=nt(t),u=rt(t,s)):(l=rt(t,s),u=nt(t));const h=Ct(l,i,r,Ft)?Dt(l,e,n,r):null;if(h){const t=h.point[a];if(c?t<=i[u+o]:t>=i[u+o+3])return h}const d=Ct(u,i,r,Ft)?Dt(u,e,n,r):null;return h&&d?h.distance<=d.distance?h:d:h||d||null}}const kt=new f.Box3,Lt=new Y,Ot=new Y,Nt=new f.Matrix4,Gt=new Z,jt=new Z;function Ht(t,e,n,r){ot.setBuffer(t._roots[e]);const i=qt(0,t,n,r);return ot.clearBuffer(),i}function qt(t,e,n,r){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const{float32Array:o,uint16Array:s,uint32Array:a}=ot;let c=2*t;null===i&&(n.boundingBox||n.computeBoundingBox(),Gt.set(n.boundingBox.min,n.boundingBox.max,r),i=Gt);if(!Q(c,s)){const s=t+8,c=a[t+6];P(s,o,kt);if(i.intersectsBox(kt)&&qt(s,e,n,r,i))return!0;P(c,o,kt);return!!(i.intersectsBox(kt)&&qt(c,e,n,r,i))}{const i=e.geometry,l=i.index,u=i.attributes.position,h=n.index,d=n.attributes.position,f=tt(t,a),p=et(c,s);if(Nt.copy(r).invert(),n.boundsTree){P(t,o,jt),jt.matrix.copy(Nt),jt.needsUpdate=!0;return n.boundsTree.shapecast({intersectsBounds:t=>jt.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(r),t.b.applyMatrix4(r),t.c.applyMatrix4(r),t.needsUpdate=!0;for(let e=3*f,n=3*(p+f);e<n;e+=3)if(St(Ot,e,l,u),Ot.needsUpdate=!0,t.intersectsTriangle(Ot))return!0;return!1}})}for(let t=3*f,e=3*(p+f);t<e;t+=3){St(Lt,t,l,u),Lt.a.applyMatrix4(Nt),Lt.b.applyMatrix4(Nt),Lt.c.applyMatrix4(Nt),Lt.needsUpdate=!0;for(let t=0,e=h.count;t<e;t+=3)if(St(Ot,t,h,d),Ot.needsUpdate=!0,Lt.intersectsTriangle(Ot))return!0}}}const Xt=new f.Matrix4,Wt=new Z,Yt=new Z,Zt=new f.Vector3,Kt=new f.Vector3,Jt=new f.Vector3,$t=new f.Vector3;function Qt(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{},o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1/0;e.boundingBox||e.computeBoundingBox(),Wt.set(e.boundingBox.min,e.boundingBox.max,n),Wt.needsUpdate=!0;const a=t.geometry,c=a.attributes.position,l=a.index,u=e.attributes.position,h=e.index,d=$.getPrimitive(),f=$.getPrimitive();let p=Zt,m=Kt,g=null,y=null;i&&(g=Jt,y=$t);let x=1/0,v=null,w=null;return Xt.copy(n).invert(),Yt.matrix.copy(Xt),t.shapecast({boundsTraverseOrder:t=>Wt.distanceToBox(t),intersectsBounds:(t,e,n)=>n<x&&n<s&&(e&&(Yt.min.copy(t.min),Yt.max.copy(t.max),Yt.needsUpdate=!0),!0),intersectsRange:(t,r)=>{if(e.boundsTree){return e.boundsTree.shapecast({boundsTraverseOrder:t=>Yt.distanceToBox(t),intersectsBounds:(t,e,n)=>n<x&&n<s,intersectsRange:(e,i)=>{for(let s=e,a=e+i;s<a;s++){St(f,3*s,h,u),f.a.applyMatrix4(n),f.b.applyMatrix4(n),f.c.applyMatrix4(n),f.needsUpdate=!0;for(let e=t,n=t+r;e<n;e++){St(d,3*e,l,c),d.needsUpdate=!0;const t=d.distanceToTriangle(f,p,g);if(t<x&&(m.copy(p),y&&y.copy(g),x=t,v=e,w=s),t<o)return!0}}}})}for(let i=0,s=A(e);i<s;i++){St(f,3*i,h,u),f.a.applyMatrix4(n),f.b.applyMatrix4(n),f.c.applyMatrix4(n),f.needsUpdate=!0;for(let e=t,n=t+r;e<n;e++){St(d,3*e,l,c),d.needsUpdate=!0;const t=d.distanceToTriangle(f,p,g);if(t<x&&(m.copy(p),y&&y.copy(g),x=t,v=e,w=i),t<o)return!0}}}}),$.releasePrimitive(d),$.releasePrimitive(f),x===1/0?null:(r.point?r.point.copy(m):r.point=m.clone(),r.distance=x,r.faceIndex=v,i&&(i.point?i.point.copy(y):i.point=y.clone(),i.point.applyMatrix4(Xt),m.applyMatrix4(Xt),i.distance=m.sub(i.point).length(),i.faceIndex=w),r)}function te(t,e,n,r,i,o,s){const{geometry:a}=n,{index:c}=a,l=a.attributes.position;for(let u=t,h=e+t;u<h;u++){let t;if(t=n.resolveTriangleIndex(u),St(s,3*t,c,l),s.needsUpdate=!0,r(s,t,i,o))return!0}return!1}function ee(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;e&&Array.isArray(e)&&(e=new Set(e));const n=t.geometry,r=n.index?n.index.array:null,i=n.attributes.position;let o,s,a,c,l=0;const u=t._roots;for(let d=0,f=u.length;d<f;d++)o=u[d],s=new Uint32Array(o),a=new Uint16Array(o),c=new Float32Array(o),h(0,l),l+=o.byteLength;function h(n,o){let l=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const u=2*n;if(a[u+15]===w){const e=s[n+6];let o=1/0,l=1/0,h=1/0,d=-1/0,f=-1/0,p=-1/0;for(let n=e,s=e+a[u+14];n<s;n++){const e=3*t.resolveTriangleIndex(n);for(let t=0;t<3;t++){let n=e+t;n=r?r[n]:n;const s=i.getX(n),a=i.getY(n),c=i.getZ(n);s<o&&(o=s),s>d&&(d=s),a<l&&(l=a),a>f&&(f=a),c<h&&(h=c),c>p&&(p=c)}}return(c[n+0]!==o||c[n+1]!==l||c[n+2]!==h||c[n+3]!==d||c[n+4]!==f||c[n+5]!==p)&&(c[n+0]=o,c[n+1]=l,c[n+2]=h,c[n+3]=d,c[n+4]=f,c[n+5]=p,!0)}{const t=n+8,r=s[n+6],i=t+o,a=r+o;let u=l,d=!1,f=!1;e?u||(d=e.has(i),f=e.has(a),u=!d&&!f):(d=!0,f=!0);const p=u||f;let m=!1;(u||d)&&(m=h(t,o,u));let g=!1;p&&(g=h(r,o,u));const y=m||g;if(y)for(let e=0;e<3;e++){const i=t+e,o=r+e,s=c[i],a=c[i+3],l=c[o],u=c[o+3];c[n+e]=s<l?s:l,c[n+e+3]=a>u?a:u}return y}}}const ne=new f.Vector3;function re(t,e,n,r,i){ot.setBuffer(t._roots[e]),ie(0,t,n,r,i),ot.clearBuffer()}function ie(t,e,n,r,i){const{float32Array:o,uint16Array:s,uint32Array:a}=ot,c=2*t;if(Q(c,s)){!function(t,e,n,r,i,o){const{geometry:s,_indirectBuffer:a}=t;for(let c=r,l=r+i;c<l;c++)Tt(s,e,n,a?a[c]:c,o)}(e,n,r,tt(t,a),et(c,s),i)}else{const s=nt(t);Ct(s,o,r,ne)&&ie(s,e,n,r,i);const c=rt(t,a);Ct(c,o,r,ne)&&ie(c,e,n,r,i)}}const oe=new f.Vector3,se=["x","y","z"];function ae(t,e,n,r){ot.setBuffer(t._roots[e]);const i=ce(0,t,n,r);return ot.clearBuffer(),i}function ce(t,e,n,r){const{float32Array:i,uint16Array:o,uint32Array:s}=ot;let a=2*t;if(Q(a,o)){return function(t,e,n,r,i){const{geometry:o,_indirectBuffer:s}=t;let a=1/0,c=null;for(let l=r,u=r+i;l<u;l++){let t;t=Tt(o,e,n,s?s[l]:l),t&&t.distance<a&&(c=t,a=t.distance)}return c}(e,n,r,tt(t,s),et(a,o))}{const o=it(t,s),a=se[o],c=r.direction[a]>=0;let l,u;c?(l=nt(t),u=rt(t,s)):(l=rt(t,s),u=nt(t));const h=Ct(l,i,r,oe)?ce(l,e,n,r):null;if(h){const t=h.point[a];if(c?t<=i[u+o]:t>=i[u+o+3])return h}const d=Ct(u,i,r,oe)?ce(u,e,n,r):null;return h&&d?h.distance<=d.distance?h:d:h||d||null}}const le=new f.Box3,ue=new Y,he=new Y,de=new f.Matrix4,fe=new Z,pe=new Z;function me(t,e,n,r){ot.setBuffer(t._roots[e]);const i=ge(0,t,n,r);return ot.clearBuffer(),i}function ge(t,e,n,r){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const{float32Array:o,uint16Array:s,uint32Array:a}=ot;let c=2*t;null===i&&(n.boundingBox||n.computeBoundingBox(),fe.set(n.boundingBox.min,n.boundingBox.max,r),i=fe);if(!Q(c,s)){const s=t+8,c=a[t+6];P(s,o,le);if(i.intersectsBox(le)&&ge(s,e,n,r,i))return!0;P(c,o,le);return!!(i.intersectsBox(le)&&ge(c,e,n,r,i))}{const i=e.geometry,l=i.index,u=i.attributes.position,h=n.index,d=n.attributes.position,f=tt(t,a),p=et(c,s);if(de.copy(r).invert(),n.boundsTree){P(t,o,pe),pe.matrix.copy(de),pe.needsUpdate=!0;return n.boundsTree.shapecast({intersectsBounds:t=>pe.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(r),t.b.applyMatrix4(r),t.c.applyMatrix4(r),t.needsUpdate=!0;for(let n=f,r=p+f;n<r;n++)if(St(he,3*e.resolveTriangleIndex(n),l,u),he.needsUpdate=!0,t.intersectsTriangle(he))return!0;return!1}})}for(let t=f,n=p+f;t<n;t++){const n=e.resolveTriangleIndex(t);St(ue,3*n,l,u),ue.a.applyMatrix4(de),ue.b.applyMatrix4(de),ue.c.applyMatrix4(de),ue.needsUpdate=!0;for(let t=0,e=h.count;t<e;t+=3)if(St(he,t,h,d),he.needsUpdate=!0,ue.intersectsTriangle(he))return!0}}}const ye=new f.Matrix4,xe=new Z,ve=new Z,we=new f.Vector3,be=new f.Vector3,Me=new f.Vector3,Ae=new f.Vector3;function Be(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{},o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1/0;e.boundingBox||e.computeBoundingBox(),xe.set(e.boundingBox.min,e.boundingBox.max,n),xe.needsUpdate=!0;const a=t.geometry,c=a.attributes.position,l=a.index,u=e.attributes.position,h=e.index,d=$.getPrimitive(),f=$.getPrimitive();let p=we,m=be,g=null,y=null;i&&(g=Me,y=Ae);let x=1/0,v=null,w=null;return ye.copy(n).invert(),ve.matrix.copy(ye),t.shapecast({boundsTraverseOrder:t=>xe.distanceToBox(t),intersectsBounds:(t,e,n)=>n<x&&n<s&&(e&&(ve.min.copy(t.min),ve.max.copy(t.max),ve.needsUpdate=!0),!0),intersectsRange:(r,i)=>{if(e.boundsTree){const a=e.boundsTree;return a.shapecast({boundsTraverseOrder:t=>ve.distanceToBox(t),intersectsBounds:(t,e,n)=>n<x&&n<s,intersectsRange:(e,s)=>{for(let b=e,M=e+s;b<M;b++){const e=a.resolveTriangleIndex(b);St(f,3*e,h,u),f.a.applyMatrix4(n),f.b.applyMatrix4(n),f.c.applyMatrix4(n),f.needsUpdate=!0;for(let n=r,s=r+i;n<s;n++){const e=t.resolveTriangleIndex(n);St(d,3*e,l,c),d.needsUpdate=!0;const r=d.distanceToTriangle(f,p,g);if(r<x&&(m.copy(p),y&&y.copy(g),x=r,v=n,w=b),r<o)return!0}}}})}for(let s=0,a=A(e);s<a;s++){St(f,3*s,h,u),f.a.applyMatrix4(n),f.b.applyMatrix4(n),f.c.applyMatrix4(n),f.needsUpdate=!0;for(let e=r,n=r+i;e<n;e++){const n=t.resolveTriangleIndex(e);St(d,3*n,l,c),d.needsUpdate=!0;const r=d.distanceToTriangle(f,p,g);if(r<x&&(m.copy(p),y&&y.copy(g),x=r,v=e,w=s),r<o)return!0}}}}),$.releasePrimitive(d),$.releasePrimitive(f),x===1/0?null:(r.point?r.point.copy(m):r.point=m.clone(),r.distance=x,r.faceIndex=v,i&&(i.point?i.point.copy(y):i.point=y.clone(),i.point.applyMatrix4(ye),m.applyMatrix4(ye),i.distance=m.sub(i.point).length(),i.faceIndex=w),r)}const Te=new ot.constructor,Se=new ot.constructor,Pe=new K((()=>new f.Box3)),Ee=new f.Box3,Ie=new f.Box3,Ce=new f.Box3,Ve=new f.Box3;let Ue=!1;function _e(t,e,n,r,i){let o,s,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,c=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,l=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,u=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0,h=arguments.length>9&&void 0!==arguments[9]?arguments[9]:null,d=arguments.length>10&&void 0!==arguments[10]&&arguments[10];d?(o=Se,s=Te):(o=Te,s=Se);const f=o.float32Array,p=o.uint32Array,m=o.uint16Array,g=s.float32Array,y=s.uint32Array,x=s.uint16Array,v=2*e,w=Q(2*t,m),b=Q(v,x);let M=!1;if(b&&w)M=d?i(tt(e,y),et(2*e,x),tt(t,p),et(2*t,m),u,c+e,l,a+t):i(tt(t,p),et(2*t,m),tt(e,y),et(2*e,x),l,a+t,u,c+e);else if(b){const o=Pe.getPrimitive();P(e,g,o),o.applyMatrix4(n);const s=nt(t),h=rt(t,p);P(s,f,Ee),P(h,f,Ie);const m=o.intersectsBox(Ee),y=o.intersectsBox(Ie);M=m&&_e(e,s,r,n,i,c,a,u,l+1,o,!d)||y&&_e(e,h,r,n,i,c,a,u,l+1,o,!d),Pe.releasePrimitive(o)}else{const o=nt(e),s=rt(e,y);P(o,g,Ce),P(s,g,Ve);const m=h.intersectsBox(Ce),x=h.intersectsBox(Ve);if(m&&x)M=_e(t,o,n,r,i,a,c,l,u+1,h,d)||_e(t,s,n,r,i,a,c,l,u+1,h,d);else if(m)if(w)M=_e(t,o,n,r,i,a,c,l,u+1,h,d);else{const e=Pe.getPrimitive();e.copy(Ce).applyMatrix4(n);const s=nt(t),h=rt(t,p);P(s,f,Ee),P(h,f,Ie);const m=e.intersectsBox(Ee),g=e.intersectsBox(Ie);M=m&&_e(o,s,r,n,i,c,a,u,l+1,e,!d)||g&&_e(o,h,r,n,i,c,a,u,l+1,e,!d),Pe.releasePrimitive(e)}else if(x)if(w)M=_e(t,s,n,r,i,a,c,l,u+1,h,d);else{const e=Pe.getPrimitive();e.copy(Ve).applyMatrix4(n);const o=nt(t),h=rt(t,p);P(o,f,Ee),P(h,f,Ie);const m=e.intersectsBox(Ee),g=e.intersectsBox(Ie);M=m&&_e(s,o,r,n,i,c,a,u,l+1,e,!d)||g&&_e(s,h,r,n,i,c,a,u,l+1,e,!d),Pe.releasePrimitive(e)}}return M}const Fe=new Z,Re=new f.Box3;class ze{static serialize(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};e={cloneBuffers:!0,...e};const n=t.geometry,r=t._roots,i=t._indirectBuffer,o=n.getIndex();let s;return s=e.cloneBuffers?{roots:r.map((t=>t.slice())),index:o.array.slice(),indirectBuffer:i?i.slice():null}:{roots:r,index:o.array,indirectBuffer:i},s}static deserialize(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};n={setIndex:!0,indirect:Boolean(t.indirectBuffer),...n};const{index:r,roots:i,indirectBuffer:o}=t,s=new ze(e,{...n,[M]:!0});if(s._roots=i,s._indirectBuffer=o||null,n.setIndex){const n=e.getIndex();if(null===n){const n=new f.BufferAttribute(t.index,1,!1);e.setIndex(n)}else n.array!==r&&(n.array.set(r),n.needsUpdate=!0)}return s}get indirect(){return!!this._indirectBuffer}constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!t.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");if(e=Object.assign({strategy:p,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,[M]:!1},e),e.useSharedArrayBuffer&&"undefined"===typeof SharedArrayBuffer)throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[M]||(G(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new f.Box3)));const{_indirectBuffer:n}=this;this.resolveTriangleIndex=e.indirect?t=>n[t]:t=>t}refit(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;return(this.indirect?ee:Et)(this,t)}traverse(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=this._roots[e],r=new Uint32Array(n),i=new Uint16Array(n);!function e(o){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const a=2*o,c=i[a+15]===w;if(c){const e=r[o+6],l=i[a+14];t(s,c,new Float32Array(n,4*o,6),e,l)}else{const i=o+8,a=r[o+6],l=r[o+7];t(s,c,new Float32Array(n,4*o,6),l)||(e(i,s+1),e(a,s+1))}}(0)}raycast(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:f.FrontSide;const n=this._roots,r=this.geometry,i=[],o=e.isMaterial,s=Array.isArray(e),a=r.groups,c=o?e.side:e,l=this.indirect?re:Ut;for(let u=0,h=n.length;u<h;u++){const n=s?e[a[u].materialIndex].side:c,r=i.length;if(l(this,u,n,t,i),s){const t=a[u].materialIndex;for(let e=r,n=i.length;e<n;e++)i[e].face.materialIndex=t}}return i}raycastFirst(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:f.FrontSide;const n=this._roots,r=this.geometry,i=e.isMaterial,o=Array.isArray(e);let s=null;const a=r.groups,c=i?e.side:e,l=this.indirect?ae:zt;for(let u=0,h=n.length;u<h;u++){const n=l(this,u,o?e[a[u].materialIndex].side:c,t);null!=n&&(null==s||n.distance<s.distance)&&(s=n,o&&(n.face.materialIndex=a[u].materialIndex))}return s}intersectsGeometry(t,e){let n=!1;const r=this._roots,i=this.indirect?me:Ht;for(let o=0,s=r.length;o<s&&(n=i(this,o,t,e),!n);o++);return n}shapecast(t){const e=$.getPrimitive(),n=this.indirect?te:Pt;let{boundsTraverseOrder:r,intersectsBounds:i,intersectsRange:o,intersectsTriangle:s}=t;if(o&&s){const t=o;o=(r,i,o,a,c)=>!!t(r,i,o,a,c)||n(r,i,this,s,o,a,e)}else o||(o=s?(t,r,i,o)=>n(t,r,this,s,i,o,e):(t,e,n)=>n);let a=!1,c=0;const l=this._roots;for(let u=0,h=l.length;u<h;u++){const t=l[u];if(a=ut(this,u,i,o,r,c),a)break;c+=t.byteLength}return $.releasePrimitive(e),a}bvhcast(t,e,n){let{intersectsRanges:r,intersectsTriangles:i}=n;const o=$.getPrimitive(),s=this.geometry.index,a=this.geometry.attributes.position,c=this.indirect?t=>{const e=this.resolveTriangleIndex(t);St(o,3*e,s,a)}:t=>{St(o,3*t,s,a)},l=$.getPrimitive(),u=t.geometry.index,h=t.geometry.attributes.position,d=t.indirect?e=>{const n=t.resolveTriangleIndex(e);St(l,3*n,u,h)}:t=>{St(l,3*t,u,h)};if(i){const t=(t,n,r,s,a,u,h,f)=>{for(let p=r,m=r+s;p<m;p++){d(p),l.a.applyMatrix4(e),l.b.applyMatrix4(e),l.c.applyMatrix4(e),l.needsUpdate=!0;for(let e=t,r=t+n;e<r;e++)if(c(e),o.needsUpdate=!0,i(o,l,e,p,a,u,h,f))return!0}return!1};if(r){const e=r;r=function(n,r,i,o,s,a,c,l){return!!e(n,r,i,o,s,a,c,l)||t(n,r,i,o,s,a,c,l)}}else r=t}return function(t,e,n,r){if(Ue)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Ue=!0;const i=t._roots,o=e._roots;let s,a=0,c=0;const l=(new f.Matrix4).copy(n).invert();for(let u=0,h=i.length;u<h;u++){Te.setBuffer(i[u]),c=0;const t=Pe.getPrimitive();P(0,Te.float32Array,t),t.applyMatrix4(l);for(let e=0,i=o.length;e<i&&(Se.setBuffer(o[u]),s=_e(0,0,n,l,r,a,c,0,0,t),Se.clearBuffer(),c+=o[e].length,!s);e++);if(Pe.releasePrimitive(t),Te.clearBuffer(),a+=i[u].length,s)break}return Ue=!1,s}(this,t,e,r)}intersectsBox(t,e){return Fe.set(t.min,t.max,e),Fe.needsUpdate=!0,this.shapecast({intersectsBounds:t=>Fe.intersectsBox(t),intersectsTriangle:t=>Fe.intersectsTriangle(t)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1/0;return(this.indirect?Be:Qt)(this,t,e,n,r,i,o)}closestPointToPoint(t){return function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1/0;const o=r*r,s=i*i;let a=1/0,c=null;if(t.shapecast({boundsTraverseOrder:t=>(dt.copy(e).clamp(t.min,t.max),dt.distanceToSquared(e)),intersectsBounds:(t,e,n)=>n<a&&n<s,intersectsTriangle:(t,n)=>{t.closestPointToPoint(e,dt);const r=e.distanceToSquared(dt);return r<a&&(ft.copy(dt),a=r,c=n),r<o}}),a===1/0)return null;const l=Math.sqrt(a);return n.point?n.point.copy(ft):n.point=ft.clone(),n.distance=l,n.faceIndex=c,n}(this,t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0)}getBoundingBox(t){t.makeEmpty();return this._roots.forEach((e=>{P(0,new Float32Array(e),Re),t.union(Re)})),t}}const De=1e-6,ke=Math.pow(10,-Math.log10(De)),Le=5e-7*ke;function Oe(t){return~~(t*ke+Le)}function Ne(t){return"".concat(Oe(t.x),",").concat(Oe(t.y),",").concat(Oe(t.z))}function Ge(t){return"".concat(Oe(t.x),",").concat(Oe(t.y),",").concat(Oe(t.z),",").concat(Oe(t.w))}function je(t,e,n){n.direction.subVectors(e,t).normalize();const r=t.dot(n.direction);return n.origin.copy(t).addScaledVector(n.direction,-r),n}function He(){return"undefined"!==typeof SharedArrayBuffer}function qe(t){if(t.buffer instanceof SharedArrayBuffer)return t;const e=t.constructor,n=t.buffer,r=new SharedArrayBuffer(n.byteLength),i=new Uint8Array(n);return new Uint8Array(r).set(i,0),new e(r)}function Xe(t,e){if(!t.index){const n=t.attributes.position.count,r=function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ArrayBuffer;return t>65535?new Uint32Array(new e(4*t)):new Uint16Array(new e(2*t))}(n,e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer);t.setIndex(new f.BufferAttribute(r,1));for(let t=0;t<n;t++)r[t]=t}}function We(t){return function(t){return t.index?t.index.count:t.attributes.position.count}(t)/3}const Ye=1e-8,Ze=new f.Vector3;function Ke(t){return t%3}function Je(t,e){return t.start-e.start}function $e(t,e){return Ze.subVectors(e,t.origin).dot(t.direction)}const Qe=1e-5,tn=1e-4;class en{constructor(){this._rays=[]}addRay(t){this._rays.push(t)}findClosestRay(t){const e=this._rays,n=t.clone();n.direction.multiplyScalar(-1);let r=1/0,i=null;for(let a=0,c=e.length;a<c;a++){const c=e[a];if(o(c,t)&&o(c,n))continue;const l=s(c,t),u=s(c,n),h=Math.min(l,u);h<r&&(r=h,i=c)}return i;function o(t,e){const n=t.origin.distanceTo(e.origin)>Qe;return t.direction.angleTo(e.direction)>tn||n}function s(t,e){const n=t.origin.distanceTo(e.origin),r=t.direction.angleTo(e.direction);return n/Qe+r/tn}}}const nn=new f.Vector3,rn=new f.Vector3,on=new f.Ray;function sn(t,e,n){const r=t.attributes,i=t.index,o=r.position,s=new Map,a=new Map,c=Array.from(e),l=new en;for(let u=0,h=c.length;u<h;u++){const t=c[u],e=~~(t/3),n=Ke(t);let r,s=3*e+n,h=3*e+(n+1)%3;i&&(s=i.getX(s),h=i.getX(h)),nn.fromBufferAttribute(o,s),rn.fromBufferAttribute(o,h),je(nn,rn,on);let d=l.findClosestRay(on);null===d&&(d=on.clone(),l.addRay(d)),a.has(d)||a.set(d,{forward:[],reverse:[],ray:d}),r=a.get(d);let f=$e(d,nn),p=$e(d,rn);f>p&&([f,p]=[p,f]),on.direction.dot(d.direction)<0?r.reverse.push({start:f,end:p,index:t}):r.forward.push({start:f,end:p,index:t})}return a.forEach(((t,e)=>{let{forward:r,reverse:i}=t;!function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Ye;t.sort(Je),e.sort(Je);for(let a=0;a<t.length;a++){const r=t[a];for(let i=0;i<e.length;i++){const c=e[i];if(c.start>r.end);else{if(r.end<c.start||c.end<r.start)continue;if(r.start<=c.start&&r.end>=c.end)o(c.end,r.end)||t.splice(a+1,0,{start:c.end,end:r.end,index:r.index}),r.end=c.start,c.start=0,c.end=0;else if(r.start>=c.start&&r.end<=c.end)o(r.end,c.end)||e.splice(i+1,0,{start:r.end,end:c.end,index:c.index}),c.end=r.start,r.start=0,r.end=0;else if(r.start<=c.start&&r.end<=c.end){const t=r.end;r.end=c.start,c.start=t}else{if(!(r.start>=c.start&&r.end>=c.end))throw new Error;{const t=c.end;c.end=r.start,r.start=t}}}if(n.has(r.index)||n.set(r.index,[]),n.has(c.index)||n.set(c.index,[]),n.get(r.index).push(c.index),n.get(c.index).push(r.index),s(c)&&(e.splice(i,1),i--),s(r)){t.splice(a,1),a--;break}}}function i(t){for(let e=0;e<t.length;e++)s(t[e])&&(t.splice(e,1),e--)}function o(t,e){return Math.abs(e-t)<r}function s(t){return Math.abs(t.end-t.start)<r}i(t),i(e)}(r,i,s,n),0===r.length&&0===i.length&&a.delete(e)})),{disjointConnectivityMap:s,fragmentMap:a}}const an=new f.Vector2,cn=new f.Vector3,ln=new f.Vector4,un=["","",""];class hn{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;this.data=null,this.disjointConnections=null,this.unmatchedDisjointEdges=null,this.unmatchedEdges=-1,this.matchedEdges=-1,this.useDrawRange=!0,this.useAllAttributes=!1,this.matchDisjointEdges=!1,this.degenerateEpsilon=1e-8,t&&this.updateFrom(t)}getSiblingTriangleIndex(t,e){const n=this.data[3*t+e];return-1===n?-1:~~(n/3)}getSiblingEdgeIndex(t,e){const n=this.data[3*t+e];return-1===n?-1:n%3}getDisjointSiblingTriangleIndices(t,e){const n=3*t+e,r=this.disjointConnections.get(n);return r?r.map((t=>~~(t/3))):[]}getDisjointSiblingEdgeIndices(t,e){const n=3*t+e,r=this.disjointConnections.get(n);return r?r.map((t=>t%3)):[]}isFullyConnected(){return 0===this.unmatchedEdges}updateFrom(t){const{useAllAttributes:e,useDrawRange:n,matchDisjointEdges:r,degenerateEpsilon:i}=this,o=e?function(t){let e="";for(let r=0,i=c.length;r<i;r++){const i=a[c[r]];let o;switch(i.itemSize){case 1:o=Oe(i.getX(t));break;case 2:n=an.fromBufferAttribute(i,t),o="".concat(Oe(n.x),",").concat(Oe(n.y));break;case 3:o=Ne(cn.fromBufferAttribute(i,t));break;case 4:o=Ge(ln.fromBufferAttribute(i,t))}""!==e&&(e+="|"),e+=o}var n;return e}:function(t){return cn.fromBufferAttribute(u,t),Ne(cn)},s=new Map,{attributes:a}=t,c=e?Object.keys(a):null,l=t.index,u=a.position;let h=We(t);const d=h;let f=0;n&&(f=t.drawRange.start,t.drawRange.count!==1/0&&(h=~~(t.drawRange.count/3)));let p=this.data;(!p||p.length<3*d)&&(p=new Int32Array(3*d)),p.fill(-1);let m=0,g=new Set;for(let y=f,x=3*h+f;y<x;y+=3){const t=y;for(let e=0;e<3;e++){let n=t+e;l&&(n=l.getX(n)),un[e]=o(n)}for(let e=0;e<3;e++){const n=(e+1)%3,r=un[e],i=un[n],o="".concat(i,"_").concat(r);if(s.has(o)){const n=t+e,r=s.get(o);p[n]=r,p[r]=n,s.delete(o),m+=2,g.delete(r)}else{const n="".concat(r,"_").concat(i),o=t+e;s.set(n,o),g.add(o)}}}if(r){const{fragmentMap:e,disjointConnectivityMap:n}=sn(t,g,i);g.clear(),e.forEach((t=>{let{forward:e,reverse:n}=t;e.forEach((t=>{let{index:e}=t;return g.add(e)})),n.forEach((t=>{let{index:e}=t;return g.add(e)}))})),this.unmatchedDisjointEdges=e,this.disjointConnections=n,m=3*h-g.size}this.matchedEdges=m,this.unmatchedEdges=g.size,this.data=p}}class dn extends f.Mesh{constructor(){super(...arguments),this.isBrush=!0,this._previousMatrix=new f.Matrix4,this._previousMatrix.elements.fill(0)}markUpdated(){this._previousMatrix.copy(this.matrix)}isDirty(){const{matrix:t,_previousMatrix:e}=this,n=t.elements,r=e.elements;for(let i=0;i<16;i++)if(n[i]!==r[i])return!0;return!1}prepareGeometry(){const t=this.geometry,e=t.attributes,n=He();if(n)for(const r in e){const t=e[r];if(t.isInterleavedBufferAttribute)throw new Error("Brush: InterleavedBufferAttributes are not supported.");t.array=qe(t.array)}if(t.boundsTree||(Xe(t,{useSharedArrayBuffer:n}),t.boundsTree=new ze(t,{maxLeafTris:3,indirect:!0,useSharedArrayBuffer:n})),t.halfEdges||(t.halfEdges=new hn(t)),!t.groupIndices){const e=We(t),n=new Uint16Array(e),r=t.groups;for(let t=0,i=r.length;t<i;t++){const{start:e,count:i}=r[t];for(let r=e/3,o=(e+i)/3;r<o;r++)n[r]=t}t.groupIndices=n}}disposeCacheData(){const{geometry:t}=this;t.halfEdges=null,t.boundsTree=null,t.groupIndices=null}}const fn=1e-14,pn=new f.Vector3,mn=new f.Vector3,gn=new f.Vector3;function yn(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:fn;pn.subVectors(t.b,t.a),mn.subVectors(t.c,t.a),gn.subVectors(t.b,t.c);const n=pn.angleTo(mn),r=pn.angleTo(gn),i=Math.PI-n-r;return Math.abs(n)<e||Math.abs(r)<e||Math.abs(i)<e||t.a.distanceToSquared(t.b)<e||t.a.distanceToSquared(t.c)<e||t.b.distanceToSquared(t.c)<e}const xn=1e-10,vn=1e-10,wn=new f.Line3,bn=new f.Line3,Mn=new f.Vector3,An=new f.Vector3,Bn=new f.Vector3,Tn=new f.Plane,Sn=new Y;class Pn{constructor(){this._pool=[],this._index=0}getTriangle(){return this._index>=this._pool.length&&this._pool.push(new f.Triangle),this._pool[this._index++]}clear(){this._index=0}reset(){this._pool.length=0,this._index=0}}class En{constructor(){this.trianglePool=new Pn,this.triangles=[],this.normal=new f.Vector3,this.coplanarTriangleUsed=!1}initialize(t){this.reset();const{triangles:e,trianglePool:n,normal:r}=this;if(Array.isArray(t))for(let i=0,o=t.length;i<o;i++){const o=t[i];if(0===i)o.getNormal(r);else if(Math.abs(1-o.getNormal(Mn).dot(r))>xn)throw new Error("Triangle Splitter: Cannot initialize with triangles that have different normals.");const s=n.getTriangle();s.copy(o),e.push(s)}else{t.getNormal(r);const i=n.getTriangle();i.copy(t),e.push(i)}}splitByTriangle(t){const{normal:e,triangles:n}=this;if(t.getNormal(An).normalize(),Math.abs(1-Math.abs(An.dot(e)))<1e-10){this.coplanarTriangleUsed=!0;for(let t=0,r=n.length;t<r;t++){n[t].coplanarCount=0}const e=[t.a,t.b,t.c];for(let n=0;n<3;n++){const r=(n+1)%3,i=e[n],o=e[r];Mn.subVectors(o,i).normalize(),Bn.crossVectors(An,Mn),Tn.setFromNormalAndCoplanarPoint(Bn,i),this.splitByPlane(Tn,t)}}else t.getPlane(Tn),this.splitByPlane(Tn,t)}splitByPlane(t,e){const{triangles:n,trianglePool:r}=this;Sn.copy(e),Sn.needsUpdate=!0;for(let i=0,o=n.length;i<o;i++){const e=n[i];if(!Sn.intersectsTriangle(e,wn,!0))continue;const{a:s,b:a,c:c}=e;let l=0,u=-1,h=!1,d=[],f=[];const p=[s,a,c];for(let n=0;n<3;n++){const e=(n+1)%3;wn.start.copy(p[n]),wn.end.copy(p[e]);const r=t.distanceToPoint(wn.start),i=t.distanceToPoint(wn.end);if(Math.abs(r)<vn&&Math.abs(i)<vn){h=!0;break}if(r>0?d.push(n):f.push(n),Math.abs(r)<vn)continue;let o=!!t.intersectLine(wn,Mn);!o&&Math.abs(i)<vn&&(Mn.copy(wn.end),o=!0),!o||Mn.distanceTo(wn.start)<xn||(Mn.distanceTo(wn.end)<xn&&(u=n),0===l?bn.start.copy(Mn):bn.end.copy(Mn),l++)}if(!h&&2===l&&bn.distance()>vn)if(-1!==u){u=(u+1)%3;let t=0;t===u&&(t=(t+1)%3);let s=t+1;s===u&&(s=(s+1)%3);const a=r.getTriangle();a.a.copy(p[s]),a.b.copy(bn.end),a.c.copy(bn.start),yn(a)||n.push(a),e.a.copy(p[t]),e.b.copy(bn.start),e.c.copy(bn.end),yn(e)&&(n.splice(i,1),i--,o--)}else{const t=d.length>=2?f[0]:d[0];if(0===t){let t=bn.start;bn.start=bn.end,bn.end=t}const s=(t+1)%3,a=(t+2)%3,c=r.getTriangle(),l=r.getTriangle();p[s].distanceToSquared(bn.start)<p[a].distanceToSquared(bn.end)?(c.a.copy(p[s]),c.b.copy(bn.start),c.c.copy(bn.end),l.a.copy(p[s]),l.b.copy(p[a]),l.c.copy(bn.start)):(c.a.copy(p[a]),c.b.copy(bn.start),c.c.copy(bn.end),l.a.copy(p[s]),l.b.copy(p[a]),l.c.copy(bn.end)),e.a.copy(p[t]),e.b.copy(bn.end),e.c.copy(bn.start),yn(c)||n.push(c),yn(l)||n.push(l),yn(e)&&(n.splice(i,1),i--,o--)}else 3===l&&console.warn("TriangleClipper: Coplanar clip not handled")}}reset(){this.triangles.length=0,this.trianglePool.clear(),this.coplanarTriangleUsed=!1}}class In{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:500;this.expansionFactor=1.5,this.type=t,this.length=0,this.array=null,this.setSize(e)}setType(t){if(0!==this.length)throw new Error("TypeBackedArray: Cannot change the type while there is used data in the buffer.");const e=this.array.buffer;this.array=new t(e),this.type=t}setSize(t){if(this.array&&t===this.array.length)return;const e=this.type,n=new e(new(He()?SharedArrayBuffer:ArrayBuffer)(4+(r=~~(r=t*e.BYTES_PER_ELEMENT))-r%4));var r;this.array&&n.set(this.array,0),this.array=n}expand(){const{array:t,expansionFactor:e}=this;this.setSize(t.length*e)}push(){let{array:t,length:e}=this;e+arguments.length>t.length&&(this.expand(),t=this.array);for(let n=0,r=arguments.length;n<r;n++)t[e+n]=n<0||arguments.length<=n?void 0:arguments[n];this.length+=arguments.length}clear(){this.length=0}}class Cn{constructor(){this.groupAttributes=[{}],this.groupCount=0}getType(t){return this.groupAttributes[0][t].type}getItemSize(t){return this.groupAttributes[0][t].itemSize}getNormalized(t){return this.groupAttributes[0][t].normalized}getCount(t){if(this.groupCount<=t)return 0;const e=this.getGroupAttrArray("position",t);return e.length/e.itemSize}getTotalLength(t){const{groupCount:e,groupAttributes:n}=this;let r=0;for(let i=0;i<e;i++){r+=n[i][t].length}return r}getGroupAttrSet(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const{groupAttributes:e}=this;if(e[t])return this.groupCount=Math.max(this.groupCount,t+1),e[t];const n=e[0];for(this.groupCount=Math.max(this.groupCount,t+1);t>=e.length;){const t={};e.push(t);for(const e in n){const r=n[e],i=new In(r.type);i.itemSize=r.itemSize,i.normalized=r.normalized,t[e]=i}}return e[t]}getGroupAttrArray(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const{groupAttributes:n}=this;if(!n[0][t])throw new Error('TypedAttributeData: Attribute with "'.concat(t,'" has not been initialized'));return this.getGroupAttrSet(e)[t]}initializeArray(t,e,n,r){const{groupAttributes:i}=this,o=i[0][t];if(o){if(o.type!==e)for(let s=0,a=i.length;s<a;s++){const o=i[s][t];o.setType(e),o.itemSize=n,o.normalized=r}}else for(let s=0,a=i.length;s<a;s++){const o=new In(e);o.itemSize=n,o.normalized=r,i[s][t]=o}}clear(){this.groupCount=0;const{groupAttributes:t}=this;t.forEach((t=>{for(const e in t)t[e].clear()}))}delete(t){this.groupAttributes.forEach((e=>{delete e[t]}))}reset(){this.groupAttributes=[],this.groupCount=0}}class Vn{constructor(){this.intersectionSet={},this.ids=[]}add(t,e){const{intersectionSet:n,ids:r}=this;n[t]||(n[t]=[],r.push(t)),n[t].push(e)}}const Un=new f.Ray,_n=new f.Matrix4,Fn=new f.Triangle,Rn=new f.Vector3,zn=new f.Vector4,Dn=new f.Vector4,kn=new f.Vector4,Ln=new f.Vector4,On=new f.Vector4,Nn=new f.Vector4,Gn=new f.Line3,jn=new f.Vector3,Hn=1e-8,qn=1e-15,Xn=-1,Wn=1,Yn=-2,Zn=2,Kn=0,Jn=1,$n=2,Qn=1e-14;let tr=null;function er(t){tr=t}function nr(t,e){t.getMidpoint(Un.origin),t.getNormal(Un.direction);const n=e.raycastFirst(Un,f.DoubleSide);return Boolean(n&&Un.direction.dot(n.face.normal)>0)?Xn:Wn}function rr(t,e){function n(){return Math.random()-.5}t.getNormal(jn),Un.direction.copy(jn),t.getMidpoint(Un.origin);let r=0,i=1/0;for(let o=0;o<3;o++){Un.direction.x+=n()*Hn,Un.direction.y+=n()*Hn,Un.direction.z+=n()*Hn,Un.direction.multiplyScalar(-1);const t=e.raycastFirst(Un,f.DoubleSide);if(Boolean(t&&Un.direction.dot(t.face.normal)>0)&&r++,null!==t&&(i=Math.min(i,t.distance)),i<=qn)return t.face.normal.dot(jn)>0?Zn:Yn;if(r/3>.5||(o-r+1)/3>.5)break}return r/3>.5?Xn:Wn}function ir(t,e,n,r,i,o){let s=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const a=n.attributes,c=n.index,l=3*t,u=c.getX(l+0),h=c.getX(l+1),d=c.getX(l+2);for(const f in o){const t=a[f],n=o[f];if(!(f in a))throw new Error("CSG Operations: Attribute ".concat(f," not available on geometry."));const c=t.itemSize;"position"===f?(Fn.a.fromBufferAttribute(t,u).applyMatrix4(r),Fn.b.fromBufferAttribute(t,h).applyMatrix4(r),Fn.c.fromBufferAttribute(t,d).applyMatrix4(r),ar(Fn.a,Fn.b,Fn.c,e,3,n,s)):"normal"===f?(Fn.a.fromBufferAttribute(t,u).applyNormalMatrix(i),Fn.b.fromBufferAttribute(t,h).applyNormalMatrix(i),Fn.c.fromBufferAttribute(t,d).applyNormalMatrix(i),s&&(Fn.a.multiplyScalar(-1),Fn.b.multiplyScalar(-1),Fn.c.multiplyScalar(-1)),ar(Fn.a,Fn.b,Fn.c,e,3,n,s,!0)):(zn.fromBufferAttribute(t,u),Dn.fromBufferAttribute(t,h),kn.fromBufferAttribute(t,d),ar(zn,Dn,kn,e,c,n,s))}}function or(t,e,n,r,i,o,s){let a=arguments.length>7&&void 0!==arguments[7]&&arguments[7];cr(t,r,i,o,s,a),cr(a?n:e,r,i,o,s,a),cr(a?e:n,r,i,o,s,a)}function sr(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];switch(t){case s:if(e===Wn||e===Zn&&!n)return Jn;break;case a:if(n){if(e===Xn)return Kn}else if(e===Wn||e===Yn)return Jn;break;case c:if(n){if(e===Wn||e===Yn)return Jn}else if(e===Xn)return Kn;break;case u:if(e===Xn)return Kn;if(e===Wn)return Jn;break;case l:if(e===Xn||e===Zn&&!n)return Jn;break;case h:if(!n&&(e===Wn||e===Yn))return Jn;break;case d:if(!n&&(e===Xn||e===Zn))return Jn;break;default:throw new Error('Unrecognized CSG operation enum "'.concat(t,'".'))}return $n}function ar(t,e,n,r,i,o){let s=arguments.length>6&&void 0!==arguments[6]&&arguments[6],a=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const c=t=>{o.push(t.x),i>1&&o.push(t.y),i>2&&o.push(t.z),i>3&&o.push(t.w)};Ln.set(0,0,0,0).addScaledVector(t,r.a.x).addScaledVector(e,r.a.y).addScaledVector(n,r.a.z),On.set(0,0,0,0).addScaledVector(t,r.b.x).addScaledVector(e,r.b.y).addScaledVector(n,r.b.z),Nn.set(0,0,0,0).addScaledVector(t,r.c.x).addScaledVector(e,r.c.y).addScaledVector(n,r.c.z),a&&(Ln.normalize(),On.normalize(),Nn.normalize()),c(Ln),s?(c(Nn),c(On)):(c(On),c(Nn))}function cr(t,e,n,r,i){let o=arguments.length>5&&void 0!==arguments[5]&&arguments[5];for(const s in i){const a=e[s],c=i[s];if(!(s in e))throw new Error("CSG Operations: Attribute ".concat(s," no available on geometry."));const l=a.itemSize;"position"===s?(Rn.fromBufferAttribute(a,t).applyMatrix4(n),c.push(Rn.x,Rn.y,Rn.z)):"normal"===s?(Rn.fromBufferAttribute(a,t).applyNormalMatrix(r),o&&Rn.multiplyScalar(-1),c.push(Rn.x,Rn.y,Rn.z)):(c.push(a.getX(t)),l>1&&c.push(a.getY(t)),l>2&&c.push(a.getZ(t)),l>3&&c.push(a.getW(t)))}}class lr{constructor(t){this.triangle=(new f.Triangle).copy(t),this.intersects={}}addTriangle(t,e){this.intersects[t]=(new f.Triangle).copy(e)}getIntersectArray(){const t=[],{intersects:e}=this;for(const n in e)t.push(e[n]);return t}}class ur{constructor(){this.data={}}addTriangleIntersection(t,e,n,r){const{data:i}=this;i[t]||(i[t]=new lr(e)),i[t].addTriangle(n,r)}getTrianglesAsArray(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const{data:e}=this,n=[];if(null!==t)t in e&&n.push(e[t].triangle);else for(const r in e)n.push(e[r].triangle);return n}getTriangleIndices(){return Object.keys(this.data).map((t=>parseInt(t)))}getIntersectionIndices(t){const{data:e}=this;return e[t]?Object.keys(e[t].intersects).map((t=>parseInt(t))):[]}getIntersectionsAsArray(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const{data:n}=this,r=new Set,i=[],o=t=>{if(n[t])if(null!==e)n[t].intersects[e]&&i.push(n[t].intersects[e]);else{const e=n[t].intersects;for(const t in e)r.has(t)||(r.add(t),i.push(e[t]))}};if(null!==t)o(t);else for(const s in n)o(s);return i}reset(){this.data={}}}class hr{constructor(){this.enabled=!1,this.triangleIntersectsA=new ur,this.triangleIntersectsB=new ur,this.intersectionEdges=[]}addIntersectingTriangles(t,e,n,r){const{triangleIntersectsA:i,triangleIntersectsB:o}=this;i.addTriangleIntersection(t,e,n,r),o.addTriangleIntersection(n,r,t,e)}addEdge(t){this.intersectionEdges.push(t.clone())}reset(){this.triangleIntersectsA.reset(),this.triangleIntersectsB.reset(),this.intersectionEdges=[]}init(){this.enabled&&(this.reset(),er(this))}complete(){this.enabled&&er(null)}}const dr=new f.Matrix4,fr=new f.Matrix3,pr=new f.Triangle,mr=new f.Triangle,gr=new f.Triangle,yr=new f.Triangle,xr=[],vr=[];function wr(t){for(const e of t)return e}function br(t,e,n,r,i){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{};const{useGroups:s=!0}=o,{aIntersections:a,bIntersections:c}=function(t,e){const n=new Vn,r=new Vn;return _n.copy(t.matrixWorld).invert().multiply(e.matrixWorld),t.geometry.boundsTree.bvhcast(e.geometry.boundsTree,_n,{intersectsTriangles(i,o,s,a){if(!yn(i)&&!yn(o)){let c=i.intersectsTriangle(o,Gn,!0);if(!c){const t=i.plane,e=o.plane,n=t.normal,r=e.normal;1===n.dot(r)&&Math.abs(t.constant-e.constant)<Qn&&(c=!0)}if(c){let c=t.geometry.boundsTree.resolveTriangleIndex(s),l=e.geometry.boundsTree.resolveTriangleIndex(a);n.add(c,l),r.add(l,c),tr&&(tr.addEdge(Gn),tr.addIntersectingTriangles(s,i,a,o))}}return!1}}),{aIntersections:n,bIntersections:r}}(t,e);let l;l=s?0:-1,Mr(t,e,a,n,!1,r,i,l),Ar(t,e,a,n,!1,i,l);return-1!==n.findIndex((t=>t!==d&&t!==h))&&(l=s?t.geometry.groups.length||1:-1,Mr(e,t,c,n,!0,r,i,l),Ar(e,t,c,n,!0,i,l)),xr.length=0,vr.length=0,{groups:[],materials:null}}function Mr(t,e,n,r,i,o,s){let a=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const c=t.matrixWorld.determinant()<0;dr.copy(e.matrixWorld).invert().multiply(t.matrixWorld),fr.getNormalMatrix(t.matrixWorld).multiplyScalar(c?-1:1);const l=t.geometry.groupIndices,u=t.geometry.index,h=t.geometry.attributes.position,d=e.geometry.boundsTree,f=e.geometry.index,p=e.geometry.attributes.position,m=n.ids,g=n.intersectionSet;for(let y=0,x=m.length;y<x;y++){const e=m[y],n=-1===a?0:l[e]+a,x=3*e,v=u.getX(x+0),w=u.getX(x+1),b=u.getX(x+2);pr.a.fromBufferAttribute(h,v).applyMatrix4(dr),pr.b.fromBufferAttribute(h,w).applyMatrix4(dr),pr.c.fromBufferAttribute(h,b).applyMatrix4(dr),o.reset(),o.initialize(pr);const M=g[e];for(let t=0,r=M.length;t<r;t++){const e=3*M[t],n=f.getX(e+0),r=f.getX(e+1),i=f.getX(e+2);mr.a.fromBufferAttribute(p,n),mr.b.fromBufferAttribute(p,r),mr.c.fromBufferAttribute(p,i),o.splitByTriangle(mr)}const A=o.triangles;for(let a=0,l=A.length;a<l;a++){const l=A[a],u=o.coplanarTriangleUsed?rr(l,d):nr(l,d);xr.length=0,vr.length=0;for(let t=0,e=r.length;t<e;t++){const e=sr(r[t],u,i);e!==$n&&(vr.push(e),xr.push(s[t].getGroupAttrSet(n)))}if(0!==xr.length){pr.getBarycoord(l.a,yr.a),pr.getBarycoord(l.b,yr.b),pr.getBarycoord(l.c,yr.c);for(let n=0,r=xr.length;n<r;n++){const r=xr[n],i=vr[n]===Kn;ir(e,yr,t.geometry,t.matrixWorld,fr,r,c!==i)}}}}return m.length}function Ar(t,e,n,r,i,o){let s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const a=t.matrixWorld.determinant()<0;dr.copy(e.matrixWorld).invert().multiply(t.matrixWorld),fr.getNormalMatrix(t.matrixWorld).multiplyScalar(a?-1:1);const c=e.geometry.boundsTree,l=t.geometry.groupIndices,u=t.geometry.index,h=t.geometry.attributes,d=h.position,f=[],p=t.geometry.halfEdges,m=new Set;for(let g=0,y=We(t.geometry);g<y;g++)g in n.intersectionSet||m.add(g);for(;m.size>0;){const e=wr(m);m.delete(e),f.push(e);const n=3*e,g=u.getX(n+0),y=u.getX(n+1),x=u.getX(n+2);gr.a.fromBufferAttribute(d,g).applyMatrix4(dr),gr.b.fromBufferAttribute(d,y).applyMatrix4(dr),gr.c.fromBufferAttribute(d,x).applyMatrix4(dr);const v=nr(gr,c);vr.length=0,xr.length=0;for(let t=0,s=r.length;t<s;t++){const e=sr(r[t],v,i);e!==$n&&(vr.push(e),xr.push(o[t]))}for(;f.length>0;){const e=f.pop();for(let t=0;t<3;t++){const n=p.getSiblingTriangleIndex(e,t);-1!==n&&m.has(n)&&(f.push(n),m.delete(n))}if(0!==xr.length){const n=3*e,r=u.getX(n+0),i=u.getX(n+1),o=u.getX(n+2),c=-1===s?0:l[e]+s;if(gr.a.fromBufferAttribute(d,r),gr.b.fromBufferAttribute(d,i),gr.c.fromBufferAttribute(d,o),!yn(gr))for(let e=0,s=xr.length;e<s;e++){const n=vr[e],s=xr[e].getGroupAttrSet(c),l=n===Kn;or(r,i,o,h,t.matrixWorld,fr,s,l!==a)}}}}}function Br(t,e){let n=e;return Array.isArray(e)||(n=[],t.forEach((t=>{n[t.materialIndex]=e}))),n}class Tr{constructor(){this.triangleSplitter=new En,this.attributeData=[],this.attributes=["position","uv","normal"],this.useGroups=!0,this.consolidateGroups=!0,this.debug=new hr}getGroupRanges(t){return this.useGroups&&0!==t.groups.length?t.groups.map((t=>({...t}))):[{start:0,count:1/0,materialIndex:0}]}evaluate(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new dn,i=!0;if(Array.isArray(n)||(n=[n]),Array.isArray(r)||(r=[r],i=!1),r.length!==n.length)throw new Error("Evaluator: operations and target array passed as different sizes.");t.prepareGeometry(),e.prepareGeometry();const{triangleSplitter:o,attributeData:s,attributes:a,useGroups:c,consolidateGroups:l,debug:u}=this;for(;s.length<r.length;)s.push(new Cn);r.forEach(((e,n)=>{!function(t,e,n,r){n.clear();const i=t.attributes;for(let o=0,s=r.length;o<s;o++){const t=r[o],e=i[t];n.initializeArray(t,e.array.constructor,e.itemSize,e.normalized)}for(const o in n.attributes)r.includes(o)||n.delete(o);for(const o in e.attributes)r.includes(o)||(e.deleteAttribute(o),e.dispose())}(t.geometry,e.geometry,s[n],a)})),u.init(),br(t,e,n,o,s,{useGroups:c}),u.complete();const h=this.getGroupRanges(t.geometry),d=Br(h,t.material),p=this.getGroupRanges(e.geometry),m=Br(p,e.material);p.forEach((t=>t.materialIndex+=d.length));let g=[...h,...p].map(((t,e)=>({...t,index:e})));if(c){const t=[...d,...m];l&&(g=g.map((e=>{const n=t[e.materialIndex];return e.materialIndex=t.indexOf(n),e})).sort(((t,e)=>t.materialIndex-e.materialIndex)));const e=[];for(let n=0,r=t.length;n<r;n++){let r=!1;for(let t=0,i=g.length;t<i;t++){const i=g[t];i.materialIndex===n&&(r=!0,i.materialIndex=e.length)}r&&e.push(t[n])}r.forEach((t=>{t.material=e}))}else g=[{start:0,count:1/0,index:0,materialIndex:0}],r.forEach((t=>{t.material=d[0]}));return r.forEach(((t,e)=>{const n=t.geometry;!function(t,e,n){let r=!1,i=-1;const o=t.attributes,s=e.groupAttributes[0];for(const c in s){const s=e.getTotalLength(c),a=e.getType(c),l=e.getItemSize(c),u=e.getNormalized(c);let h=o[c];(!h||h.array.length<s)&&(h=new f.BufferAttribute(new a(s),l,u),t.setAttribute(c,h),r=!0);let d=0;for(let t=0,r=Math.min(n.length,e.groupCount);t<r;t++){const r=n[t].index,{array:i,type:o,length:s}=e.groupAttributes[r][c],a=new o(i.buffer,0,s);h.array.set(a,d),d+=a.length}h.needsUpdate=!0,i=s/h.itemSize}if(t.index){const e=t.index.array;if(e.length<i)t.index=null,r=!0;else for(let t=0,n=e.length;t<n;t++)e[t]=t}let a=0;t.clearGroups();for(let c=0,l=Math.min(n.length,e.groupCount);c<l;c++){const{index:r,materialIndex:i}=n[c],o=e.getCount(r);0!==o&&(t.addGroup(a,o,i),a+=o)}t.setDrawRange(0,i),t.boundsTree=null,r&&t.dispose()}(n,s[e],g),l&&function(t){for(let e=0;e<t.length-1;e++){const n=t[e],r=t[e+1];if(n.materialIndex===r.materialIndex){const i=n.start,o=r.start+r.count;r.start=i,r.count=o-i,t.splice(e,1),e--}}}(n.groups)})),i?r:r[0]}evaluateHierarchy(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new dn;t.updateMatrixWorld(!0);const n=(t,e)=>{const r=t.children;for(let i=0,o=r.length;i<o;i++){const t=r[i];t.isOperationGroup?n(t,e):e(t)}},r=t=>{const e=t.children;let i=!1;for(let n=0,s=e.length;n<s;n++){const t=e[n];i=r(t)||i}const o=t.isDirty();if(o&&t.markUpdated(),i&&!t.isOperationGroup){let e;return n(t,(n=>{e=e?this.evaluate(e,n,n.operation):this.evaluate(t,n,n.operation)})),t._cachedGeometry=e.geometry,t._cachedMaterials=e.material,!0}return i||o};return r(t),e.geometry=t._cachedGeometry,e.material=t._cachedMaterials,e}reset(){this.triangleSplitter.reset()}}const Sr={subtraction:a,reverseSubtraction:c,addition:s,difference:u,intersection:l};function Pr(t){let e=null;return t instanceof dn?(t.updateMatrixWorld(),e=t):t.traverse((t=>{t.updateMatrixWorld(),!e&&t instanceof dn&&(e=t)})),e}const Er=i.createContext(null),Ir=i.forwardRef(((t,e)=>{let{children:n,computeVertexNormals:r=!1,useGroups:o=!1,showOperations:a=!1}=t;const c=i.useRef(null),l=i.useRef(null),u=i.useMemo((()=>Object.assign(new Tr,{useGroups:o})),[o]),h=i.useCallback((()=>{try{const o=l.current.children.slice();if(o.length>0){(i=c.current).dispose(),i.attributes={},i.groups=[],i.boundsTree=i.index=i.boundingBox=i.boundingSphere=null,i.drawRange={start:0,count:1/0},l.current.matrixWorld.identity();let a=Pr(o.shift());if(a){for(var t,e,n;o.length;){const t=Pr(o.shift());t&&(a=u.evaluate(a,t,Sr[t.operator]||s))}c.current.boundsTree=a.geometry.boundsTree,c.current.index=a.geometry.index,c.current.attributes=a.geometry.attributes,c.current.groups=a.geometry.groups,c.current.drawRange=a.geometry.drawRange,u.useGroups&&null!=(t=c.current)&&null!=(e=t.__r3f)&&null!=(n=e.parent)&&n.material&&(c.current.__r3f.parent.material=a.material),r&&c.current.computeVertexNormals()}}}catch(o){console.log(o)}var i}),[r,u]),d=i.useMemo((()=>({computeVertexNormals:r,showOperations:a,useGroups:o,update:h})),[r,a,o]);return i.useLayoutEffect((()=>{h()})),i.useImperativeHandle(e,(()=>({geometry:c.current,operations:l.current,...d})),[d]),i.createElement(i.Fragment,null,i.createElement("group",{matrixAutoUpdate:!1,ref:l},i.createElement(Er.Provider,{value:d},n)),i.createElement("bufferGeometry",{ref:c}))})),Cr=i.forwardRef(((t,e)=>{let{showOperation:n=!1,operator:s="addition",...a}=t;(0,o.e)({Brush:dn});const{showOperations:c}=i.useContext(Er);return i.createElement("brush",(0,r.A)({operator:s,raycast:()=>null,visible:n||c,ref:e},a))})),Vr=i.forwardRef(((t,e)=>i.createElement(Cr,(0,r.A)({ref:e,operator:"subtraction"},t))))},7585:(t,e,n)=>{n.d(e,{$:()=>h});var r=n(8168),i=n(9408),o=n(5043),s=n(7551),a=n(9211);function c(t,e,n,r){const o=class extends i.ShaderMaterial{constructor(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const s=Object.entries(t);super({uniforms:s.reduce(((t,e)=>{let[n,r]=e;return{...t,...i.UniformsUtils.clone({[n]:{value:r}})}}),{}),vertexShader:e,fragmentShader:n}),this.key="",s.forEach((t=>{let[e]=t;return Object.defineProperty(this,e,{get:()=>this.uniforms[e].value,set:t=>this.uniforms[e].value=t})})),Object.assign(this,o),r&&r(this)}};return o.key=i.MathUtils.generateUUID(),o}const l=c({},"void main() { }","void main() { gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0); discard;  }");class u extends i.MeshPhysicalMaterial{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:6,e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super(),this.uniforms={chromaticAberration:{value:.05},transmission:{value:0},_transmission:{value:1},transmissionMap:{value:null},roughness:{value:0},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:1/0},attenuationColor:{value:new i.Color("white")},anisotropicBlur:{value:.1},time:{value:0},distortion:{value:0},distortionScale:{value:.5},temporalDistortion:{value:0},buffer:{value:null}},this.onBeforeCompile=n=>{n.uniforms={...n.uniforms,...this.uniforms},this.anisotropy>0&&(n.defines.USE_ANISOTROPY=""),e?n.defines.USE_SAMPLER="":n.defines.USE_TRANSMISSION="",n.fragmentShader="\n      uniform float chromaticAberration;         \n      uniform float anisotropicBlur;      \n      uniform float time;\n      uniform float distortion;\n      uniform float distortionScale;\n      uniform float temporalDistortion;\n      uniform sampler2D buffer;\n\n      vec3 random3(vec3 c) {\n        float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n        vec3 r;\n        r.z = fract(512.0*j);\n        j *= .125;\n        r.x = fract(512.0*j);\n        j *= .125;\n        r.y = fract(512.0*j);\n        return r-0.5;\n      }\n\n      uint hash( uint x ) {\n        x += ( x << 10u );\n        x ^= ( x >>  6u );\n        x += ( x <<  3u );\n        x ^= ( x >> 11u );\n        x += ( x << 15u );\n        return x;\n      }\n\n      // Compound versions of the hashing algorithm I whipped together.\n      uint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\n      uint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\n      uint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n      // Construct a float with half-open range [0:1] using low 23 bits.\n      // All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\n      float floatConstruct( uint m ) {\n        const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n        const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n        m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n        m |= ieeeOne;                          // Add fractional part to 1.0\n        float  f = uintBitsToFloat( m );       // Range [1:2]\n        return f - 1.0;                        // Range [0:1]\n      }\n\n      // Pseudo-random value in half-open range [0:1].\n      float randomBase( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\n      float randomBase( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n      float randomBase( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n      float randomBase( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n      float rand(float seed) {\n        float result = randomBase(vec3(gl_FragCoord.xy, seed));\n        return result;\n      }\n\n      const float F3 =  0.3333333;\n      const float G3 =  0.1666667;\n\n      float snoise(vec3 p) {\n        vec3 s = floor(p + dot(p, vec3(F3)));\n        vec3 x = p - s + dot(s, vec3(G3));\n        vec3 e = step(vec3(0.0), x - x.yzx);\n        vec3 i1 = e*(1.0 - e.zxy);\n        vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n        vec3 x1 = x - i1 + G3;\n        vec3 x2 = x - i2 + 2.0*G3;\n        vec3 x3 = x - 1.0 + 3.0*G3;\n        vec4 w, d;\n        w.x = dot(x, x);\n        w.y = dot(x1, x1);\n        w.z = dot(x2, x2);\n        w.w = dot(x3, x3);\n        w = max(0.6 - w, 0.0);\n        d.x = dot(random3(s), x);\n        d.y = dot(random3(s + i1), x1);\n        d.z = dot(random3(s + i2), x2);\n        d.w = dot(random3(s + 1.0), x3);\n        w *= w;\n        w *= w;\n        d *= w;\n        return dot(d, vec4(52.0));\n      }\n\n      float snoiseFractal(vec3 m) {\n        return 0.5333333* snoise(m)\n              +0.2666667* snoise(2.0*m)\n              +0.1333333* snoise(4.0*m)\n              +0.0666667* snoise(8.0*m);\n      }\n"+n.fragmentShader,n.fragmentShader=n.fragmentShader.replace("#include <transmission_pars_fragment>","\n        #ifdef USE_TRANSMISSION\n          // Transmission code is based on glTF-Sampler-Viewer\n          // https://github.com/KhronosGroup/glTF-Sample-Viewer\n          uniform float _transmission;\n          uniform float thickness;\n          uniform float attenuationDistance;\n          uniform vec3 attenuationColor;\n          #ifdef USE_TRANSMISSIONMAP\n            uniform sampler2D transmissionMap;\n          #endif\n          #ifdef USE_THICKNESSMAP\n            uniform sampler2D thicknessMap;\n          #endif\n          uniform vec2 transmissionSamplerSize;\n          uniform sampler2D transmissionSamplerMap;\n          uniform mat4 modelMatrix;\n          uniform mat4 projectionMatrix;\n          varying vec3 vWorldPosition;\n          vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n            // Direction of refracted light.\n            vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n            // Compute rotation-independant scaling of the model matrix.\n            vec3 modelScale;\n            modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n            modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n            modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n            // The thickness is specified in local space.\n            return normalize( refractionVector ) * thickness * modelScale;\n          }\n          float applyIorToRoughness( const in float roughness, const in float ior ) {\n            // Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n            // an IOR of 1.5 results in the default amount of microfacet refraction.\n            return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n          }\n          vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n            float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );            \n            #ifdef USE_SAMPLER\n              #ifdef texture2DLodEXT\n                return texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod);\n              #else\n                return texture2D(transmissionSamplerMap, fragCoord.xy, framebufferLod);\n              #endif\n            #else\n              return texture2D(buffer, fragCoord.xy);\n            #endif\n          }\n          vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n            if ( isinf( attenuationDistance ) ) {\n              // Attenuation distance is +\u221e, i.e. the transmitted color is not attenuated at all.\n              return radiance;\n            } else {\n              // Compute light attenuation using Beer's law.\n              vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n              vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance ); // Beer's law\n              return transmittance * radiance;\n            }\n          }\n          vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n            const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n            const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n            const in vec3 attenuationColor, const in float attenuationDistance ) {\n            vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n            vec3 refractedRayExit = position + transmissionRay;\n            // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n            vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n            vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n            refractionCoords += 1.0;\n            refractionCoords /= 2.0;\n            // Sample framebuffer to get pixel the refracted ray hits.\n            vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n            vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n            // Get the specular component.\n            vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n            return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n          }\n        #endif\n"),n.fragmentShader=n.fragmentShader.replace("#include <transmission_fragment>","  \n        // Improve the refraction to use the world pos\n        material.transmission = _transmission;\n        material.transmissionAlpha = 1.0;\n        material.thickness = thickness;\n        material.attenuationDistance = attenuationDistance;\n        material.attenuationColor = attenuationColor;\n        #ifdef USE_TRANSMISSIONMAP\n          material.transmission *= texture2D( transmissionMap, vUv ).r;\n        #endif\n        #ifdef USE_THICKNESSMAP\n          material.thickness *= texture2D( thicknessMap, vUv ).g;\n        #endif\n        \n        vec3 pos = vWorldPosition;\n        float runningSeed = 0.0;\n        vec3 v = normalize( cameraPosition - pos );\n        vec3 n = inverseTransformDirection( normal, viewMatrix );\n        vec3 transmission = vec3(0.0);\n        float transmissionR, transmissionB, transmissionG;\n        float randomCoords = rand(runningSeed++);\n        float thickness_smear = thickness * max(pow(roughnessFactor, 0.33), anisotropicBlur);\n        vec3 distortionNormal = vec3(0.0);\n        vec3 temporalOffset = vec3(time, -time, -time) * temporalDistortion;\n        if (distortion > 0.0) {\n          distortionNormal = distortion * vec3(snoiseFractal(vec3((pos * distortionScale + temporalOffset))), snoiseFractal(vec3(pos.zxy * distortionScale - temporalOffset)), snoiseFractal(vec3(pos.yxz * distortionScale + temporalOffset)));\n        }\n        for (float i = 0.0; i < ".concat(t,".0; i ++) {\n          vec3 sampleNorm = normalize(n + roughnessFactor * roughnessFactor * 2.0 * normalize(vec3(rand(runningSeed++) - 0.5, rand(runningSeed++) - 0.5, rand(runningSeed++) - 0.5)) * pow(rand(runningSeed++), 0.33) + distortionNormal);\n          transmissionR = getIBLVolumeRefraction(\n            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness  + thickness_smear * (i + randomCoords) / float(").concat(t,"),\n            material.attenuationColor, material.attenuationDistance\n          ).r;\n          transmissionG = getIBLVolumeRefraction(\n            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior  * (1.0 + chromaticAberration * (i + randomCoords) / float(").concat(t,")) , material.thickness + thickness_smear * (i + randomCoords) / float(").concat(t,"),\n            material.attenuationColor, material.attenuationDistance\n          ).g;\n          transmissionB = getIBLVolumeRefraction(\n            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior * (1.0 + 2.0 * chromaticAberration * (i + randomCoords) / float(").concat(t,")), material.thickness + thickness_smear * (i + randomCoords) / float(").concat(t,"),\n            material.attenuationColor, material.attenuationDistance\n          ).b;\n          transmission.r += transmissionR;\n          transmission.g += transmissionG;\n          transmission.b += transmissionB;\n        }\n        transmission /= ").concat(t,".0;\n        totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\n"))},Object.keys(this.uniforms).forEach((t=>Object.defineProperty(this,t,{get:()=>this.uniforms[t].value,set:e=>this.uniforms[t].value=e})))}}const h=o.forwardRef(((t,e)=>{let{buffer:n,transmissionSampler:c=!1,backside:h=!1,side:d=i.FrontSide,transmission:f=1,thickness:p=0,backsideThickness:m=0,samples:g=10,resolution:y,backsideResolution:x,background:v,anisotropy:w,anisotropicBlur:b,...M}=t;(0,s.e)({MeshTransmissionMaterial:u});const A=o.useRef(null),[B]=o.useState((()=>new l)),T=(0,a.j)(x||y),S=(0,a.j)(y);let P,E,I;return(0,s.C)((t=>{A.current.time=t.clock.getElapsedTime(),A.current.buffer!==S.texture||c||(I=A.current.__r3f.parent,I&&(E=t.gl.toneMapping,P=t.scene.background,t.gl.toneMapping=i.NoToneMapping,v&&(t.scene.background=v),I.material=B,h&&(t.gl.setRenderTarget(T),t.gl.render(t.scene,t.camera),I.material=A.current,I.material.buffer=T.texture,I.material.thickness=m,I.material.side=i.BackSide),t.gl.setRenderTarget(S),t.gl.render(t.scene,t.camera),I.material=A.current,I.material.thickness=p,I.material.side=d,I.material.buffer=S.texture,t.scene.background=P,t.gl.setRenderTarget(null),t.gl.toneMapping=E))})),o.useImperativeHandle(e,(()=>A.current),[]),o.createElement("meshTransmissionMaterial",(0,r.A)({args:[g,c],ref:A},M,{buffer:n||S.texture,_transmission:f,anisotropicBlur:null!==b&&void 0!==b?b:w,transmission:c?f:0,thickness:p,side:d}))}))},2474:(t,e,n)=>{n.d(e,{m:()=>f});var r=n(8168),i=n(5043),o=n(9408),s=n(8798),a=Object.defineProperty,c=(t,e,n)=>(((t,e,n)=>{e in t?a(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n})(t,"symbol"!==typeof e?e+"":e,n),n);const l={uniforms:{turbidity:{value:2},rayleigh:{value:1},mieCoefficient:{value:.005},mieDirectionalG:{value:.8},sunPosition:{value:new o.Vector3},up:{value:new o.Vector3(0,1,0)}},vertexShader:"\n      uniform vec3 sunPosition;\n      uniform float rayleigh;\n      uniform float turbidity;\n      uniform float mieCoefficient;\n      uniform vec3 up;\n\n      varying vec3 vWorldPosition;\n      varying vec3 vSunDirection;\n      varying float vSunfade;\n      varying vec3 vBetaR;\n      varying vec3 vBetaM;\n      varying float vSunE;\n\n      // constants for atmospheric scattering\n      const float e = 2.71828182845904523536028747135266249775724709369995957;\n      const float pi = 3.141592653589793238462643383279502884197169;\n\n      // wavelength of used primaries, according to preetham\n      const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );\n      // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:\n      // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\n      const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );\n\n      // mie stuff\n      // K coefficient for the primaries\n      const float v = 4.0;\n      const vec3 K = vec3( 0.686, 0.678, 0.666 );\n      // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\n      const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );\n\n      // earth shadow hack\n      // cutoffAngle = pi / 1.95;\n      const float cutoffAngle = 1.6110731556870734;\n      const float steepness = 1.5;\n      const float EE = 1000.0;\n\n      float sunIntensity( float zenithAngleCos ) {\n        zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );\n        return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );\n      }\n\n      vec3 totalMie( float T ) {\n        float c = ( 0.2 * T ) * 10E-18;\n        return 0.434 * c * MieConst;\n      }\n\n      void main() {\n\n        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n        vWorldPosition = worldPosition.xyz;\n\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        gl_Position.z = gl_Position.w; // set z to camera.far\n\n        vSunDirection = normalize( sunPosition );\n\n        vSunE = sunIntensity( dot( vSunDirection, up ) );\n\n        vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );\n\n        float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );\n\n      // extinction (absorbtion + out scattering)\n      // rayleigh coefficients\n        vBetaR = totalRayleigh * rayleighCoefficient;\n\n      // mie coefficients\n        vBetaM = totalMie( turbidity ) * mieCoefficient;\n\n      }\n    ",fragmentShader:"\n      varying vec3 vWorldPosition;\n      varying vec3 vSunDirection;\n      varying float vSunfade;\n      varying vec3 vBetaR;\n      varying vec3 vBetaM;\n      varying float vSunE;\n\n      uniform float mieDirectionalG;\n      uniform vec3 up;\n\n      const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );\n\n      // constants for atmospheric scattering\n      const float pi = 3.141592653589793238462643383279502884197169;\n\n      const float n = 1.0003; // refractive index of air\n      const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)\n\n      // optical length at zenith for molecules\n      const float rayleighZenithLength = 8.4E3;\n      const float mieZenithLength = 1.25E3;\n      // 66 arc seconds -> degrees, and the cosine of that\n      const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\n\n      // 3.0 / ( 16.0 * pi )\n      const float THREE_OVER_SIXTEENPI = 0.05968310365946075;\n      // 1.0 / ( 4.0 * pi )\n      const float ONE_OVER_FOURPI = 0.07957747154594767;\n\n      float rayleighPhase( float cosTheta ) {\n        return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );\n      }\n\n      float hgPhase( float cosTheta, float g ) {\n        float g2 = pow( g, 2.0 );\n        float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );\n        return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );\n      }\n\n      void main() {\n\n        vec3 direction = normalize( vWorldPosition - cameraPos );\n\n      // optical length\n      // cutoff angle at 90 to avoid singularity in next formula.\n        float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );\n        float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );\n        float sR = rayleighZenithLength * inverse;\n        float sM = mieZenithLength * inverse;\n\n      // combined extinction factor\n        vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );\n\n      // in scattering\n        float cosTheta = dot( direction, vSunDirection );\n\n        float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );\n        vec3 betaRTheta = vBetaR * rPhase;\n\n        float mPhase = hgPhase( cosTheta, mieDirectionalG );\n        vec3 betaMTheta = vBetaM * mPhase;\n\n        vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );\n        Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );\n\n      // nightsky\n        float theta = acos( direction.y ); // elevation --\x3e y-axis, [-pi/2, pi/2]\n        float phi = atan( direction.z, direction.x ); // azimuth --\x3e x-axis [-pi/2, pi/2]\n        vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );\n        vec3 L0 = vec3( 0.1 ) * Fex;\n\n      // composition + solar disc\n        float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );\n        L0 += ( vSunE * 19000.0 * Fex ) * sundisk;\n\n        vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );\n\n        vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );\n\n        gl_FragColor = vec4( retColor, 1.0 );\n\n      #include <tonemapping_fragment>\n      #include <".concat(s.r>=154?"colorspace_fragment":"encodings_fragment",">\n\n      }\n    ")},u=new o.ShaderMaterial({name:"SkyShader",fragmentShader:l.fragmentShader,vertexShader:l.vertexShader,uniforms:o.UniformsUtils.clone(l.uniforms),side:o.BackSide,depthWrite:!1});class h extends o.Mesh{constructor(){super(new o.BoxGeometry(1,1,1),u)}}function d(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new o.Vector3;const r=Math.PI*(t-.5),i=2*Math.PI*(e-.5);return n.x=Math.cos(i),n.y=Math.sin(r),n.z=Math.sin(i),n}c(h,"SkyShader",l),c(h,"material",u);const f=i.forwardRef(((t,e)=>{let{inclination:n=.6,azimuth:s=.1,distance:a=1e3,mieCoefficient:c=.005,mieDirectionalG:l=.8,rayleigh:u=.5,turbidity:f=10,sunPosition:p=d(n,s),...m}=t;const g=i.useMemo((()=>(new o.Vector3).setScalar(a)),[a]),[y]=i.useState((()=>new h));return i.createElement("primitive",(0,r.A)({object:y,ref:e,"material-uniforms-mieCoefficient-value":c,"material-uniforms-mieDirectionalG-value":l,"material-uniforms-rayleigh-value":u,"material-uniforms-sunPosition-value":p,"material-uniforms-turbidity-value":f,scale:g},m))}))},8798:(t,e,n)=>{n.d(e,{r:()=>i});var r=n(9408);const i=parseInt(r.REVISION.replace(/\D+/g,""))},3970:(t,e,n)=>{n.d(e,{T:()=>I});const r={enabled:!1,files:{},add:function(t,e){!1!==this.enabled&&(this.files[t]=e)},get:function(t){if(!1!==this.enabled)return this.files[t]},remove:function(t){delete this.files[t]},clear:function(){this.files={}}};class i{constructor(t,e,n){const r=this;let i,o=!1,s=0,a=0;const c=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=n,this.itemStart=function(t){a++,!1===o&&void 0!==r.onStart&&r.onStart(t,s,a),o=!0},this.itemEnd=function(t){s++,void 0!==r.onProgress&&r.onProgress(t,s,a),s===a&&(o=!1,void 0!==r.onLoad&&r.onLoad())},this.itemError=function(t){void 0!==r.onError&&r.onError(t)},this.resolveURL=function(t){return i?i(t):t},this.setURLModifier=function(t){return i=t,this},this.addHandler=function(t,e){return c.push(t,e),this},this.removeHandler=function(t){const e=c.indexOf(t);return-1!==e&&c.splice(e,2),this},this.getHandler=function(t){for(let e=0,n=c.length;e<n;e+=2){const n=c[e],r=c[e+1];if(n.global&&(n.lastIndex=0),n.test(t))return r}return null}}}const o=new i;class s{constructor(t){this.manager=void 0!==t?t:o,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const n=this;return new Promise((function(r,i){n.load(t,r,e,i)}))}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array;function a(t){return document.createElementNS("http://www.w3.org/1999/xhtml",t)}const c={};function l(t){t in c||(c[t]=!0,console.warn(t))}class u extends s{constructor(t){super(t)}load(t,e,n,i){void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const o=this,s=r.get(t);if(void 0!==s)return o.manager.itemStart(t),setTimeout((function(){e&&e(s),o.manager.itemEnd(t)}),0),s;const c=a("img");function l(){h(),r.add(t,this),e&&e(this),o.manager.itemEnd(t)}function u(e){h(),i&&i(e),o.manager.itemError(t),o.manager.itemEnd(t)}function h(){c.removeEventListener("load",l,!1),c.removeEventListener("error",u,!1)}return c.addEventListener("load",l,!1),c.addEventListener("error",u,!1),"data:"!==t.slice(0,5)&&void 0!==this.crossOrigin&&(c.crossOrigin=this.crossOrigin),o.manager.itemStart(t),c.src=t,c}}class h{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[t]&&(n[t]=[]),-1===n[t].indexOf(e)&&n[t].push(e)}hasEventListener(t,e){if(void 0===this._listeners)return!1;const n=this._listeners;return void 0!==n[t]&&-1!==n[t].indexOf(e)}removeEventListener(t,e){if(void 0===this._listeners)return;const n=this._listeners[t];if(void 0!==n){const t=n.indexOf(e);-1!==t&&n.splice(t,1)}}dispatchEvent(t){if(void 0===this._listeners)return;const e=this._listeners[t.type];if(void 0!==e){t.target=this;const n=e.slice(0);for(let e=0,r=n.length;e<r;e++)n[e].call(this,t);t.target=null}}}const d=1001,f=3001,p="srgb",m=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];Math.PI,Math.PI;function g(){const t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,n=4294967295*Math.random()|0,r=4294967295*Math.random()|0;return(m[255&t]+m[t>>8&255]+m[t>>16&255]+m[t>>24&255]+"-"+m[255&e]+m[e>>8&255]+"-"+m[e>>16&15|64]+m[e>>24&255]+"-"+m[63&n|128]+m[n>>8&255]+"-"+m[n>>16&255]+m[n>>24&255]+m[255&r]+m[r>>8&255]+m[r>>16&255]+m[r>>24&255]).toLowerCase()}function y(t,e,n){return Math.max(e,Math.min(n,t))}class x{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;x.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,r=t.elements;return this.x=r[0]*e+r[3]*n+r[6],this.y=r[1]*e+r[4]*n+r[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(y(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.x=t[e],this.y=t[e+1],this}toArray(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),r=Math.sin(e),i=this.x-t.x,o=this.y-t.y;return this.x=i*n-o*r+t.x,this.y=i*r+o*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class v{constructor(t,e,n,r,i,o,s,a,c){v.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],void 0!==t&&this.set(t,e,n,r,i,o,s,a,c)}set(t,e,n,r,i,o,s,a,c){const l=this.elements;return l[0]=t,l[1]=r,l[2]=s,l[3]=e,l[4]=i,l[5]=a,l[6]=n,l[7]=o,l[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,r=e.elements,i=this.elements,o=n[0],s=n[3],a=n[6],c=n[1],l=n[4],u=n[7],h=n[2],d=n[5],f=n[8],p=r[0],m=r[3],g=r[6],y=r[1],x=r[4],v=r[7],w=r[2],b=r[5],M=r[8];return i[0]=o*p+s*y+a*w,i[3]=o*m+s*x+a*b,i[6]=o*g+s*v+a*M,i[1]=c*p+l*y+u*w,i[4]=c*m+l*x+u*b,i[7]=c*g+l*v+u*M,i[2]=h*p+d*y+f*w,i[5]=h*m+d*x+f*b,i[8]=h*g+d*v+f*M,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],r=t[2],i=t[3],o=t[4],s=t[5],a=t[6],c=t[7],l=t[8];return e*o*l-e*s*c-n*i*l+n*s*a+r*i*c-r*o*a}invert(){const t=this.elements,e=t[0],n=t[1],r=t[2],i=t[3],o=t[4],s=t[5],a=t[6],c=t[7],l=t[8],u=l*o-s*c,h=s*a-l*i,d=c*i-o*a,f=e*u+n*h+r*d;if(0===f)return this.set(0,0,0,0,0,0,0,0,0);const p=1/f;return t[0]=u*p,t[1]=(r*c-l*n)*p,t[2]=(s*n-r*o)*p,t[3]=h*p,t[4]=(l*e-r*a)*p,t[5]=(r*i-s*e)*p,t[6]=d*p,t[7]=(n*a-c*e)*p,t[8]=(o*e-n*i)*p,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,r,i,o,s){const a=Math.cos(i),c=Math.sin(i);return this.set(n*a,n*c,-n*(a*o+c*s)+o+t,-r*c,r*a,-r*(-c*o+a*s)+s+e,0,0,1),this}scale(t,e){return this.premultiply(w.makeScale(t,e)),this}rotate(t){return this.premultiply(w.makeRotation(-t)),this}translate(t,e){return this.premultiply(w.makeTranslation(t,e)),this}makeTranslation(t,e){return t.isVector2?this.set(1,0,t.x,0,1,t.y,0,0,1):this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,n,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,n=t.elements;for(let r=0;r<9;r++)if(e[r]!==n[r])return!1;return!0}fromArray(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return(new this.constructor).fromArray(this.elements)}}const w=new v;function b(t){return t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}let M;class A{static getDataURL(t){if(/^data:/i.test(t.src))return t.src;if("undefined"===typeof HTMLCanvasElement)return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{void 0===M&&(M=a("canvas")),M.width=t.width,M.height=t.height;const n=M.getContext("2d");t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0,t.width,t.height),e=M}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}static sRGBToLinear(t){if("undefined"!==typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!==typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!==typeof ImageBitmap&&t instanceof ImageBitmap){const e=a("canvas");e.width=t.width,e.height=t.height;const n=e.getContext("2d");n.drawImage(t,0,0,t.width,t.height);const r=n.getImageData(0,0,t.width,t.height),i=r.data;for(let t=0;t<i.length;t++)i[t]=255*b(i[t]/255);return n.putImageData(r,0,0),e}if(t.data){const e=t.data.slice(0);for(let t=0;t<e.length;t++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[t]=Math.floor(255*b(e[t]/255)):e[t]=b(e[t]);return{data:e,width:t.width,height:t.height}}return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}let B=0;class T{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;this.isSource=!0,Object.defineProperty(this,"id",{value:B++}),this.uuid=g(),this.data=t,this.version=0}set needsUpdate(t){!0===t&&this.version++}toJSON(t){const e=void 0===t||"string"===typeof t;if(!e&&void 0!==t.images[this.uuid])return t.images[this.uuid];const n={uuid:this.uuid,url:""},r=this.data;if(null!==r){let t;if(Array.isArray(r)){t=[];for(let e=0,n=r.length;e<n;e++)r[e].isDataTexture?t.push(S(r[e].image)):t.push(S(r[e]))}else t=S(r);n.url=t}return e||(t.images[this.uuid]=n),n}}function S(t){return"undefined"!==typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!==typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!==typeof ImageBitmap&&t instanceof ImageBitmap?A.getDataURL(t):t.data?{data:Array.from(t.data),width:t.width,height:t.height,type:t.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let P=0;class E extends h{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:E.DEFAULT_IMAGE,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:E.DEFAULT_MAPPING,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:d,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:d,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1006,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1008,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1023,a=arguments.length>7&&void 0!==arguments[7]?arguments[7]:1009,c=arguments.length>8&&void 0!==arguments[8]?arguments[8]:E.DEFAULT_ANISOTROPY,u=arguments.length>9&&void 0!==arguments[9]?arguments[9]:"";super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:P++}),this.uuid=g(),this.name="",this.source=new T(t),this.mipmaps=[],this.mapping=e,this.channel=0,this.wrapS=n,this.wrapT=r,this.magFilter=i,this.minFilter=o,this.anisotropy=c,this.format=s,this.internalFormat=null,this.type=a,this.offset=new x(0,0),this.repeat=new x(1,1),this.center=new x(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new v,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,"string"===typeof u?this.colorSpace=u:(l("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=u===f?p:""),this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(t){void 0===t&&(t=null),this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return(new this.constructor).copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.channel=t.channel,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.colorSpace=t.colorSpace,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}toJSON(t){const e=void 0===t||"string"===typeof t;if(!e&&void 0!==t.textures[this.uuid])return t.textures[this.uuid];const n={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(n.userData=this.userData),e||(t.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(300!==this.mapping)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case 1e3:t.x=t.x-Math.floor(t.x);break;case d:t.x=t.x<0?0:1;break;case 1002:1===Math.abs(Math.floor(t.x)%2)?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x)}if(t.y<0||t.y>1)switch(this.wrapT){case 1e3:t.y=t.y-Math.floor(t.y);break;case d:t.y=t.y<0?0:1;break;case 1002:1===Math.abs(Math.floor(t.y)%2)?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y)}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){!0===t&&(this.version++,this.source.needsUpdate=!0)}get encoding(){return l("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace===p?f:3e3}set encoding(t){l("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=t===f?p:""}}E.DEFAULT_IMAGE=null,E.DEFAULT_MAPPING=300,E.DEFAULT_ANISOTROPY=1;class I extends s{constructor(t){super(t)}load(t,e,n,r){const i=new E,o=new u(this.manager);return o.setCrossOrigin(this.crossOrigin),o.setPath(this.path),o.load(t,(function(t){i.image=t,i.needsUpdate=!0,void 0!==e&&e(i)}),n,r),i}}}}]);
//# sourceMappingURL=285.41388879.chunk.js.map