{"version":3,"file":"static/js/569.e19a2dfd.chunk.js","mappings":"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","sources":["../node_modules/three-bvh-csg/src/core/constants.js","../node_modules/three-mesh-bvh/src/core/Constants.js","../node_modules/three-mesh-bvh/src/core/build/geometryUtils.js","../node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js","../node_modules/three-mesh-bvh/src/core/build/computeBoundsUtils.js","../node_modules/three-mesh-bvh/src/core/build/splitUtils.js","../node_modules/three-mesh-bvh/src/core/MeshBVHNode.js","../node_modules/three-mesh-bvh/src/core/build/sortUtils.generated.js","../node_modules/three-mesh-bvh/src/core/build/sortUtils_indirect.generated.js","../node_modules/three-mesh-bvh/src/core/build/buildTree.js","../node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js","../node_modules/three-mesh-bvh/src/math/MathUtilities.js","../node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js","../node_modules/three-mesh-bvh/src/math/OrientedBox.js","../node_modules/three-mesh-bvh/src/utils/PrimitivePool.js","../node_modules/three-mesh-bvh/src/utils/ExtendedTrianglePool.js","../node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js","../node_modules/three-mesh-bvh/src/core/utils/BufferStack.js","../node_modules/three-mesh-bvh/src/core/cast/shapecast.js","../node_modules/three-mesh-bvh/src/core/cast/closestPointToPoint.js","../node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js","../node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js","../node_modules/three-mesh-bvh/src/core/utils/iterationUtils.generated.js","../node_modules/three-mesh-bvh/src/core/cast/refit.generated.js","../node_modules/three-mesh-bvh/src/core/utils/intersectUtils.js","../node_modules/three-mesh-bvh/src/core/cast/raycast.generated.js","../node_modules/three-mesh-bvh/src/core/cast/raycastFirst.generated.js","../node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry.generated.js","../node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry.generated.js","../node_modules/three-mesh-bvh/src/core/utils/iterationUtils_indirect.generated.js","../node_modules/three-mesh-bvh/src/core/cast/refit_indirect.generated.js","../node_modules/three-mesh-bvh/src/core/cast/raycast_indirect.generated.js","../node_modules/three-mesh-bvh/src/core/cast/raycastFirst_indirect.generated.js","../node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry_indirect.generated.js","../node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry_indirect.generated.js","../node_modules/three-mesh-bvh/src/core/cast/bvhcast.js","../node_modules/three-mesh-bvh/src/core/MeshBVH.js","../node_modules/three-mesh-bvh/src/utils/BufferUtils.js","../node_modules/three-bvh-csg/src/core/utils/hashUtils.js","../node_modules/three-bvh-csg/src/core/utils/geometryUtils.js","../node_modules/three-bvh-csg/src/core/utils/halfEdgeUtils.js","../node_modules/three-bvh-csg/src/core/utils/RaySet.js","../node_modules/three-bvh-csg/src/core/utils/computeDisjointEdges.js","../node_modules/three-bvh-csg/src/core/HalfEdgeMap.js","../node_modules/three-bvh-csg/src/core/Brush.js","../node_modules/three-bvh-csg/src/core/utils/triangleUtils.js","../node_modules/three-bvh-csg/src/core/TriangleSplitter.js","../node_modules/three-bvh-csg/src/core/TypeBackedArray.js","../node_modules/three-bvh-csg/src/core/TypedAttributeData.js","../node_modules/three-bvh-csg/src/core/IntersectionMap.js","../node_modules/three-bvh-csg/src/core/operations/operationsUtils.js","../node_modules/three-bvh-csg/src/core/debug/OperationDebugData.js","../node_modules/three-bvh-csg/src/core/operations/operations.js","../node_modules/three-bvh-csg/src/core/Evaluator.js","../node_modules/@react-three/csg/dist/index.js"],"sourcesContent":["export const ADDITION = 0;\nexport const SUBTRACTION = 1;\nexport const REVERSE_SUBTRACTION = 2;\nexport const INTERSECTION = 3;\nexport const DIFFERENCE = 4;\n\n// guaranteed non manifold results\nexport const HOLLOW_SUBTRACTION = 5;\nexport const HOLLOW_INTERSECTION = 6;\n","// Split strategy constants\nexport const CENTER = 0;\nexport const AVERAGE = 1;\nexport const SAH = 2;\n\n// Traversal constants\nexport const NOT_INTERSECTED = 0;\nexport const INTERSECTED = 1;\nexport const CONTAINED = 2;\n\n// SAH cost constants\n// TODO: hone these costs more. The relative difference between them should be the\n// difference in measured time to perform a triangle intersection vs traversing\n// bounds.\nexport const TRIANGLE_INTERSECT_COST = 1.25;\nexport const TRAVERSAL_COST = 1;\n\n\n// Build constants\nexport const BYTES_PER_NODE = 6 * 4 + 4 + 4;\nexport const IS_LEAFNODE_FLAG = 0xFFFF;\n\n// EPSILON for computing floating point error during build\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\nexport const FLOAT32_EPSILON = Math.pow( 2, - 24 );\n\nexport const SKIP_GENERATION = Symbol( 'SKIP_GENERATION' );\n","import { BufferAttribute } from 'three';\n\nexport function getVertexCount( geo ) {\n\n\treturn geo.index ? geo.index.count : geo.attributes.position.count;\n\n}\n\nexport function getTriCount( geo ) {\n\n\treturn getVertexCount( geo ) / 3;\n\n}\n\nexport function getIndexArray( vertexCount, BufferConstructor = ArrayBuffer ) {\n\n\tif ( vertexCount > 65535 ) {\n\n\t\treturn new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\n\n\t} else {\n\n\t\treturn new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\n\n\t}\n\n}\n\n// ensures that an index is present on the geometry\nexport function ensureIndex( geo, options ) {\n\n\tif ( ! geo.index ) {\n\n\t\tconst vertexCount = geo.attributes.position.count;\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\tconst index = getIndexArray( vertexCount, BufferConstructor );\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\n\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tindex[ i ] = i;\n\n\t\t}\n\n\t}\n\n}\n\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nexport function getFullGeometryRange( geo ) {\n\n\tconst triCount = getTriCount( geo );\n\tconst drawRange = geo.drawRange;\n\tconst start = drawRange.start / 3;\n\tconst end = ( drawRange.start + drawRange.count ) / 3;\n\n\tconst offset = Math.max( 0, start );\n\tconst count = Math.min( triCount, end ) - offset;\n\treturn [ {\n\t\toffset: Math.floor( offset ),\n\t\tcount: Math.floor( count ),\n\t} ];\n\n}\n\nexport function getRootIndexRanges( geo ) {\n\n\tif ( ! geo.groups || ! geo.groups.length ) {\n\n\t\treturn getFullGeometryRange( geo );\n\n\t}\n\n\tconst ranges = [];\n\tconst rangeBoundaries = new Set();\n\n\tconst drawRange = geo.drawRange;\n\tconst drawRangeStart = drawRange.start / 3;\n\tconst drawRangeEnd = ( drawRange.start + drawRange.count ) / 3;\n\tfor ( const group of geo.groups ) {\n\n\t\tconst groupStart = group.start / 3;\n\t\tconst groupEnd = ( group.start + group.count ) / 3;\n\t\trangeBoundaries.add( Math.max( drawRangeStart, groupStart ) );\n\t\trangeBoundaries.add( Math.min( drawRangeEnd, groupEnd ) );\n\n\t}\n\n\n\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\n\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\n\n\t\tconst start = sortedBoundaries[ i ];\n\t\tconst end = sortedBoundaries[ i + 1 ];\n\n\t\tranges.push( {\n\t\t\toffset: Math.floor( start ),\n\t\t\tcount: Math.floor( end - start ),\n\t\t} );\n\n\t}\n\n\treturn ranges;\n\n}\n\nexport function hasGroupGaps( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\treturn false;\n\n\t}\n\n\tconst vertexCount = getTriCount( geometry );\n\tconst groups = getRootIndexRanges( geometry )\n\t\t.sort( ( a, b ) => a.offset - b.offset );\n\n\tconst finalGroup = groups[ groups.length - 1 ];\n\tfinalGroup.count = Math.min( vertexCount - finalGroup.offset, finalGroup.count );\n\n\tlet total = 0;\n\tgroups.forEach( ( { count } ) => total += count );\n\treturn vertexCount !== total;\n\n}\n","export function arrayToBox( nodeIndex32, array, target ) {\n\n\ttarget.min.x = array[ nodeIndex32 ];\n\ttarget.min.y = array[ nodeIndex32 + 1 ];\n\ttarget.min.z = array[ nodeIndex32 + 2 ];\n\n\ttarget.max.x = array[ nodeIndex32 + 3 ];\n\ttarget.max.y = array[ nodeIndex32 + 4 ];\n\ttarget.max.z = array[ nodeIndex32 + 5 ];\n\n\treturn target;\n\n}\n\nexport function makeEmptyBounds( target ) {\n\n\ttarget[ 0 ] = target[ 1 ] = target[ 2 ] = Infinity;\n\ttarget[ 3 ] = target[ 4 ] = target[ 5 ] = - Infinity;\n\n}\n\nexport function getLongestEdgeIndex( bounds ) {\n\n\tlet splitDimIdx = - 1;\n\tlet splitDist = - Infinity;\n\n\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\tconst dist = bounds[ i + 3 ] - bounds[ i ];\n\t\tif ( dist > splitDist ) {\n\n\t\t\tsplitDist = dist;\n\t\t\tsplitDimIdx = i;\n\n\t\t}\n\n\t}\n\n\treturn splitDimIdx;\n\n}\n\n// copies bounds a into bounds b\nexport function copyBounds( source, target ) {\n\n\ttarget.set( source );\n\n}\n\n// sets bounds target to the union of bounds a and b\nexport function unionBounds( a, b, target ) {\n\n\tlet aVal, bVal;\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst d3 = d + 3;\n\n\t\t// set the minimum values\n\t\taVal = a[ d ];\n\t\tbVal = b[ d ];\n\t\ttarget[ d ] = aVal < bVal ? aVal : bVal;\n\n\t\t// set the max values\n\t\taVal = a[ d3 ];\n\t\tbVal = b[ d3 ];\n\t\ttarget[ d3 ] = aVal > bVal ? aVal : bVal;\n\n\t}\n\n}\n\n// expands the given bounds by the provided triangle bounds\nexport function expandByTriangleBounds( startIndex, triangleBounds, bounds ) {\n\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst tCenter = triangleBounds[ startIndex + 2 * d ];\n\t\tconst tHalf = triangleBounds[ startIndex + 2 * d + 1 ];\n\n\t\tconst tMin = tCenter - tHalf;\n\t\tconst tMax = tCenter + tHalf;\n\n\t\tif ( tMin < bounds[ d ] ) {\n\n\t\t\tbounds[ d ] = tMin;\n\n\t\t}\n\n\t\tif ( tMax > bounds[ d + 3 ] ) {\n\n\t\t\tbounds[ d + 3 ] = tMax;\n\n\t\t}\n\n\t}\n\n}\n\n// compute bounds surface area\nexport function computeSurfaceArea( bounds ) {\n\n\tconst d0 = bounds[ 3 ] - bounds[ 0 ];\n\tconst d1 = bounds[ 4 ] - bounds[ 1 ];\n\tconst d2 = bounds[ 5 ] - bounds[ 2 ];\n\n\treturn 2 * ( d0 * d1 + d1 * d2 + d2 * d0 );\n\n}\n","import { FLOAT32_EPSILON } from '../Constants.js';\nimport { makeEmptyBounds } from '../../utils/ArrayBoxUtilities.js';\nimport { getTriCount } from './geometryUtils.js';\n\n// computes the union of the bounds of all of the given triangles and puts the resulting box in target. If\n// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.\n// These are computed together to avoid redundant accesses to bounds array.\nexport function getBounds( triangleBounds, offset, count, target, centroidTarget = null ) {\n\n\tlet minx = Infinity;\n\tlet miny = Infinity;\n\tlet minz = Infinity;\n\tlet maxx = - Infinity;\n\tlet maxy = - Infinity;\n\tlet maxz = - Infinity;\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tconst includeCentroid = centroidTarget !== null;\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tconst hx = triangleBounds[ i + 1 ];\n\t\tconst lx = cx - hx;\n\t\tconst rx = cx + hx;\n\t\tif ( lx < minx ) minx = lx;\n\t\tif ( rx > maxx ) maxx = rx;\n\t\tif ( includeCentroid && cx < cminx ) cminx = cx;\n\t\tif ( includeCentroid && cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tconst hy = triangleBounds[ i + 3 ];\n\t\tconst ly = cy - hy;\n\t\tconst ry = cy + hy;\n\t\tif ( ly < miny ) miny = ly;\n\t\tif ( ry > maxy ) maxy = ry;\n\t\tif ( includeCentroid && cy < cminy ) cminy = cy;\n\t\tif ( includeCentroid && cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tconst hz = triangleBounds[ i + 5 ];\n\t\tconst lz = cz - hz;\n\t\tconst rz = cz + hz;\n\t\tif ( lz < minz ) minz = lz;\n\t\tif ( rz > maxz ) maxz = rz;\n\t\tif ( includeCentroid && cz < cminz ) cminz = cz;\n\t\tif ( includeCentroid && cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\ttarget[ 0 ] = minx;\n\ttarget[ 1 ] = miny;\n\ttarget[ 2 ] = minz;\n\n\ttarget[ 3 ] = maxx;\n\ttarget[ 4 ] = maxy;\n\ttarget[ 5 ] = maxz;\n\n\tif ( includeCentroid ) {\n\n\t\tcentroidTarget[ 0 ] = cminx;\n\t\tcentroidTarget[ 1 ] = cminy;\n\t\tcentroidTarget[ 2 ] = cminz;\n\n\t\tcentroidTarget[ 3 ] = cmaxx;\n\t\tcentroidTarget[ 4 ] = cmaxy;\n\t\tcentroidTarget[ 5 ] = cmaxz;\n\n\t}\n\n}\n\n// A stand alone function for retrieving the centroid bounds.\nexport function getCentroidBounds( triangleBounds, offset, count, centroidTarget ) {\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tif ( cx < cminx ) cminx = cx;\n\t\tif ( cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tif ( cy < cminy ) cminy = cy;\n\t\tif ( cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tif ( cz < cminz ) cminz = cz;\n\t\tif ( cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\tcentroidTarget[ 0 ] = cminx;\n\tcentroidTarget[ 1 ] = cminy;\n\tcentroidTarget[ 2 ] = cminz;\n\n\tcentroidTarget[ 3 ] = cmaxx;\n\tcentroidTarget[ 4 ] = cmaxy;\n\tcentroidTarget[ 5 ] = cmaxz;\n\n}\n\n\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\nexport function computeTriangleBounds( geo, fullBounds ) {\n\n\t// clear the bounds to empty\n\tmakeEmptyBounds( fullBounds );\n\n\tconst posAttr = geo.attributes.position;\n\tconst index = geo.index ? geo.index.array : null;\n\tconst triCount = getTriCount( geo );\n\tconst triangleBounds = new Float32Array( triCount * 6 );\n\tconst normalized = posAttr.normalized;\n\n\t// used for non-normalized positions\n\tconst posArr = posAttr.array;\n\n\t// support for an interleaved position buffer\n\tconst bufferOffset = posAttr.offset || 0;\n\tlet stride = 3;\n\tif ( posAttr.isInterleavedBufferAttribute ) {\n\n\t\tstride = posAttr.data.stride;\n\n\t}\n\n\t// used for normalized positions\n\tconst getters = [ 'getX', 'getY', 'getZ' ];\n\n\tfor ( let tri = 0; tri < triCount; tri ++ ) {\n\n\t\tconst tri3 = tri * 3;\n\t\tconst tri6 = tri * 6;\n\n\t\tlet ai = tri3 + 0;\n\t\tlet bi = tri3 + 1;\n\t\tlet ci = tri3 + 2;\n\n\t\tif ( index ) {\n\n\t\t\tai = index[ ai ];\n\t\t\tbi = index[ bi ];\n\t\t\tci = index[ ci ];\n\n\t\t}\n\n\t\t// we add the stride and offset here since we access the array directly\n\t\t// below for the sake of performance\n\t\tif ( ! normalized ) {\n\n\t\t\tai = ai * stride + bufferOffset;\n\t\t\tbi = bi * stride + bufferOffset;\n\t\t\tci = ci * stride + bufferOffset;\n\n\t\t}\n\n\t\tfor ( let el = 0; el < 3; el ++ ) {\n\n\t\t\tlet a, b, c;\n\n\t\t\tif ( normalized ) {\n\n\t\t\t\ta = posAttr[ getters[ el ] ]( ai );\n\t\t\t\tb = posAttr[ getters[ el ] ]( bi );\n\t\t\t\tc = posAttr[ getters[ el ] ]( ci );\n\n\t\t\t} else {\n\n\t\t\t\ta = posArr[ ai + el ];\n\t\t\t\tb = posArr[ bi + el ];\n\t\t\t\tc = posArr[ ci + el ];\n\n\t\t\t}\n\n\t\t\tlet min = a;\n\t\t\tif ( b < min ) min = b;\n\t\t\tif ( c < min ) min = c;\n\n\t\t\tlet max = a;\n\t\t\tif ( b > max ) max = b;\n\t\t\tif ( c > max ) max = c;\n\n\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\n\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\n\t\t\t// worked with.\n\t\t\tconst halfExtents = ( max - min ) / 2;\n\t\t\tconst el2 = el * 2;\n\t\t\ttriangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;\n\t\t\ttriangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\n\n\t\t\tif ( min < fullBounds[ el ] ) fullBounds[ el ] = min;\n\t\t\tif ( max > fullBounds[ el + 3 ] ) fullBounds[ el + 3 ] = max;\n\n\t\t}\n\n\t}\n\n\treturn triangleBounds;\n\n}\n","import { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByTriangleBounds } from '../../utils/ArrayBoxUtilities.js';\nimport { CENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST } from '../Constants.js';\n\nconst BIN_COUNT = 32;\nconst binsSort = ( a, b ) => a.candidate - b.candidate;\nconst sahBins = new Array( BIN_COUNT ).fill().map( () => {\n\n\treturn {\n\n\t\tcount: 0,\n\t\tbounds: new Float32Array( 6 ),\n\t\trightCacheBounds: new Float32Array( 6 ),\n\t\tleftCacheBounds: new Float32Array( 6 ),\n\t\tcandidate: 0,\n\n\t};\n\n} );\nconst leftBounds = new Float32Array( 6 );\n\nexport function getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {\n\n\tlet axis = - 1;\n\tlet pos = 0;\n\n\t// Center\n\tif ( strategy === CENTER ) {\n\n\t\taxis = getLongestEdgeIndex( centroidBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\n\n\t\t}\n\n\t} else if ( strategy === AVERAGE ) {\n\n\t\taxis = getLongestEdgeIndex( nodeBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = getAverage( triangleBounds, offset, count, axis );\n\n\t\t}\n\n\t} else if ( strategy === SAH ) {\n\n\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\n\t\tlet bestCost = TRIANGLE_INTERSECT_COST * count;\n\n\t\t// iterate over all axes\n\t\tconst cStart = offset * 6;\n\t\tconst cEnd = ( offset + count ) * 6;\n\t\tfor ( let a = 0; a < 3; a ++ ) {\n\n\t\t\tconst axisLeft = centroidBoundingData[ a ];\n\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\n\t\t\tconst axisLength = axisRight - axisLeft;\n\t\t\tconst binWidth = axisLength / BIN_COUNT;\n\n\t\t\t// If we have fewer triangles than we're planning to split then just check all\n\t\t\t// the triangle positions because it will be faster.\n\t\t\tif ( count < BIN_COUNT / 4 ) {\n\n\t\t\t\t// initialize the bin candidates\n\t\t\t\tconst truncatedBins = [ ...sahBins ];\n\t\t\t\ttruncatedBins.length = count;\n\n\t\t\t\t// set the candidates\n\t\t\t\tlet b = 0;\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ b ];\n\t\t\t\t\tbin.candidate = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tbin.count = 0;\n\n\t\t\t\t\tconst {\n\t\t\t\t\t\tbounds,\n\t\t\t\t\t\tleftCacheBounds,\n\t\t\t\t\t\trightCacheBounds,\n\t\t\t\t\t} = bin;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bounds );\n\n\t\t\t\t}\n\n\t\t\t\ttruncatedBins.sort( binsSort );\n\n\t\t\t\t// remove redundant splits\n\t\t\t\tlet splitCount = count;\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\n\n\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\n\t\t\t\t\t\tsplitCount --;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// find the appropriate bin for each triangle and expand the bounds.\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst center = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\tif ( center >= bin.candidate ) {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.rightCacheBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.leftCacheBounds );\n\t\t\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// expand all the bounds\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\tconst leftCount = bin.count;\n\t\t\t\t\tconst rightCount = count - bin.count;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\n\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\n\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet rightProb = 0;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// reset the bins\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tbin.count = 0;\n\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\n\n\t\t\t\t\tconst bounds = bin.bounds;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over all center positions\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst triCenter = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\n\n\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\n\t\t\t\t\t// considered to be on the right side of the split\n\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\n\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\n\n\t\t\t\t\tconst bin = sahBins[ binIndex ];\n\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.bounds );\n\n\t\t\t\t}\n\n\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\n\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\n\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\n\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\n\n\t\t\t\t}\n\n\t\t\t\tlet leftCount = 0;\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst binCount = bin.count;\n\t\t\t\t\tconst bounds = bin.bounds;\n\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\n\n\t\t\t\t\t// don't do anything with the bounds if the new bounds have no triangles\n\t\t\t\t\tif ( binCount !== 0 ) {\n\n\t\t\t\t\t\tif ( leftCount === 0 ) {\n\n\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tleftCount += binCount;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tlet rightProb = 0;\n\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rightCount = count - leftCount;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tconsole.warn( `MeshBVH: Invalid build strategy value ${ strategy } used.` );\n\n\t}\n\n\treturn { axis, pos };\n\n}\n\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction getAverage( triangleBounds, offset, count, axis ) {\n\n\tlet avg = 0;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tavg += triangleBounds[ i * 6 + axis * 2 ];\n\n\t}\n\n\treturn avg / count;\n\n}\n","export class MeshBVHNode {\n\n\tconstructor() {\n\n\t\t// internal nodes have boundingData, left, right, and splitAxis\n\t\t// leaf nodes have offset and count (referring to primitives in the mesh geometry)\n\n\t}\n\n}\n","/********************************************************/\n/* This file is generated from \"sortUtils.template.js\". */\n/********************************************************/\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition( indirectBuffer, index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tlet t0 = index[ left * 3 + i ];\n\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\n\t\t\t\tindex[ right * 3 + i ] = t0;\n\n\t\t\t}\n\n\n\t\t\t// swap bounds\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\n\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\n\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nexport { partition };\n","/********************************************************/\n/* This file is generated from \"sortUtils.template.js\". */\n/********************************************************/\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition_indirect( indirectBuffer, index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\t\t\tlet t = indirectBuffer[ left ];\n\t\t\tindirectBuffer[ left ] = indirectBuffer[ right ];\n\t\t\tindirectBuffer[ right ] = t;\n\n\n\t\t\t// swap bounds\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\n\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\n\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nexport { partition_indirect };\n","import { ensureIndex, getFullGeometryRange, getRootIndexRanges, getTriCount, hasGroupGaps, } from './geometryUtils.js';\nimport { getBounds, getCentroidBounds, computeTriangleBounds } from './computeBoundsUtils.js';\nimport { getOptimalSplit } from './splitUtils.js';\nimport { MeshBVHNode } from '../MeshBVHNode.js';\nimport { BYTES_PER_NODE, IS_LEAFNODE_FLAG } from '../Constants.js';\n\nimport { partition } from './sortUtils.generated.js';\nimport { partition_indirect } from './sortUtils_indirect.generated.js';\n\nfunction generateIndirectBuffer( geometry, useSharedArrayBuffer ) {\n\n\tconst triCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\tconst useUint32 = triCount > 2 ** 16;\n\tconst byteCount = useUint32 ? 4 : 2;\n\n\tconst buffer = useSharedArrayBuffer ? new SharedArrayBuffer( triCount * byteCount ) : new ArrayBuffer( triCount * byteCount );\n\tconst indirectBuffer = useUint32 ? new Uint32Array( buffer ) : new Uint16Array( buffer );\n\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\n\n\t\tindirectBuffer[ i ] = i;\n\n\t}\n\n\treturn indirectBuffer;\n\n}\n\nfunction buildTree( bvh, options ) {\n\n\t// Compute the full bounds of the geometry at the same time as triangle bounds because\n\t// we'll need it for the root bounds in the case with no groups and it should be fast here.\n\t// We can't use the geometry bounding box if it's available because it may be out of date.\n\tconst geometry = bvh.geometry;\n\tconst indexArray = geometry.index ? geometry.index.array : null;\n\tconst maxDepth = options.maxDepth;\n\tconst verbose = options.verbose;\n\tconst maxLeafTris = options.maxLeafTris;\n\tconst strategy = options.strategy;\n\tconst onProgress = options.onProgress;\n\tconst totalTriangles = getTriCount( geometry );\n\tconst indirectBuffer = bvh._indirectBuffer;\n\tlet reachedMaxDepth = false;\n\n\tconst fullBounds = new Float32Array( 6 );\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\n\tconst triangleBounds = computeTriangleBounds( geometry, fullBounds );\n\tconst partionFunc = options.indirect ? partition_indirect : partition;\n\n\tconst roots = [];\n\tconst ranges = options.indirect ? getFullGeometryRange( geometry ) : getRootIndexRanges( geometry );\n\n\tif ( ranges.length === 1 ) {\n\n\t\tconst range = ranges[ 0 ];\n\t\tconst root = new MeshBVHNode();\n\t\troot.boundingData = fullBounds;\n\t\tgetCentroidBounds( triangleBounds, range.offset, range.count, cacheCentroidBoundingData );\n\n\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\n\t\troots.push( root );\n\n\t} else {\n\n\t\tfor ( let range of ranges ) {\n\n\t\t\tconst root = new MeshBVHNode();\n\t\t\troot.boundingData = new Float32Array( 6 );\n\t\t\tgetBounds( triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData );\n\n\t\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\n\t\t\troots.push( root );\n\n\t\t}\n\n\t}\n\n\treturn roots;\n\n\tfunction triggerProgress( trianglesProcessed ) {\n\n\t\tif ( onProgress ) {\n\n\t\t\tonProgress( trianglesProcessed / totalTriangles );\n\n\t\t}\n\n\t}\n\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\n\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\n\n\t\t\treachedMaxDepth = true;\n\t\t\tif ( verbose ) {\n\n\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\n\t\t\t\tconsole.warn( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// early out if we've met our capacity\n\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\t// Find where to split the volume\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\n\t\tif ( split.axis === - 1 ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\tconst splitOffset = partionFunc( indirectBuffer, indexArray, triangleBounds, offset, count, split );\n\n\t\t// create the two new child nodes\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\n\t\t} else {\n\n\t\t\tnode.splitAxis = split.axis;\n\n\t\t\t// create the left child and compute its bounding box\n\t\t\tconst left = new MeshBVHNode();\n\t\t\tconst lstart = offset;\n\t\t\tconst lcount = splitOffset - offset;\n\t\t\tnode.left = left;\n\t\t\tleft.boundingData = new Float32Array( 6 );\n\n\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t// repeat for right\n\t\t\tconst right = new MeshBVHNode();\n\t\t\tconst rstart = splitOffset;\n\t\t\tconst rcount = count - lcount;\n\t\t\tnode.right = right;\n\t\t\tright.boundingData = new Float32Array( 6 );\n\n\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nexport function buildPackedTree( bvh, options ) {\n\n\tconst geometry = bvh.geometry;\n\tif ( options.indirect ) {\n\n\t\tbvh._indirectBuffer = generateIndirectBuffer( geometry, options.useSharedArrayBuffer );\n\n\t\tif ( hasGroupGaps( geometry ) && ! options.verbose ) {\n\n\t\t\tconsole.warn(\n\t\t\t\t'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the \"indirect\" option. ' +\n\t\t\t\t'BVH may incorrectly report intersections on unrendered portions of the geometry.'\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\tif ( ! bvh._indirectBuffer ) {\n\n\t\tensureIndex( geometry, options );\n\n\t}\n\n\t// boundingData  \t\t\t\t: 6 float32\n\t// right / offset \t\t\t\t: 1 uint32\n\t// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\n\tconst roots = buildTree( bvh, options );\n\n\tlet float32Array;\n\tlet uint32Array;\n\tlet uint16Array;\n\tconst packedRoots = [];\n\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\tfor ( let i = 0; i < roots.length; i ++ ) {\n\n\t\tconst root = roots[ i ];\n\t\tlet nodeCount = countNodes( root );\n\n\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\n\t\tfloat32Array = new Float32Array( buffer );\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tpopulateBuffer( 0, root );\n\t\tpackedRoots.push( buffer );\n\n\t}\n\n\tbvh._roots = packedRoots;\n\treturn;\n\n\tfunction countNodes( node ) {\n\n\t\tif ( node.count ) {\n\n\t\t\treturn 1;\n\n\t\t} else {\n\n\t\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\n\n\t\t}\n\n\t}\n\n\tfunction populateBuffer( byteOffset, node ) {\n\n\t\tconst stride4Offset = byteOffset / 4;\n\t\tconst stride2Offset = byteOffset / 2;\n\t\tconst isLeaf = ! ! node.count;\n\t\tconst boundingData = node.boundingData;\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tfloat32Array[ stride4Offset + i ] = boundingData[ i ];\n\n\t\t}\n\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = node.offset;\n\t\t\tconst count = node.count;\n\t\t\tuint32Array[ stride4Offset + 6 ] = offset;\n\t\t\tuint16Array[ stride2Offset + 14 ] = count;\n\t\t\tuint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;\n\t\t\treturn byteOffset + BYTES_PER_NODE;\n\n\t\t} else {\n\n\t\t\tconst left = node.left;\n\t\t\tconst right = node.right;\n\t\t\tconst splitAxis = node.splitAxis;\n\n\t\t\tlet nextUnusedPointer;\n\t\t\tnextUnusedPointer = populateBuffer( byteOffset + BYTES_PER_NODE, left );\n\n\t\t\tif ( ( nextUnusedPointer / 4 ) > Math.pow( 2, 32 ) ) {\n\n\t\t\t\tthrow new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );\n\n\t\t\t}\n\n\t\t\tuint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;\n\t\t\tnextUnusedPointer = populateBuffer( nextUnusedPointer, right );\n\n\t\t\tuint32Array[ stride4Offset + 7 ] = splitAxis;\n\t\t\treturn nextUnusedPointer;\n\n\t\t}\n\n\t}\n\n}\n","import { Vector3 } from 'three';\n\nexport class SeparatingAxisBounds {\n\n\tconstructor() {\n\n\t\tthis.min = Infinity;\n\t\tthis.max = - Infinity;\n\n\t}\n\n\tsetFromPointsField( points, field ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = p[ field ];\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tsetFromPoints( axis, points ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = axis.dot( p );\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tisSeparated( other ) {\n\n\t\treturn this.min > other.max || other.min > this.max;\n\n\t}\n\n}\n\nSeparatingAxisBounds.prototype.setFromBox = ( function () {\n\n\tconst p = new Vector3();\n\treturn function setFromBox( axis, box ) {\n\n\t\tconst boxMin = box.min;\n\t\tconst boxMax = box.max;\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tp.x = boxMin.x * x + boxMax.x * ( 1 - x );\n\t\t\t\t\tp.y = boxMin.y * y + boxMax.y * ( 1 - y );\n\t\t\t\t\tp.z = boxMin.z * z + boxMax.z * ( 1 - z );\n\n\t\t\t\t\tconst val = axis.dot( p );\n\t\t\t\t\tmin = Math.min( val, min );\n\t\t\t\t\tmax = Math.max( val, max );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t};\n\n} )();\n\nexport const areIntersecting = ( function () {\n\n\tconst cacheSatBounds = new SeparatingAxisBounds();\n\treturn function areIntersecting( shape1, shape2 ) {\n\n\t\tconst points1 = shape1.points;\n\t\tconst satAxes1 = shape1.satAxes;\n\t\tconst satBounds1 = shape1.satBounds;\n\n\t\tconst points2 = shape2.points;\n\t\tconst satAxes2 = shape2.satAxes;\n\t\tconst satBounds2 = shape2.satBounds;\n\n\t\t// check axes of the first shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds1[ i ];\n\t\t\tconst sa = satAxes1[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points2 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check axes of the second shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds2[ i ];\n\t\t\tconst sa = satAxes2[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points1 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t};\n\n} )();\n","import { Vector3, Vector2, Plane, Line3 } from 'three';\n\nexport const closestPointLineToLine = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst v02 = new Vector3();\n\treturn function closestPointLineToLine( l1, l2, result ) {\n\n\t\tconst v0 = l1.start;\n\t\tconst v10 = dir1;\n\t\tconst v2 = l2.start;\n\t\tconst v32 = dir2;\n\n\t\tv02.subVectors( v0, v2 );\n\t\tdir1.subVectors( l1.end, l1.start );\n\t\tdir2.subVectors( l2.end, l2.start );\n\n\t\t// float d0232 = v02.Dot(v32);\n\t\tconst d0232 = v02.dot( v32 );\n\n\t\t// float d3210 = v32.Dot(v10);\n\t\tconst d3210 = v32.dot( v10 );\n\n\t\t// float d3232 = v32.Dot(v32);\n\t\tconst d3232 = v32.dot( v32 );\n\n\t\t// float d0210 = v02.Dot(v10);\n\t\tconst d0210 = v02.dot( v10 );\n\n\t\t// float d1010 = v10.Dot(v10);\n\t\tconst d1010 = v10.dot( v10 );\n\n\t\t// float denom = d1010*d3232 - d3210*d3210;\n\t\tconst denom = d1010 * d3232 - d3210 * d3210;\n\n\t\tlet d, d2;\n\t\tif ( denom !== 0 ) {\n\n\t\t\td = ( d0232 * d3210 - d0210 * d3232 ) / denom;\n\n\t\t} else {\n\n\t\t\td = 0;\n\n\t\t}\n\n\t\td2 = ( d0232 + d * d3210 ) / d3232;\n\n\t\tresult.x = d;\n\t\tresult.y = d2;\n\n\t};\n\n} )();\n\nexport const closestPointsSegmentToSegment = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\n\tconst paramResult = new Vector2();\n\tconst temp1 = new Vector3();\n\tconst temp2 = new Vector3();\n\treturn function closestPointsSegmentToSegment( l1, l2, target1, target2 ) {\n\n\t\tclosestPointLineToLine( l1, l2, paramResult );\n\n\t\tlet d = paramResult.x;\n\t\tlet d2 = paramResult.y;\n\t\tif ( d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1 ) {\n\n\t\t\tl1.at( d, target1 );\n\t\t\tl2.at( d2, target2 );\n\n\t\t\treturn;\n\n\t\t} else if ( d >= 0 && d <= 1 ) {\n\n\t\t\t// Only d2 is out of bounds.\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tl2.at( 0, target2 );\n\n\t\t\t} else {\n\n\t\t\t\tl2.at( 1, target2 );\n\n\t\t\t}\n\n\t\t\tl1.closestPointToPoint( target2, true, target1 );\n\t\t\treturn;\n\n\t\t} else if ( d2 >= 0 && d2 <= 1 ) {\n\n\t\t\t// Only d is out of bounds.\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tl1.at( 0, target1 );\n\n\t\t\t} else {\n\n\t\t\t\tl1.at( 1, target1 );\n\n\t\t\t}\n\n\t\t\tl2.closestPointToPoint( target1, true, target2 );\n\t\t\treturn;\n\n\t\t} else {\n\n\t\t\t// Both u and u2 are out of bounds.\n\t\t\tlet p;\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tp = l1.start;\n\n\t\t\t} else {\n\n\t\t\t\tp = l1.end;\n\n\t\t\t}\n\n\t\t\tlet p2;\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tp2 = l2.start;\n\n\t\t\t} else {\n\n\t\t\t\tp2 = l2.end;\n\n\t\t\t}\n\n\t\t\tconst closestPoint = temp1;\n\t\t\tconst closestPoint2 = temp2;\n\t\t\tl1.closestPointToPoint( p2, true, temp1 );\n\t\t\tl2.closestPointToPoint( p, true, temp2 );\n\n\t\t\tif ( closestPoint.distanceToSquared( p2 ) <= closestPoint2.distanceToSquared( p ) ) {\n\n\t\t\t\ttarget1.copy( closestPoint );\n\t\t\t\ttarget2.copy( p2 );\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\ttarget1.copy( p );\n\t\t\t\ttarget2.copy( closestPoint2 );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n} )();\n\n\nexport const sphereIntersectTriangle = ( function () {\n\n\t// https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\n\tconst closestPointTemp = new Vector3();\n\tconst projectedPointTemp = new Vector3();\n\tconst planeTemp = new Plane();\n\tconst lineTemp = new Line3();\n\treturn function sphereIntersectTriangle( sphere, triangle ) {\n\n\t\tconst { radius, center } = sphere;\n\t\tconst { a, b, c } = triangle;\n\n\t\t// phase 1\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = b;\n\t\tconst closestPoint1 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint1.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint2 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint2.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = b;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint3 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint3.distanceTo( center ) <= radius ) return true;\n\n\t\t// phase 2\n\t\tconst plane = triangle.getPlane( planeTemp );\n\t\tconst dp = Math.abs( plane.distanceToPoint( center ) );\n\t\tif ( dp <= radius ) {\n\n\t\t\tconst pp = plane.projectPoint( center, projectedPointTemp );\n\t\t\tconst cp = triangle.containsPoint( pp );\n\t\t\tif ( cp ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n} )();\n","import { Triangle, Vector3, Line3, Sphere, Plane } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { closestPointsSegmentToSegment, sphereIntersectTriangle } from './MathUtilities.js';\n\nconst ZERO_EPSILON = 1e-15;\nfunction isNearZero( value ) {\n\n\treturn Math.abs( value ) < ZERO_EPSILON;\n\n}\n\nexport class ExtendedTriangle extends Triangle {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.isExtendedTriangle = true;\n\t\tthis.satAxes = new Array( 4 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 4 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.points = [ this.a, this.b, this.c ];\n\t\tthis.sphere = new Sphere();\n\t\tthis.plane = new Plane();\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn sphereIntersectTriangle( sphere, this );\n\n\t}\n\n\tupdate() {\n\n\t\tconst a = this.a;\n\t\tconst b = this.b;\n\t\tconst c = this.c;\n\t\tconst points = this.points;\n\n\t\tconst satAxes = this.satAxes;\n\t\tconst satBounds = this.satBounds;\n\n\t\tconst axis0 = satAxes[ 0 ];\n\t\tconst sab0 = satBounds[ 0 ];\n\t\tthis.getNormal( axis0 );\n\t\tsab0.setFromPoints( axis0, points );\n\n\t\tconst axis1 = satAxes[ 1 ];\n\t\tconst sab1 = satBounds[ 1 ];\n\t\taxis1.subVectors( a, b );\n\t\tsab1.setFromPoints( axis1, points );\n\n\t\tconst axis2 = satAxes[ 2 ];\n\t\tconst sab2 = satBounds[ 2 ];\n\t\taxis2.subVectors( b, c );\n\t\tsab2.setFromPoints( axis2, points );\n\n\t\tconst axis3 = satAxes[ 3 ];\n\t\tconst sab3 = satBounds[ 3 ];\n\t\taxis3.subVectors( c, a );\n\t\tsab3.setFromPoints( axis3, points );\n\n\t\tthis.sphere.setFromPoints( this.points );\n\t\tthis.plane.setFromNormalAndCoplanarPoint( axis0, a );\n\t\tthis.needsUpdate = false;\n\n\t}\n\n}\n\nExtendedTriangle.prototype.closestPointToSegment = ( function () {\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\tconst edge = new Line3();\n\n\treturn function distanceToSegment( segment, target1 = null, target2 = null ) {\n\n\t\tconst { start, end } = segment;\n\t\tconst points = this.points;\n\t\tlet distSq;\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check the triangle edges\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst nexti = ( i + 1 ) % 3;\n\t\t\tedge.start.copy( points[ i ] );\n\t\t\tedge.end.copy( points[ nexti ] );\n\n\t\t\tclosestPointsSegmentToSegment( edge, segment, point1, point2 );\n\n\t\t\tdistSq = point1.distanceToSquared( point2 );\n\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check end points\n\t\tthis.closestPointToPoint( start, point1 );\n\t\tdistSq = start.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( start );\n\n\t\t}\n\n\t\tthis.closestPointToPoint( end, point1 );\n\t\tdistSq = end.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( end );\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n\nExtendedTriangle.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri2 = new ExtendedTriangle();\n\tconst arr1 = new Array( 3 );\n\tconst arr2 = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\tconst dir = new Vector3();\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst tempDir = new Vector3();\n\tconst edge = new Line3();\n\tconst edge1 = new Line3();\n\tconst edge2 = new Line3();\n\tconst tempPoint = new Vector3();\n\n\tfunction triIntersectPlane( tri, plane, targetEdge ) {\n\n\t\t// find the edge that intersects the other triangle plane\n\t\tconst points = tri.points;\n\t\tlet count = 0;\n\t\tlet startPointIntersection = - 1;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst { start, end } = edge;\n\t\t\tstart.copy( points[ i ] );\n\t\t\tend.copy( points[ ( i + 1 ) % 3 ] );\n\t\t\tedge.delta( dir );\n\n\t\t\tconst startIntersects = isNearZero( plane.distanceToPoint( start ) );\n\t\t\tif ( isNearZero( plane.normal.dot( dir ) ) && startIntersects ) {\n\n\t\t\t\t// if the edge lies on the plane then take the line\n\t\t\t\ttargetEdge.copy( edge );\n\t\t\t\tcount = 2;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// check if the start point is near the plane because \"intersectLine\" is not robust to that case\n\t\t\tconst doesIntersect = plane.intersectLine( edge, tempPoint );\n\t\t\tif ( ! doesIntersect && startIntersects ) {\n\n\t\t\t\ttempPoint.copy( start );\n\n\t\t\t}\n\n\t\t\t// ignore the end point\n\t\t\tif ( ( doesIntersect || startIntersects ) && ! isNearZero( tempPoint.distanceTo( end ) ) ) {\n\n\t\t\t\tif ( count <= 1 ) {\n\n\t\t\t\t\t// assign to the start or end point and save which index was snapped to\n\t\t\t\t\t// the start point if necessary\n\t\t\t\t\tconst point = count === 1 ? targetEdge.start : targetEdge.end;\n\t\t\t\t\tpoint.copy( tempPoint );\n\t\t\t\t\tif ( startIntersects ) {\n\n\t\t\t\t\t\tstartPointIntersection = count;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( count >= 2 ) {\n\n\t\t\t\t\t// if we're here that means that there must have been one point that had\n\t\t\t\t\t// snapped to the start point so replace it here\n\t\t\t\t\tconst point = startPointIntersection === 1 ? targetEdge.start : targetEdge.end;\n\t\t\t\t\tpoint.copy( tempPoint );\n\t\t\t\t\tcount = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tcount ++;\n\t\t\t\tif ( count === 2 && startPointIntersection === - 1 ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn count;\n\n\t}\n\n\t// TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\n\t// be a line contained by both triangles if not a different special case somehow represented in the return result.\n\treturn function intersectsTriangle( other, target = null, suppressLog = false ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! other.isExtendedTriangle ) {\n\n\t\t\tsaTri2.copy( other );\n\t\t\tsaTri2.update();\n\t\t\tother = saTri2;\n\n\t\t} else if ( other.needsUpdate ) {\n\n\t\t\tother.update();\n\n\t\t}\n\n\t\tconst plane1 = this.plane;\n\t\tconst plane2 = other.plane;\n\n\t\tif ( Math.abs( plane1.normal.dot( plane2.normal ) ) > 1.0 - 1e-10 ) {\n\n\t\t\t// perform separating axis intersection test only for coplanar triangles\n\t\t\tconst satBounds1 = this.satBounds;\n\t\t\tconst satAxes1 = this.satAxes;\n\t\t\tarr2[ 0 ] = other.a;\n\t\t\tarr2[ 1 ] = other.b;\n\t\t\tarr2[ 2 ] = other.c;\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sb = satBounds1[ i ];\n\t\t\t\tconst sa = satAxes1[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr2 );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\tconst satBounds2 = other.satBounds;\n\t\t\tconst satAxes2 = other.satAxes;\n\t\t\tarr1[ 0 ] = this.a;\n\t\t\tarr1[ 1 ] = this.b;\n\t\t\tarr1[ 2 ] = this.c;\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sb = satBounds2[ i ];\n\t\t\t\tconst sa = satAxes2[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr1 );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\t// check crossed axes\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sa1 = satAxes1[ i ];\n\t\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\t\tconst sa2 = satAxes2[ i2 ];\n\t\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, arr1 );\n\t\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, arr2 );\n\t\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( target ) {\n\n\t\t\t\t// TODO find two points that intersect on the edges and make that the result\n\t\t\t\tif ( ! suppressLog ) {\n\n\t\t\t\t\tconsole.warn( 'ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.' );\n\n\t\t\t\t}\n\n\t\t\t\ttarget.start.set( 0, 0, 0 );\n\t\t\t\ttarget.end.set( 0, 0, 0 );\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\t// find the edge that intersects the other triangle plane\n\t\t\tconst count1 = triIntersectPlane( this, plane2, edge1 );\n\t\t\tif ( count1 === 1 && other.containsPoint( edge1.end ) ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( edge1.end );\n\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( count1 !== 2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// find the other triangles edge that intersects this plane\n\t\t\tconst count2 = triIntersectPlane( other, plane1, edge2 );\n\t\t\tif ( count2 === 1 && this.containsPoint( edge2.end ) ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( edge2.end );\n\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( count2 !== 2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// find swap the second edge so both lines are running the same direction\n\t\t\tedge1.delta( dir1 );\n\t\t\tedge2.delta( dir2 );\n\n\t\t\tif ( dir1.dot( dir2 ) < 0 ) {\n\n\t\t\t\tlet tmp = edge2.start;\n\t\t\t\tedge2.start = edge2.end;\n\t\t\t\tedge2.end = tmp;\n\n\t\t\t}\n\n\t\t\t// check if the edges are overlapping\n\t\t\tconst s1 = edge1.start.dot( dir1 );\n\t\t\tconst e1 = edge1.end.dot( dir1 );\n\t\t\tconst s2 = edge2.start.dot( dir1 );\n\t\t\tconst e2 = edge2.end.dot( dir1 );\n\t\t\tconst separated1 = e1 < s2;\n\t\t\tconst separated2 = s1 < e2;\n\n\t\t\tif ( s1 !== e2 && s2 !== e1 && separated1 === separated2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// assign the target output\n\t\t\tif ( target ) {\n\n\t\t\t\ttempDir.subVectors( edge1.start, edge2.start );\n\t\t\t\tif ( tempDir.dot( dir1 ) > 0 ) {\n\n\t\t\t\t\ttarget.start.copy( edge1.start );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget.start.copy( edge2.start );\n\n\t\t\t\t}\n\n\t\t\t\ttempDir.subVectors( edge1.end, edge2.end );\n\t\t\t\tif ( tempDir.dot( dir1 ) < 0 ) {\n\n\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToTriangle = ( function () {\n\n\tconst point = new Vector3();\n\tconst point2 = new Vector3();\n\tconst cornerFields = [ 'a', 'b', 'c' ];\n\tconst line1 = new Line3();\n\tconst line2 = new Line3();\n\n\treturn function distanceToTriangle( other, target1 = null, target2 = null ) {\n\n\t\tconst lineTarget = target1 || target2 ? line1 : null;\n\t\tif ( this.intersectsTriangle( other, lineTarget ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tif ( target1 ) lineTarget.getCenter( target1 );\n\t\t\t\tif ( target2 ) lineTarget.getCenter( target2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check all point distances\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tlet dist;\n\t\t\tconst field = cornerFields[ i ];\n\t\t\tconst otherVec = other[ field ];\n\t\t\tthis.closestPointToPoint( otherVec, point );\n\n\t\t\tdist = otherVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\tif ( target2 ) target2.copy( otherVec );\n\n\t\t\t}\n\n\n\t\t\tconst thisVec = this[ field ];\n\t\t\tother.closestPointToPoint( thisVec, point );\n\n\t\t\tdist = thisVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( thisVec );\n\t\t\t\tif ( target2 ) target2.copy( point );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst f11 = cornerFields[ i ];\n\t\t\tconst f12 = cornerFields[ ( i + 1 ) % 3 ];\n\t\t\tline1.set( this[ f11 ], this[ f12 ] );\n\t\t\tfor ( let i2 = 0; i2 < 3; i2 ++ ) {\n\n\t\t\t\tconst f21 = cornerFields[ i2 ];\n\t\t\t\tconst f22 = cornerFields[ ( i2 + 1 ) % 3 ];\n\t\t\t\tline2.set( other[ f21 ], other[ f22 ] );\n\n\t\t\t\tclosestPointsSegmentToSegment( line1, line2, point, point2 );\n\n\t\t\t\tconst dist = point.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n","import { Vector3, Matrix4, Line3 } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { ExtendedTriangle } from './ExtendedTriangle.js';\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\n\nexport class OrientedBox {\n\n\tconstructor( min, max, matrix ) {\n\n\t\tthis.isOrientedBox = true;\n\t\tthis.min = new Vector3();\n\t\tthis.max = new Vector3();\n\t\tthis.matrix = new Matrix4();\n\t\tthis.invMatrix = new Matrix4();\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\n\t\tthis.satAxes = new Array( 3 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.needsUpdate = false;\n\n\t\tif ( min ) this.min.copy( min );\n\t\tif ( max ) this.max.copy( max );\n\t\tif ( matrix ) this.matrix.copy( matrix );\n\n\t}\n\n\tset( min, max, matrix ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\t\tthis.matrix.copy( matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.min.copy( other.min );\n\t\tthis.max.copy( other.max );\n\t\tthis.matrix.copy( other.matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nOrientedBox.prototype.update = ( function () {\n\n\treturn function update() {\n\n\t\tconst matrix = this.matrix;\n\t\tconst min = this.min;\n\t\tconst max = this.max;\n\n\t\tconst points = this.points;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\n\t\t\t\t\tconst v = points[ i ];\n\t\t\t\t\tv.x = x ? max.x : min.x;\n\t\t\t\t\tv.y = y ? max.y : min.y;\n\t\t\t\t\tv.z = z ? max.z : min.z;\n\n\t\t\t\t\tv.applyMatrix4( matrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst minVec = points[ 0 ];\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst index = 1 << i;\n\t\t\tconst pi = points[ index ];\n\n\t\t\taxis.subVectors( minVec, pi );\n\t\t\tsb.setFromPoints( axis, points );\n\n\t\t}\n\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\n\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\n\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\n\n\t\tthis.invMatrix.copy( this.matrix ).invert();\n\t\tthis.needsUpdate = false;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsBox = ( function () {\n\n\tconst aabbBounds = new SeparatingAxisBounds();\n\treturn function intersectsBox( box ) {\n\n\t\t// TODO: should this be doing SAT against the AABB?\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\n\t\taabbBounds.min = min.x;\n\t\taabbBounds.max = max.x;\n\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.y;\n\t\taabbBounds.max = max.y;\n\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.z;\n\t\taabbBounds.max = max.z;\n\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\taabbBounds.setFromBox( axis, box );\n\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri = new ExtendedTriangle();\n\tconst pointsArr = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\treturn function intersectsTriangle( triangle ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! triangle.isExtendedTriangle ) {\n\n\t\t\tsaTri.copy( triangle );\n\t\t\tsaTri.update();\n\t\t\ttriangle = saTri;\n\n\t\t} else if ( triangle.needsUpdate ) {\n\n\t\t\ttriangle.update();\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\n\t\tpointsArr[ 0 ] = triangle.a;\n\t\tpointsArr[ 1 ] = triangle.b;\n\t\tpointsArr[ 2 ] = triangle.c;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst sa = satAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\tconst triSatBounds = triangle.satBounds;\n\t\tconst triSatAxes = triangle.satAxes;\n\t\tconst points = this.points;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = triSatBounds[ i ];\n\t\t\tconst sa = triSatAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, points );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check crossed axes\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sa1 = satAxes[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\tconst sa2 = triSatAxes[ i2 ];\n\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\n\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\n\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.closestPointToPoint = ( function () {\n\n\treturn function closestPointToPoint( point, target1 ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\ttarget1\n\t\t\t.copy( point )\n\t\t\t.applyMatrix4( this.invMatrix )\n\t\t\t.clamp( this.min, this.max )\n\t\t\t.applyMatrix4( this.matrix );\n\n\t\treturn target1;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToBox = ( function () {\n\n\tconst xyzFields = [ 'x', 'y', 'z' ];\n\tconst segments1 = new Array( 12 ).fill().map( () => new Line3() );\n\tconst segments2 = new Array( 12 ).fill().map( () => new Line3() );\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\n\t// early out if we find a value below threshold\n\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( this.intersectsBox( box ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tbox.getCenter( point2 );\n\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\tbox.closestPointToPoint( point1, point2 );\n\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst threshold2 = threshold * threshold;\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst points = this.points;\n\n\n\t\t// iterate over every edge and compare distances\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check over all these points\n\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tpoint2.copy( p ).clamp( min, max );\n\n\t\t\tconst dist = p.distanceToSquared( point2 );\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( p );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate and check all line segment distances\n\t\tlet count = 0;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\n\n\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\n\n\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\n\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\n\n\t\t\t\t\t// get obb line segments\n\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst p1 = points[ index ];\n\t\t\t\t\tconst p2 = points[ index2 ];\n\t\t\t\t\tconst line1 = segments1[ count ];\n\t\t\t\t\tline1.set( p1, p2 );\n\n\n\t\t\t\t\t// get aabb line segments\n\t\t\t\t\tconst f1 = xyzFields[ i ];\n\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\n\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\n\t\t\t\t\tconst line2 = segments2[ count ];\n\t\t\t\t\tconst start = line2.start;\n\t\t\t\t\tconst end = line2.end;\n\n\t\t\t\t\tstart[ f1 ] = min[ f1 ];\n\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tend[ f1 ] = max[ f1 ];\n\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check all the other boxes point\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tpoint2.x = x ? max.x : min.x;\n\t\t\t\t\tpoint2.y = y ? max.y : min.y;\n\t\t\t\t\tpoint2.z = z ? max.z : min.z;\n\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 12; i ++ ) {\n\n\t\t\tconst l1 = segments1[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\n\n\t\t\t\tconst l2 = segments2[ i2 ];\n\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\n\t\t\t\tconst dist = point1.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n","export class PrimitivePool {\n\n\tconstructor( getNewPrimitive ) {\n\n\t\tthis._getNewPrimitive = getNewPrimitive;\n\t\tthis._primitives = [];\n\n\t}\n\n\tgetPrimitive() {\n\n\t\tconst primitives = this._primitives;\n\t\tif ( primitives.length === 0 ) {\n\n\t\t\treturn this._getNewPrimitive();\n\n\t\t} else {\n\n\t\t\treturn primitives.pop();\n\n\t\t}\n\n\t}\n\n\treleasePrimitive( primitive ) {\n\n\t\tthis._primitives.push( primitive );\n\n\t}\n\n}\n","import { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { PrimitivePool } from './PrimitivePool.js';\n\nclass ExtendedTrianglePoolBase extends PrimitivePool {\n\n\tconstructor() {\n\n\t\tsuper( () => new ExtendedTriangle() );\n\n\t}\n\n}\n\nexport const ExtendedTrianglePool = /* @__PURE__ */ new ExtendedTrianglePoolBase();\n","export function IS_LEAF( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 15 ] === 0xFFFF;\n\n}\n\nexport function OFFSET( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function COUNT( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 14 ];\n\n}\n\nexport function LEFT_NODE( n32 ) {\n\n\treturn n32 + 8;\n\n}\n\nexport function RIGHT_NODE( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function SPLIT_AXIS( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 7 ];\n\n}\n\nexport function BOUNDING_DATA_INDEX( n32 ) {\n\n\treturn n32;\n\n}\n","class _BufferStack {\n\n\tconstructor() {\n\n\t\tthis.float32Array = null;\n\t\tthis.uint16Array = null;\n\t\tthis.uint32Array = null;\n\n\t\tconst stack = [];\n\t\tlet prevBuffer = null;\n\t\tthis.setBuffer = buffer => {\n\n\t\t\tif ( prevBuffer ) {\n\n\t\t\t\tstack.push( prevBuffer );\n\n\t\t\t}\n\n\t\t\tprevBuffer = buffer;\n\t\t\tthis.float32Array = new Float32Array( buffer );\n\t\t\tthis.uint16Array = new Uint16Array( buffer );\n\t\t\tthis.uint32Array = new Uint32Array( buffer );\n\n\t\t};\n\n\t\tthis.clearBuffer = () => {\n\n\t\t\tprevBuffer = null;\n\t\t\tthis.float32Array = null;\n\t\t\tthis.uint16Array = null;\n\t\t\tthis.uint32Array = null;\n\n\t\t\tif ( stack.length !== 0 ) {\n\n\t\t\t\tthis.setBuffer( stack.pop() );\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n}\n\nexport const BufferStack = new _BufferStack();\n","import { Box3 } from 'three';\nimport { CONTAINED } from '../Constants.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\nlet _box1, _box2;\nconst boxStack = [];\nconst boxPool = /* @__PURE__ */ new PrimitivePool( () => new Box3() );\n\nexport function shapecast( bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset ) {\n\n\t// setup\n\t_box1 = boxPool.getPrimitive();\n\t_box2 = boxPool.getPrimitive();\n\tboxStack.push( _box1, _box2 );\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\n\tconst result = shapecastTraverse( 0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t// cleanup\n\tBufferStack.clearBuffer();\n\tboxPool.releasePrimitive( _box1 );\n\tboxPool.releasePrimitive( _box2 );\n\tboxStack.pop();\n\tboxStack.pop();\n\n\tconst length = boxStack.length;\n\tif ( length > 0 ) {\n\n\t\t_box2 = boxStack[ length - 1 ];\n\t\t_box1 = boxStack[ length - 2 ];\n\n\t}\n\n\treturn result;\n\n}\n\nfunction shapecastTraverse(\n\tnodeIndex32,\n\tgeometry,\n\tintersectsBoundsFunc,\n\tintersectsRangeFunc,\n\tnodeScoreFunc = null,\n\tnodeIndexByteOffset = 0, // offset for unique node identifier\n\tdepth = 0\n) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1 );\n\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1 );\n\n\t} else {\n\n\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tlet c1 = left;\n\t\tlet c2 = right;\n\n\t\tlet score1, score2;\n\t\tlet box1, box2;\n\t\tif ( nodeScoreFunc ) {\n\n\t\t\tbox1 = _box1;\n\t\t\tbox2 = _box2;\n\n\t\t\t// bounding data is not offset\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\tscore1 = nodeScoreFunc( box1 );\n\t\t\tscore2 = nodeScoreFunc( box2 );\n\n\t\t\tif ( score2 < score1 ) {\n\n\t\t\t\tc1 = right;\n\t\t\t\tc2 = left;\n\n\t\t\t\tconst temp = score1;\n\t\t\t\tscore1 = score2;\n\t\t\t\tscore2 = temp;\n\n\t\t\t\tbox1 = box2;\n\t\t\t\t// box2 is always set before use below\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Check box 1 intersection\n\t\tif ( ! box1 ) {\n\n\t\t\tbox1 = _box1;\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\n\t\t}\n\n\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\n\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );\n\n\t\tlet c1StopTraversal;\n\t\tif ( c1Intersection === CONTAINED ) {\n\n\t\t\tconst offset = getLeftOffset( c1 );\n\t\t\tconst end = getRightEndOffset( c1 );\n\t\t\tconst count = end - offset;\n\n\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1 );\n\n\t\t} else {\n\n\t\t\tc1StopTraversal =\n\t\t\t\tc1Intersection &&\n\t\t\t\tshapecastTraverse(\n\t\t\t\t\tc1,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\tdepth + 1\n\t\t\t\t);\n\n\t\t}\n\n\t\tif ( c1StopTraversal ) return true;\n\n\t\t// Check box 2 intersection\n\t\t// cached box2 will have been overwritten by previous traversal\n\t\tbox2 = _box2;\n\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\n\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );\n\n\t\tlet c2StopTraversal;\n\t\tif ( c2Intersection === CONTAINED ) {\n\n\t\t\tconst offset = getLeftOffset( c2 );\n\t\t\tconst end = getRightEndOffset( c2 );\n\t\t\tconst count = end - offset;\n\n\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2 );\n\n\t\t} else {\n\n\t\t\tc2StopTraversal =\n\t\t\t\tc2Intersection &&\n\t\t\t\tshapecastTraverse(\n\t\t\t\t\tc2,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\tdepth + 1\n\t\t\t\t);\n\n\t\t}\n\n\t\tif ( c2StopTraversal ) return true;\n\n\t\treturn false;\n\n\t\t// Define these inside the function so it has access to the local variables needed\n\t\t// when converting to the buffer equivalents\n\t\tfunction getLeftOffset( nodeIndex32 ) {\n\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\treturn OFFSET( nodeIndex32, uint32Array );\n\n\t\t}\n\n\t\tfunction getRightEndOffset( nodeIndex32 ) {\n\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\t// adjust offset to point to the right node\n\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\t// return the end offset of the triangle range\n\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\n\n\t\t}\n\n\t}\n\n}\n","import { Vector3 } from 'three';\n\nconst temp = /* @__PURE__ */ new Vector3();\nconst temp1 = /* @__PURE__ */ new Vector3();\n\nexport function closestPointToPoint(\n\tbvh,\n\tpoint,\n\ttarget = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\t// early out if under minThreshold\n\t// skip checking if over maxThreshold\n\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\n\t// returns Infinity if no value found\n\tconst minThresholdSq = minThreshold * minThreshold;\n\tconst maxThresholdSq = maxThreshold * maxThreshold;\n\tlet closestDistanceSq = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tbvh.shapecast(\n\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\n\t\t\t\treturn temp.distanceToSquared( point );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\n\n\t\t\t},\n\n\t\t\tintersectsTriangle: ( tri, triIndex ) => {\n\n\t\t\t\ttri.closestPointToPoint( point, temp );\n\t\t\t\tconst distSq = point.distanceToSquared( temp );\n\t\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\t\ttemp1.copy( temp );\n\t\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\t\tclosestDistanceTriIndex = triIndex;\n\n\t\t\t\t}\n\n\t\t\t\tif ( distSq < minThresholdSq ) {\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tif ( closestDistanceSq === Infinity ) return null;\n\n\tconst closestDistance = Math.sqrt( closestDistanceSq );\n\n\tif ( ! target.point ) target.point = temp1.clone();\n\telse target.point.copy( temp1 );\n\ttarget.distance = closestDistance,\n\ttarget.faceIndex = closestDistanceTriIndex;\n\n\treturn target;\n\n}\n","import { Vector3, Vector2, Triangle, DoubleSide, BackSide } from 'three';\n\n// Ripped and modified From THREE.js Mesh raycast\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\nconst _vA = /* @__PURE__ */ new Vector3();\nconst _vB = /* @__PURE__ */ new Vector3();\nconst _vC = /* @__PURE__ */ new Vector3();\n\nconst _uvA = /* @__PURE__ */ new Vector2();\nconst _uvB = /* @__PURE__ */ new Vector2();\nconst _uvC = /* @__PURE__ */ new Vector2();\n\nconst _normalA = /* @__PURE__ */ new Vector3();\nconst _normalB = /* @__PURE__ */ new Vector3();\nconst _normalC = /* @__PURE__ */ new Vector3();\n\nconst _intersectionPoint = /* @__PURE__ */ new Vector3();\nfunction checkIntersection( ray, pA, pB, pC, point, side ) {\n\n\tlet intersect;\n\tif ( side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, side !== DoubleSide, point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\tconst distance = ray.origin.distanceTo( point );\n\n\treturn {\n\n\t\tdistance: distance,\n\t\tpoint: point.clone(),\n\n\t};\n\n}\n\nfunction checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side ) {\n\n\t_vA.fromBufferAttribute( position, a );\n\t_vB.fromBufferAttribute( position, b );\n\t_vC.fromBufferAttribute( position, c );\n\n\tconst intersection = checkIntersection( ray, _vA, _vB, _vC, _intersectionPoint, side );\n\n\tif ( intersection ) {\n\n\t\tif ( uv ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv, a );\n\t\t\t_uvB.fromBufferAttribute( uv, b );\n\t\t\t_uvC.fromBufferAttribute( uv, c );\n\n\t\t\tintersection.uv = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t}\n\n\t\tif ( uv1 ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv1, a );\n\t\t\t_uvB.fromBufferAttribute( uv1, b );\n\t\t\t_uvC.fromBufferAttribute( uv1, c );\n\n\t\t\tintersection.uv1 = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t}\n\n\t\tif ( normal ) {\n\n\t\t\t_normalA.fromBufferAttribute( normal, a );\n\t\t\t_normalB.fromBufferAttribute( normal, b );\n\t\t\t_normalC.fromBufferAttribute( normal, c );\n\n\t\t\tintersection.normal = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new Vector3() );\n\t\t\tif ( intersection.normal.dot( ray.direction ) > 0 ) {\n\n\t\t\t\tintersection.normal.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( _vA, _vB, _vC, face.normal );\n\n\t\tintersection.face = face;\n\t\tintersection.faceIndex = a;\n\n\t}\n\n\treturn intersection;\n\n}\n\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\nfunction intersectTri( geo, side, ray, tri, intersections ) {\n\n\tconst triOffset = tri * 3;\n\tlet a = triOffset + 0;\n\tlet b = triOffset + 1;\n\tlet c = triOffset + 2;\n\n\tconst index = geo.index;\n\tif ( geo.index ) {\n\n\t\ta = index.getX( a );\n\t\tb = index.getX( b );\n\t\tc = index.getX( c );\n\n\t}\n\n\tconst { position, normal, uv, uv1 } = geo.attributes;\n\tconst intersection = checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side );\n\n\tif ( intersection ) {\n\n\t\tintersection.faceIndex = tri;\n\t\tif ( intersections ) intersections.push( intersection );\n\t\treturn intersection;\n\n\t}\n\n\treturn null;\n\n}\n\nexport { intersectTri };\n","\nimport { Vector2, Vector3, Triangle } from 'three';\n\n// sets the vertices of triangle `tri` with the 3 vertices after i\nexport function setTriangle( tri, i, index, pos ) {\n\n\tconst ta = tri.a;\n\tconst tb = tri.b;\n\tconst tc = tri.c;\n\n\tlet i0 = i;\n\tlet i1 = i + 1;\n\tlet i2 = i + 2;\n\tif ( index ) {\n\n\t\ti0 = index.getX( i0 );\n\t\ti1 = index.getX( i1 );\n\t\ti2 = index.getX( i2 );\n\n\t}\n\n\tta.x = pos.getX( i0 );\n\tta.y = pos.getY( i0 );\n\tta.z = pos.getZ( i0 );\n\n\ttb.x = pos.getX( i1 );\n\ttb.y = pos.getY( i1 );\n\ttb.z = pos.getZ( i1 );\n\n\ttc.x = pos.getX( i2 );\n\ttc.y = pos.getY( i2 );\n\ttc.z = pos.getZ( i2 );\n\n}\n\nconst tempV1 = /* @__PURE__ */ new Vector3();\nconst tempV2 = /* @__PURE__ */ new Vector3();\nconst tempV3 = /* @__PURE__ */ new Vector3();\nconst tempUV1 = /* @__PURE__ */ new Vector2();\nconst tempUV2 = /* @__PURE__ */ new Vector2();\nconst tempUV3 = /* @__PURE__ */ new Vector2();\n\nexport function getTriangleHitPointInfo( point, geometry, triangleIndex, target ) {\n\n\tconst indices = geometry.getIndex().array;\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst uvs = geometry.getAttribute( 'uv' );\n\n\tconst a = indices[ triangleIndex * 3 ];\n\tconst b = indices[ triangleIndex * 3 + 1 ];\n\tconst c = indices[ triangleIndex * 3 + 2 ];\n\n\ttempV1.fromBufferAttribute( positions, a );\n\ttempV2.fromBufferAttribute( positions, b );\n\ttempV3.fromBufferAttribute( positions, c );\n\n\t// find the associated material index\n\tlet materialIndex = 0;\n\tconst groups = geometry.groups;\n\tconst firstVertexIndex = triangleIndex * 3;\n\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\t\tconst { start, count } = group;\n\t\tif ( firstVertexIndex >= start && firstVertexIndex < start + count ) {\n\n\t\t\tmaterialIndex = group.materialIndex;\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t// extract uvs\n\tlet uv = null;\n\tif ( uvs ) {\n\n\t\ttempUV1.fromBufferAttribute( uvs, a );\n\t\ttempUV2.fromBufferAttribute( uvs, b );\n\t\ttempUV3.fromBufferAttribute( uvs, c );\n\n\t\tif ( target && target.uv ) uv = target.uv;\n\t\telse uv = new Vector2();\n\n\t\tTriangle.getInterpolation( point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv );\n\n\t}\n\n\t// adjust the provided target or create a new one\n\tif ( target ) {\n\n\t\tif ( ! target.face ) target.face = { };\n\t\ttarget.face.a = a;\n\t\ttarget.face.b = b;\n\t\ttarget.face.c = c;\n\t\ttarget.face.materialIndex = materialIndex;\n\t\tif ( ! target.face.normal ) target.face.normal = new Vector3();\n\t\tTriangle.getNormal( tempV1, tempV2, tempV3, target.face.normal );\n\n\t\tif ( uv ) target.uv = uv;\n\n\t\treturn target;\n\n\t} else {\n\n\t\treturn {\n\t\t\tface: {\n\t\t\t\ta: a,\n\t\t\t\tb: b,\n\t\t\t\tc: c,\n\t\t\t\tmaterialIndex: materialIndex,\n\t\t\t\tnormal: Triangle.getNormal( tempV1, tempV2, tempV3, new Vector3() )\n\t\t\t},\n\t\t\tuv: uv\n\t\t};\n\n\t}\n\n}\n","import { intersectTri } from '../../utils/ThreeRayIntersectUtilities.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\n\n/*************************************************************/\n/* This file is generated from \"iterationUtils.template.js\". */\n/*************************************************************/\n/* eslint-disable indent */\n\nfunction intersectTris( bvh, side, ray, offset, count, intersections ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\n\t\tintersectTri( geometry, side, ray, i, intersections );\n\n\n\t}\n\n}\n\nfunction intersectClosestTri( bvh, side, ray, offset, count ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet intersection;\n\n\t\tintersection = intersectTri( geometry, side, ray, i );\n\n\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\nfunction iterateOverTriangles(\n\toffset,\n\tcount,\n\tbvh,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst { geometry } = bvh;\n\tconst { index } = geometry;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tlet tri;\n\n\t\ttri = i;\n\n\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport { intersectClosestTri, intersectTris, iterateOverTriangles };\n","import { IS_LEAFNODE_FLAG } from '../Constants.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit( bvh, nodeIndices = null ) {\n\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\tnodeIndices = new Set( nodeIndices );\n\n\t}\n\n\tconst geometry = bvh.geometry;\n\tconst indexArr = geometry.index ? geometry.index.array : null;\n\tconst posAttr = geometry.attributes.position;\n\n\tlet buffer, uint32Array, uint16Array, float32Array;\n\tlet byteOffset = 0;\n\tconst roots = bvh._roots;\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\tbuffer = roots[ i ];\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t_traverse( 0, byteOffset );\n\t\tbyteOffset += buffer.byteLength;\n\n\t}\n\n\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\tconst node16Index = node32Index * 2;\n\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\tlet minx = Infinity;\n\t\t\tlet miny = Infinity;\n\t\t\tlet minz = Infinity;\n\t\t\tlet maxx = - Infinity;\n\t\t\tlet maxy = - Infinity;\n\t\t\tlet maxz = - Infinity;\n\n\n\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\n\n\t\t\t\tlet index = indexArr[ i ];\n\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\tif ( z > maxz ) maxz = z;\n\n\t\t\t}\n\n\n\t\t\tif (\n\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t) {\n\n\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = node32Index + 8;\n\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\tconst offsetRight = right + byteOffset;\n\t\t\tlet forceChildren = force;\n\t\t\tlet includesLeft = false;\n\t\t\tlet includesRight = false;\n\n\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tincludesLeft = true;\n\t\t\t\tincludesRight = true;\n\n\t\t\t}\n\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\tlet leftChange = false;\n\t\t\tif ( traverseLeft ) {\n\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tlet rightChange = false;\n\t\t\tif ( traverseRight ) {\n\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tconst didChange = leftChange || rightChange;\n\t\t\tif ( didChange ) {\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn didChange;\n\n\t\t}\n\n\t}\n\n}\n\nexport { refit };\n","import { Box3 } from 'three';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\n\nconst _boundingBox = /* @__PURE__ */ new Box3();\nexport function intersectRay( nodeIndex32, array, ray, target ) {\n\n\tarrayToBox( nodeIndex32, array, _boundingBox );\n\treturn ray.intersectBox( _boundingBox, target );\n\n}\n","import { Vector3 } from 'three';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectTris } from '../utils/iterationUtils.generated.js';\nimport '../utils/iterationUtils_indirect.generated.js';\n\n/******************************************************/\n/* This file is generated from \"raycast.template.js\". */\n/******************************************************/\n\nconst _boxIntersection = /* @__PURE__ */ new Vector3();\nfunction raycast( bvh, root, side, ray, intersects ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t_raycast( 0, bvh, side, ray, intersects );\n\tBufferStack.clearBuffer();\n\n}\n\nfunction _raycast( nodeIndex32, bvh, side, ray, intersects ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tconst nodeIndex16 = nodeIndex32 * 2;\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\tintersectTris( bvh, side, ray, offset, count, intersects );\n\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray, _boxIntersection ) ) {\n\n\t\t\t_raycast( leftIndex, bvh, side, ray, intersects );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray, _boxIntersection ) ) {\n\n\t\t\t_raycast( rightIndex, bvh, side, ray, intersects );\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycast };\n","import { Vector3 } from 'three';\nimport { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport { intersectClosestTri } from '../utils/iterationUtils.generated.js';\nimport '../utils/iterationUtils_indirect.generated.js';\n\n/***********************************************************/\n/* This file is generated from \"raycastFirst.template.js\". */\n/***********************************************************/\nconst _boxIntersection = /* @__PURE__ */ new Vector3();\nconst _xyzFields = [ 'x', 'y', 'z' ];\nfunction raycastFirst( bvh, root, side, ray ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _raycastFirst( 0, bvh, side, ray );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _raycastFirst( nodeIndex32, bvh, side, ray ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\treturn intersectClosestTri( bvh, side, ray, offset, count );\n\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, _boxIntersection );\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, side, ray ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, _boxIntersection );\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, side, ray ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycastFirst };\n","import { Box3, Matrix4 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\n/*****************************************************************/\n/* This file is generated from \"intersectsGeometry.template.js\". */\n/*****************************************************************/\n/* eslint-disable indent */\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst triangle = /* @__PURE__ */ new ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new Matrix4();\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\n\nfunction intersectsGeometry( bvh, root, otherGeometry, geometryToBvh ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tif ( cachedObb === null ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tcachedObb = obb;\n\n\t}\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst thisGeometry = bvh.geometry;\n\t\tconst thisIndex = thisGeometry.index;\n\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\tconst index = otherGeometry.index;\n\t\tconst pos = otherGeometry.attributes.position;\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t// here.\n\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t// if there's a bounds tree\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\tobb2.needsUpdate = true;\n\n\t\t\t// TODO: use a triangle iteration function here\n\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.needsUpdate = true;\n\n\n\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\tsetTriangle( triangle2, i, thisIndex, thisPos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn res;\n\n\t\t} else {\n\n\t\t\t// if we're just dealing with raw geometry\n\n\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\tsetTriangle( triangle, i, thisIndex, thisPos );\n\n\n\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = nodeIndex32 + 8;\n\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\tconst leftIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( leftIntersection ) return true;\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\tconst rightIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( rightIntersection ) return true;\n\n\t\treturn false;\n\n\t}\n\n}\n\nexport { intersectsGeometry };\n","import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\n\nfunction closestPointToGeometry(\n\tbvh,\n\totherGeometry,\n\tgeometryToBvh,\n\ttarget1 = { },\n\ttarget2 = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\tif ( ! otherGeometry.boundingBox ) {\n\n\t\totherGeometry.computeBoundingBox();\n\n\t}\n\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\tobb.needsUpdate = true;\n\n\tconst geometry = bvh.geometry;\n\tconst pos = geometry.attributes.position;\n\tconst index = geometry.index;\n\tconst otherPos = otherGeometry.attributes.position;\n\tconst otherIndex = otherGeometry.index;\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tlet tempTarget1 = temp1;\n\tlet tempTargetDest1 = temp2;\n\tlet tempTarget2 = null;\n\tlet tempTargetDest2 = null;\n\n\tif ( target2 ) {\n\n\t\ttempTarget2 = temp3;\n\t\ttempTargetDest2 = temp4;\n\n\t}\n\n\tlet closestDistance = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tlet closestDistanceOtherTriIndex = null;\n\ttempMatrix.copy( geometryToBvh ).invert();\n\tobb2.matrix.copy( tempMatrix );\n\tbvh.shapecast(\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\tif ( closestDistance === Infinity ) {\n\n\t\treturn null;\n\n\t}\n\n\tif ( ! target1.point ) {\n\n\t\ttarget1.point = tempTargetDest1.clone();\n\n\t} else {\n\n\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t}\n\n\ttarget1.distance = closestDistance,\n\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\tif ( target2 ) {\n\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\telse target2.point.copy( tempTargetDest2 );\n\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t}\n\n\treturn target1;\n\n}\n\nexport { closestPointToGeometry };\n","import { intersectTri } from '../../utils/ThreeRayIntersectUtilities.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\n\n/*************************************************************/\n/* This file is generated from \"iterationUtils.template.js\". */\n/*************************************************************/\n/* eslint-disable indent */\n\nfunction intersectTris_indirect( bvh, side, ray, offset, count, intersections ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet vi = _indirectBuffer ? _indirectBuffer[ i ] : i;\n\t\tintersectTri( geometry, side, ray, vi, intersections );\n\n\n\t}\n\n}\n\nfunction intersectClosestTri_indirect( bvh, side, ray, offset, count ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet intersection;\n\t\tintersection = intersectTri( geometry, side, ray, _indirectBuffer ? _indirectBuffer[ i ] : i );\n\n\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\nfunction iterateOverTriangles_indirect(\n\toffset,\n\tcount,\n\tbvh,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst { geometry } = bvh;\n\tconst { index } = geometry;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tlet tri;\n\t\ttri = bvh.resolveTriangleIndex( i );\n\n\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport { intersectClosestTri_indirect, intersectTris_indirect, iterateOverTriangles_indirect };\n","import { IS_LEAFNODE_FLAG } from '../Constants.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit_indirect( bvh, nodeIndices = null ) {\n\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\tnodeIndices = new Set( nodeIndices );\n\n\t}\n\n\tconst geometry = bvh.geometry;\n\tconst indexArr = geometry.index ? geometry.index.array : null;\n\tconst posAttr = geometry.attributes.position;\n\n\tlet buffer, uint32Array, uint16Array, float32Array;\n\tlet byteOffset = 0;\n\tconst roots = bvh._roots;\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\tbuffer = roots[ i ];\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t_traverse( 0, byteOffset );\n\t\tbyteOffset += buffer.byteLength;\n\n\t}\n\n\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\tconst node16Index = node32Index * 2;\n\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\tlet minx = Infinity;\n\t\t\tlet miny = Infinity;\n\t\t\tlet minz = Infinity;\n\t\t\tlet maxx = - Infinity;\n\t\t\tlet maxy = - Infinity;\n\t\t\tlet maxz = - Infinity;\n\n\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\tconst t = 3 * bvh.resolveTriangleIndex( i );\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tlet index = t + j;\n\t\t\t\t\tindex = indexArr ? indexArr[ index ] : index;\n\n\t\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\t\tif ( z > maxz ) maxz = z;\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif (\n\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t) {\n\n\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = node32Index + 8;\n\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\tconst offsetRight = right + byteOffset;\n\t\t\tlet forceChildren = force;\n\t\t\tlet includesLeft = false;\n\t\t\tlet includesRight = false;\n\n\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tincludesLeft = true;\n\t\t\t\tincludesRight = true;\n\n\t\t\t}\n\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\tlet leftChange = false;\n\t\t\tif ( traverseLeft ) {\n\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tlet rightChange = false;\n\t\t\tif ( traverseRight ) {\n\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tconst didChange = leftChange || rightChange;\n\t\t\tif ( didChange ) {\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn didChange;\n\n\t\t}\n\n\t}\n\n}\n\nexport { refit_indirect };\n","import { Vector3 } from 'three';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport '../utils/iterationUtils.generated.js';\nimport { intersectTris_indirect } from '../utils/iterationUtils_indirect.generated.js';\n\n/******************************************************/\n/* This file is generated from \"raycast.template.js\". */\n/******************************************************/\n\nconst _boxIntersection = /* @__PURE__ */ new Vector3();\nfunction raycast_indirect( bvh, root, side, ray, intersects ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t_raycast( 0, bvh, side, ray, intersects );\n\tBufferStack.clearBuffer();\n\n}\n\nfunction _raycast( nodeIndex32, bvh, side, ray, intersects ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tconst nodeIndex16 = nodeIndex32 * 2;\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\tintersectTris_indirect( bvh, side, ray, offset, count, intersects );\n\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray, _boxIntersection ) ) {\n\n\t\t\t_raycast( leftIndex, bvh, side, ray, intersects );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray, _boxIntersection ) ) {\n\n\t\t\t_raycast( rightIndex, bvh, side, ray, intersects );\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycast_indirect };\n","import { Vector3 } from 'three';\nimport { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport '../utils/iterationUtils.generated.js';\nimport { intersectClosestTri_indirect } from '../utils/iterationUtils_indirect.generated.js';\n\n/***********************************************************/\n/* This file is generated from \"raycastFirst.template.js\". */\n/***********************************************************/\nconst _boxIntersection = /* @__PURE__ */ new Vector3();\nconst _xyzFields = [ 'x', 'y', 'z' ];\nfunction raycastFirst_indirect( bvh, root, side, ray ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _raycastFirst( 0, bvh, side, ray );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _raycastFirst( nodeIndex32, bvh, side, ray ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\treturn intersectClosestTri_indirect( bvh, side, ray, offset, count );\n\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, _boxIntersection );\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, side, ray ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, _boxIntersection );\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, side, ray ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycastFirst_indirect };\n","import { Box3, Matrix4 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\n/*****************************************************************/\n/* This file is generated from \"intersectsGeometry.template.js\". */\n/*****************************************************************/\n/* eslint-disable indent */\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst triangle = /* @__PURE__ */ new ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new Matrix4();\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\n\nfunction intersectsGeometry_indirect( bvh, root, otherGeometry, geometryToBvh ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tif ( cachedObb === null ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tcachedObb = obb;\n\n\t}\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst thisGeometry = bvh.geometry;\n\t\tconst thisIndex = thisGeometry.index;\n\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\tconst index = otherGeometry.index;\n\t\tconst pos = otherGeometry.attributes.position;\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t// here.\n\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t// if there's a bounds tree\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\tobb2.needsUpdate = true;\n\n\t\t\t// TODO: use a triangle iteration function here\n\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * bvh.resolveTriangleIndex( i ), thisIndex, thisPos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn res;\n\n\t\t} else {\n\n\t\t\t// if we're just dealing with raw geometry\n\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\tsetTriangle( triangle, 3 * ti, thisIndex, thisPos );\n\n\n\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = nodeIndex32 + 8;\n\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\tconst leftIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( leftIntersection ) return true;\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\tconst rightIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( rightIntersection ) return true;\n\n\t\treturn false;\n\n\t}\n\n}\n\nexport { intersectsGeometry_indirect };\n","import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\n\nfunction closestPointToGeometry_indirect(\n\tbvh,\n\totherGeometry,\n\tgeometryToBvh,\n\ttarget1 = { },\n\ttarget2 = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\tif ( ! otherGeometry.boundingBox ) {\n\n\t\totherGeometry.computeBoundingBox();\n\n\t}\n\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\tobb.needsUpdate = true;\n\n\tconst geometry = bvh.geometry;\n\tconst pos = geometry.attributes.position;\n\tconst index = geometry.index;\n\tconst otherPos = otherGeometry.attributes.position;\n\tconst otherIndex = otherGeometry.index;\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tlet tempTarget1 = temp1;\n\tlet tempTargetDest1 = temp2;\n\tlet tempTarget2 = null;\n\tlet tempTargetDest2 = null;\n\n\tif ( target2 ) {\n\n\t\ttempTarget2 = temp3;\n\t\ttempTargetDest2 = temp4;\n\n\t}\n\n\tlet closestDistance = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tlet closestDistanceOtherTriIndex = null;\n\ttempMatrix.copy( geometryToBvh ).invert();\n\tobb2.matrix.copy( tempMatrix );\n\tbvh.shapecast(\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * ti2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\tif ( closestDistance === Infinity ) {\n\n\t\treturn null;\n\n\t}\n\n\tif ( ! target1.point ) {\n\n\t\ttarget1.point = tempTargetDest1.clone();\n\n\t} else {\n\n\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t}\n\n\ttarget1.distance = closestDistance,\n\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\tif ( target2 ) {\n\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\telse target2.point.copy( tempTargetDest2 );\n\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t}\n\n\treturn target1;\n\n}\n\nexport { closestPointToGeometry_indirect };\n","import { Box3, Matrix4 } from 'three';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { BOUNDING_DATA_INDEX, COUNT, IS_LEAF, LEFT_NODE, OFFSET, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\n\nconst _bufferStack1 = new BufferStack.constructor();\nconst _bufferStack2 = new BufferStack.constructor();\nconst _boxPool = new PrimitivePool( () => new Box3() );\nconst _leftBox1 = new Box3();\nconst _rightBox1 = new Box3();\n\nconst _leftBox2 = new Box3();\nconst _rightBox2 = new Box3();\n\nlet _active = false;\n\nexport function bvhcast( bvh, otherBvh, matrixToLocal, intersectsRanges ) {\n\n\tif ( _active ) {\n\n\t\tthrow new Error( 'MeshBVH: Recursive calls to bvhcast not supported.' );\n\n\t}\n\n\t_active = true;\n\n\tconst roots = bvh._roots;\n\tconst otherRoots = otherBvh._roots;\n\tlet result;\n\tlet offset1 = 0;\n\tlet offset2 = 0;\n\tconst invMat = new Matrix4().copy( matrixToLocal ).invert();\n\n\t// iterate over the first set of roots\n\tfor ( let i = 0, il = roots.length; i < il; i ++ ) {\n\n\t\t_bufferStack1.setBuffer( roots[ i ] );\n\t\toffset2 = 0;\n\n\t\t// prep the initial root box\n\t\tconst localBox = _boxPool.getPrimitive();\n\t\tarrayToBox( BOUNDING_DATA_INDEX( 0 ), _bufferStack1.float32Array, localBox );\n\t\tlocalBox.applyMatrix4( invMat );\n\n\t\t// iterate over the second set of roots\n\t\tfor ( let j = 0, jl = otherRoots.length; j < jl; j ++ ) {\n\n\t\t\t_bufferStack2.setBuffer( otherRoots[ i ] );\n\n\t\t\tresult = _traverse(\n\t\t\t\t0, 0, matrixToLocal, invMat, intersectsRanges,\n\t\t\t\toffset1, offset2, 0, 0,\n\t\t\t\tlocalBox,\n\t\t\t);\n\n\t\t\t_bufferStack2.clearBuffer();\n\t\t\toffset2 += otherRoots[ j ].length;\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// release stack info\n\t\t_boxPool.releasePrimitive( localBox );\n\t\t_bufferStack1.clearBuffer();\n\t\toffset1 += roots[ i ].length;\n\n\t\tif ( result ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t_active = false;\n\treturn result;\n\n}\n\nfunction _traverse(\n\tnode1Index32,\n\tnode2Index32,\n\tmatrix2to1,\n\tmatrix1to2,\n\tintersectsRangesFunc,\n\n\t// offsets for ids\n\tnode1IndexByteOffset = 0,\n\tnode2IndexByteOffset = 0,\n\n\t// tree depth\n\tdepth1 = 0,\n\tdepth2 = 0,\n\n\tcurrBox = null,\n\treversed = false,\n\n) {\n\n\t// get the buffer stacks associated with the current indices\n\tlet bufferStack1, bufferStack2;\n\tif ( reversed ) {\n\n\t\tbufferStack1 = _bufferStack2;\n\t\tbufferStack2 = _bufferStack1;\n\n\t} else {\n\n\t\tbufferStack1 = _bufferStack1;\n\t\tbufferStack2 = _bufferStack2;\n\n\t}\n\n\t// get the local instances of the typed buffers\n\tconst\n\t\tfloat32Array1 = bufferStack1.float32Array,\n\t\tuint32Array1 = bufferStack1.uint32Array,\n\t\tuint16Array1 = bufferStack1.uint16Array,\n\t\tfloat32Array2 = bufferStack2.float32Array,\n\t\tuint32Array2 = bufferStack2.uint32Array,\n\t\tuint16Array2 = bufferStack2.uint16Array;\n\n\tconst node1Index16 = node1Index32 * 2;\n\tconst node2Index16 = node2Index32 * 2;\n\tconst isLeaf1 = IS_LEAF( node1Index16, uint16Array1 );\n\tconst isLeaf2 = IS_LEAF( node2Index16, uint16Array2 );\n\tlet result = false;\n\tif ( isLeaf2 && isLeaf1 ) {\n\n\t\t// if both bounds are leaf nodes then fire the callback if the boxes intersect\n\t\tif ( reversed ) {\n\n\t\t\tresult = intersectsRangesFunc(\n\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\tdepth2, node2IndexByteOffset + node2Index32,\n\t\t\t\tdepth1, node1IndexByteOffset + node1Index32,\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tresult = intersectsRangesFunc(\n\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\tdepth1, node1IndexByteOffset + node1Index32,\n\t\t\t\tdepth2, node2IndexByteOffset + node2Index32,\n\t\t\t);\n\n\t\t}\n\n\t} else if ( isLeaf2 ) {\n\n\t\t// SWAP\n\t\t// If we've traversed to the leaf node on the other bvh then we need to swap over\n\t\t// to traverse down the first one\n\n\t\t// get the new box to use\n\t\tconst newBox = _boxPool.getPrimitive();\n\t\tarrayToBox( BOUNDING_DATA_INDEX( node2Index32 ), float32Array2, newBox );\n\t\tnewBox.applyMatrix4( matrix2to1 );\n\n\t\t// get the child bounds to check before traversal\n\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\tresult = (\n\t\t\tintersectCl1 && _traverse(\n\t\t\t\tnode2Index32, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\tnewBox, ! reversed,\n\t\t\t)\n\t\t) || (\n\t\t\tintersectCr1 && _traverse(\n\t\t\t\tnode2Index32, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\tnewBox, ! reversed,\n\t\t\t)\n\t\t);\n\n\t\t_boxPool.releasePrimitive( newBox );\n\n\t} else {\n\n\t\t// if neither are leaves then we should swap if one of the children does not\n\t\t// intersect with the current bounds\n\n\t\t// get the child bounds to check\n\t\tconst cl2 = LEFT_NODE( node2Index32 );\n\t\tconst cr2 = RIGHT_NODE( node2Index32, uint32Array2 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cl2 ), float32Array2, _leftBox2 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cr2 ), float32Array2, _rightBox2 );\n\n\t\tconst leftIntersects = currBox.intersectsBox( _leftBox2 );\n\t\tconst rightIntersects = currBox.intersectsBox( _rightBox2 );\n\t\tif ( leftIntersects && rightIntersects ) {\n\n\t\t\t// continue to traverse both children if they both intersect\n\t\t\tresult = _traverse(\n\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\tcurrBox, reversed,\n\t\t\t) || _traverse(\n\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\tcurrBox, reversed,\n\t\t\t);\n\n\t\t} else if ( leftIntersects ) {\n\n\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\tresult = _traverse(\n\t\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// SWAP\n\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\tnewBox.copy( _leftBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\tresult = (\n\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\tcl2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t) || (\n\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\tcl2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t}\n\n\t\t} else if ( rightIntersects ) {\n\n\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\tresult = _traverse(\n\t\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// SWAP\n\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\tnewBox.copy( _rightBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\tresult = (\n\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\tcr2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t) || (\n\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\tcr2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\n","import { BufferAttribute, Box3, FrontSide } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG, SKIP_GENERATION } from './Constants.js';\nimport { buildPackedTree } from './build/buildTree.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { ExtendedTrianglePool } from '../utils/ExtendedTrianglePool.js';\nimport { shapecast } from './cast/shapecast.js';\nimport { closestPointToPoint } from './cast/closestPointToPoint.js';\n\nimport { iterateOverTriangles } from './utils/iterationUtils.generated.js';\nimport { refit } from './cast/refit.generated.js';\nimport { raycast } from './cast/raycast.generated.js';\nimport { raycastFirst } from './cast/raycastFirst.generated.js';\nimport { intersectsGeometry } from './cast/intersectsGeometry.generated.js';\nimport { closestPointToGeometry } from './cast/closestPointToGeometry.generated.js';\n\nimport { iterateOverTriangles_indirect } from './utils/iterationUtils_indirect.generated.js';\nimport { refit_indirect } from './cast/refit_indirect.generated.js';\nimport { raycast_indirect } from './cast/raycast_indirect.generated.js';\nimport { raycastFirst_indirect } from './cast/raycastFirst_indirect.generated.js';\nimport { intersectsGeometry_indirect } from './cast/intersectsGeometry_indirect.generated.js';\nimport { closestPointToGeometry_indirect } from './cast/closestPointToGeometry_indirect.generated.js';\nimport { isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\nimport { setTriangle } from '../utils/TriangleUtilities.js';\nimport { bvhcast } from './cast/bvhcast.js';\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst tempBox = /* @__PURE__ */ new Box3();\n\nexport class MeshBVH {\n\n\tstatic serialize( bvh, options = {} ) {\n\n\t\toptions = {\n\t\t\tcloneBuffers: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst rootData = bvh._roots;\n\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\tconst indexAttribute = geometry.getIndex();\n\t\tlet result;\n\t\tif ( options.cloneBuffers ) {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData.map( root => root.slice() ),\n\t\t\t\tindex: indexAttribute.array.slice(),\n\t\t\t\tindirectBuffer: indirectBuffer ? indirectBuffer.slice() : null,\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData,\n\t\t\t\tindex: indexAttribute.array,\n\t\t\t\tindirectBuffer: indirectBuffer,\n\t\t\t};\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tstatic deserialize( data, geometry, options = {} ) {\n\n\t\toptions = {\n\t\t\tsetIndex: true,\n\t\t\tindirect: Boolean( data.indirectBuffer ),\n\t\t\t...options,\n\t\t};\n\n\t\tconst { index, roots, indirectBuffer } = data;\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\n\t\tbvh._roots = roots;\n\t\tbvh._indirectBuffer = indirectBuffer || null;\n\n\t\tif ( options.setIndex ) {\n\n\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\tif ( indexAttribute === null ) {\n\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\n\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t} else if ( indexAttribute.array !== index ) {\n\n\t\t\t\tindexAttribute.array.set( index );\n\t\t\t\tindexAttribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvh;\n\n\t}\n\n\tget indirect() {\n\n\t\treturn ! ! this._indirectBuffer;\n\n\t}\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\n\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\n\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\n\n\t\t}\n\n\t\t// default options\n\t\toptions = Object.assign( {\n\n\t\t\tstrategy: CENTER,\n\t\t\tmaxDepth: 40,\n\t\t\tmaxLeafTris: 10,\n\t\t\tverbose: true,\n\t\t\tuseSharedArrayBuffer: false,\n\t\t\tsetBoundingBox: true,\n\t\t\tonProgress: null,\n\t\t\tindirect: false,\n\n\t\t\t// undocumented options\n\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\n\t\t\t[ SKIP_GENERATION ]: false,\n\n\t\t}, options );\n\n\t\tif ( options.useSharedArrayBuffer && ! isSharedArrayBufferSupported() ) {\n\n\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\n\n\t\t}\n\n\t\t// retain references to the geometry so we can use them it without having to\n\t\t// take a geometry reference in every function.\n\t\tthis.geometry = geometry;\n\t\tthis._roots = null;\n\t\tthis._indirectBuffer = null;\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\n\n\t\t\tbuildPackedTree( this, options );\n\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\n\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst { _indirectBuffer } = this;\n\t\tthis.resolveTriangleIndex = options.indirect ? i => _indirectBuffer[ i ] : i => i;\n\n\t}\n\n\trefit( nodeIndices = null ) {\n\n\t\tconst refitFunc = this.indirect ? refit_indirect : refit;\n\t\treturn refitFunc( this, nodeIndices );\n\n\t}\n\n\ttraverse( callback, rootIndex = 0 ) {\n\n\t\tconst buffer = this._roots[ rootIndex ];\n\t\tconst uint32Array = new Uint32Array( buffer );\n\t\tconst uint16Array = new Uint16Array( buffer );\n\t\t_traverse( 0 );\n\n\t\tfunction _traverse( node32Index, depth = 0 ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\n\n\t\t\t} else {\n\n\t\t\t\t// TODO: use node functions here\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\n\n\t\t\t\tif ( ! stopTraversal ) {\n\n\t\t\t\t\t_traverse( left, depth + 1 );\n\t\t\t\t\t_traverse( right, depth + 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Core Cast Functions */\n\traycast( ray, materialOrSide = FrontSide ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst intersects = [];\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tconst raycastFunc = this.indirect ? raycast_indirect : raycast;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst startCount = intersects.length;\n\n\t\t\traycastFunc( this, i, materialSide, ray, intersects );\n\n\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\n\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn intersects;\n\n\t}\n\n\traycastFirst( ray, materialOrSide = FrontSide ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tlet closestResult = null;\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tconst raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst result = raycastFirstFunc( this, i, materialSide, ray );\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\n\n\t\t\t\tclosestResult = result;\n\t\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn closestResult;\n\n\t}\n\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\n\n\t\tlet result = false;\n\t\tconst roots = this._roots;\n\t\tconst intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tresult = intersectsGeometryFunc( this, i, otherGeometry, geomToMesh );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tshapecast( callbacks ) {\n\n\t\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\t\tconst iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;\n\t\tlet {\n\t\t\tboundsTraverseOrder,\n\t\t\tintersectsBounds,\n\t\t\tintersectsRange,\n\t\t\tintersectsTriangle,\n\t\t} = callbacks;\n\n\t\t// wrap the intersectsRange function\n\t\tif ( intersectsRange && intersectsTriangle ) {\n\n\t\t\tconst originalIntersectsRange = intersectsRange;\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\n\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\n\n\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t} else if ( ! intersectsRange ) {\n\n\t\t\tif ( intersectsTriangle ) {\n\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\n\n\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\n\n\t\t\t\t\treturn contained;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\t// run shapecast\n\t\tlet result = false;\n\t\tlet byteOffset = 0;\n\t\tconst roots = this._roots;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst root = roots[ i ];\n\t\t\tresult = shapecast( this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tbyteOffset += root.byteLength;\n\n\t\t}\n\n\t\tExtendedTrianglePool.releasePrimitive( triangle );\n\n\t\treturn result;\n\n\t}\n\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\n\n\t\tlet {\n\t\t\tintersectsRanges,\n\t\t\tintersectsTriangles,\n\t\t} = callbacks;\n\n\t\tconst triangle1 = ExtendedTrianglePool.getPrimitive();\n\t\tconst indexAttr1 = this.geometry.index;\n\t\tconst positionAttr1 = this.geometry.attributes.position;\n\t\tconst assignTriangle1 = this.indirect ?\n\t\t\ti1 => {\n\n\n\t\t\t\tconst ti = this.resolveTriangleIndex( i1 );\n\t\t\t\tsetTriangle( triangle1, ti * 3, indexAttr1, positionAttr1 );\n\n\t\t\t} :\n\t\t\ti1 => {\n\n\t\t\t\tsetTriangle( triangle1, i1 * 3, indexAttr1, positionAttr1 );\n\n\t\t\t};\n\n\t\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\t\tconst indexAttr2 = otherBvh.geometry.index;\n\t\tconst positionAttr2 = otherBvh.geometry.attributes.position;\n\t\tconst assignTriangle2 = otherBvh.indirect ?\n\t\t\ti2 => {\n\n\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\tsetTriangle( triangle2, ti2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t} :\n\t\t\ti2 => {\n\n\t\t\t\tsetTriangle( triangle2, i2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t};\n\n\t\t// generate triangle callback if needed\n\t\tif ( intersectsTriangles ) {\n\n\t\t\tconst iterateOverDoubleTriangles = ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) => {\n\n\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\tassignTriangle2( i2 );\n\n\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\n\n\t\t\t\t\t\tassignTriangle1( i1 );\n\n\t\t\t\t\t\ttriangle1.needsUpdate = true;\n\n\t\t\t\t\t\tif ( intersectsTriangles( triangle1, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t};\n\n\t\t\tif ( intersectsRanges ) {\n\n\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\n\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvhcast( this, otherBvh, matrixToLocal, intersectsRanges );\n\n\t}\n\n\n\t/* Derived Cast Functions */\n\tintersectsBox( box, boxToMesh ) {\n\n\t\tobb.set( box.min, box.max, boxToMesh );\n\t\tobb.needsUpdate = true;\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\tconst closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;\n\t\treturn closestPointToGeometryFunc(\n\t\t\tthis,\n\t\t\totherGeometry,\n\t\t\tgeometryToBvh,\n\t\t\ttarget1,\n\t\t\ttarget2,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\treturn closestPointToPoint(\n\t\t\tthis,\n\t\t\tpoint,\n\t\t\ttarget,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\ttarget.makeEmpty();\n\n\t\tconst roots = this._roots;\n\t\troots.forEach( buffer => {\n\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\n\t\t\ttarget.union( tempBox );\n\n\t\t} );\n\n\t\treturn target;\n\n\t}\n\n}\n","export function isSharedArrayBufferSupported() {\n\n\treturn typeof SharedArrayBuffer !== 'undefined';\n\n}\n","const HASH_WIDTH = 1e-6;\nconst HASH_HALF_WIDTH = HASH_WIDTH * 0.5;\nconst HASH_MULTIPLIER = Math.pow( 10, - Math.log10( HASH_WIDTH ) );\nconst HASH_ADDITION = HASH_HALF_WIDTH * HASH_MULTIPLIER;\nexport function hashNumber( v ) {\n\n\treturn ~ ~ ( v * HASH_MULTIPLIER + HASH_ADDITION );\n\n}\n\nexport function hashVertex2( v ) {\n\n\treturn `${ hashNumber( v.x ) },${ hashNumber( v.y ) }`;\n\n}\n\nexport function hashVertex3( v ) {\n\n\treturn `${ hashNumber( v.x ) },${ hashNumber( v.y ) },${ hashNumber( v.z ) }`;\n\n}\n\nexport function hashVertex4( v ) {\n\n\treturn `${ hashNumber( v.x ) },${ hashNumber( v.y ) },${ hashNumber( v.z ) },${ hashNumber( v.w ) }`;\n\n}\n\nexport function hashRay( r ) {\n\n\treturn `${ hashVertex3( r.origin ) }-${ hashVertex3( r.direction ) }`;\n\n}\n\nexport function toNormalizedRay( v0, v1, target ) {\n\n\t// get a normalized direction\n\ttarget\n\t\t.direction\n\t\t.subVectors( v1, v0 )\n\t\t.normalize();\n\n\t// project the origin onto the perpendicular plane that\n\t// passes through 0, 0, 0\n\tconst scalar = v0.dot( target.direction );\n\ttarget.\n\t\torigin\n\t\t.copy( v0 )\n\t\t.addScaledVector( target.direction, - scalar );\n\n\treturn target;\n\n}\n","import { BufferAttribute } from 'three';\n\nexport function areSharedArrayBuffersSupported() {\n\n\treturn typeof SharedArrayBuffer !== 'undefined';\n\n}\n\nexport function convertToSharedArrayBuffer( array ) {\n\n\tif ( array.buffer instanceof SharedArrayBuffer ) {\n\n\t\treturn array;\n\n\t}\n\n\tconst cons = array.constructor;\n\tconst buffer = array.buffer;\n\tconst sharedBuffer = new SharedArrayBuffer( buffer.byteLength );\n\n\tconst uintArray = new Uint8Array( buffer );\n\tconst sharedUintArray = new Uint8Array( sharedBuffer );\n\tsharedUintArray.set( uintArray, 0 );\n\n\treturn new cons( sharedBuffer );\n\n}\n\nexport function getIndexArray( vertexCount, BufferConstructor = ArrayBuffer ) {\n\n\tif ( vertexCount > 65535 ) {\n\n\t\treturn new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\n\n\t} else {\n\n\t\treturn new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\n\n\t}\n\n}\n\nexport function ensureIndex( geo, options ) {\n\n\tif ( ! geo.index ) {\n\n\t\tconst vertexCount = geo.attributes.position.count;\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\tconst index = getIndexArray( vertexCount, BufferConstructor );\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\n\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tindex[ i ] = i;\n\n\t\t}\n\n\t}\n\n}\n\nexport function getVertexCount( geo ) {\n\n\treturn geo.index ? geo.index.count : geo.attributes.position.count;\n\n}\n\nexport function getTriCount( geo ) {\n\n\treturn getVertexCount( geo ) / 3;\n\n}\n","import { Vector3 } from 'three';\n\nconst DEGENERATE_EPSILON = 1e-8;\nconst _tempVec = new Vector3();\n\nexport function toTriIndex( v ) {\n\n\treturn ~ ~ ( v / 3 );\n\n}\n\nexport function toEdgeIndex( v ) {\n\n\treturn v % 3;\n\n}\n\nexport function sortEdgeFunc( a, b ) {\n\n\treturn a.start - b.start;\n\n}\n\nexport function getProjectedDistance( ray, vec ) {\n\n\treturn _tempVec.subVectors( vec, ray.origin ).dot( ray.direction );\n\n}\n\nexport function hasOverlaps( arr ) {\n\n\tarr = [ ...arr ].sort( sortEdgeFunc );\n\tfor ( let i = 0, l = arr.length; i < l - 1; i ++ ) {\n\n\t\tconst info0 = arr[ i ];\n\t\tconst info1 = arr[ i + 1 ];\n\n\t\tif ( info1.start < info0.end && Math.abs( info1.start - info0.end ) > 1e-5 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport function getEdgeSetLength( arr ) {\n\n\tlet tot = 0;\n\tarr.forEach( ( { start, end } ) => tot += end - start );\n\treturn tot;\n\n}\n\nexport function matchEdges( forward, reverse, disjointConnectivityMap, eps = DEGENERATE_EPSILON ) {\n\n\tforward.sort( sortEdgeFunc );\n\treverse.sort( sortEdgeFunc );\n\n\tfor ( let i = 0; i < forward.length; i ++ ) {\n\n\t\tconst e0 = forward[ i ];\n\t\tfor ( let o = 0; o < reverse.length; o ++ ) {\n\n\t\t\tconst e1 = reverse[ o ];\n\t\t\tif ( e1.start > e0.end ) {\n\n\t\t\t\t// e2 is completely after e1\n\t\t\t\t// break;\n\n\t\t\t\t// NOTE: there are cases where there are overlaps due to precision issues or\n\t\t\t\t// thin / degenerate triangles. Assuming the sibling side has the same issues\n\t\t\t\t// we let the matching work here. Long term we should remove the degenerate\n\t\t\t\t// triangles before this.\n\n\t\t\t} else if ( e0.end < e1.start || e1.end < e0.start ) {\n\n\t\t\t\t// e1 is completely before e2\n\t\t\t\tcontinue;\n\n\t\t\t} else if ( e0.start <= e1.start && e0.end >= e1.end ) {\n\n\t\t\t\t// e1 is larger than and e2 is completely within e1\n\t\t\t\tif ( ! areDistancesDegenerate( e1.end, e0.end ) ) {\n\n\t\t\t\t\tforward.splice( i + 1, 0, {\n\t\t\t\t\t\tstart: e1.end,\n\t\t\t\t\t\tend: e0.end,\n\t\t\t\t\t\tindex: e0.index,\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\te0.end = e1.start;\n\n\t\t\t\te1.start = 0;\n\t\t\t\te1.end = 0;\n\n\t\t\t} else if ( e0.start >= e1.start && e0.end <= e1.end ) {\n\n\t\t\t\t// e2 is larger than and e1 is completely within e2\n\t\t\t\tif ( ! areDistancesDegenerate( e0.end, e1.end ) ) {\n\n\t\t\t\t\treverse.splice( o + 1, 0, {\n\t\t\t\t\t\tstart: e0.end,\n\t\t\t\t\t\tend: e1.end,\n\t\t\t\t\t\tindex: e1.index,\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\te1.end = e0.start;\n\n\t\t\t\te0.start = 0;\n\t\t\t\te0.end = 0;\n\n\t\t\t} else if ( e0.start <= e1.start && e0.end <= e1.end ) {\n\n\t\t\t\t// e1 overlaps e2 at the beginning\n\t\t\t\tconst tmp = e0.end;\n\t\t\t\te0.end = e1.start;\n\t\t\t\te1.start = tmp;\n\n\t\t\t} else if ( e0.start >= e1.start && e0.end >= e1.end ) {\n\n\t\t\t\t// e1 overlaps e2 at the end\n\t\t\t\tconst tmp = e1.end;\n\t\t\t\te1.end = e0.start;\n\t\t\t\te0.start = tmp;\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error();\n\n\t\t\t}\n\n\t\t\t// Add the connectivity information\n\t\t\tif ( ! disjointConnectivityMap.has( e0.index ) ) {\n\n\t\t\t\tdisjointConnectivityMap.set( e0.index, [] );\n\n\t\t\t}\n\n\t\t\tif ( ! disjointConnectivityMap.has( e1.index ) ) {\n\n\t\t\t\tdisjointConnectivityMap.set( e1.index, [] );\n\n\t\t\t}\n\n\t\t\tdisjointConnectivityMap\n\t\t\t\t.get( e0.index )\n\t\t\t\t.push( e1.index );\n\n\t\t\tdisjointConnectivityMap\n\t\t\t\t.get( e1.index )\n\t\t\t\t.push( e0.index );\n\n\t\t\tif ( isEdgeDegenerate( e1 ) ) {\n\n\t\t\t\treverse.splice( o, 1 );\n\t\t\t\to --;\n\n\t\t\t}\n\n\t\t\tif ( isEdgeDegenerate( e0 ) ) {\n\n\t\t\t\t// and if we have to remove the current original edge then exit this loop\n\t\t\t\t// so we can work on the next one\n\t\t\t\tforward.splice( i, 1 );\n\t\t\t\ti --;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcleanUpEdgeSet( forward );\n\tcleanUpEdgeSet( reverse );\n\n\tfunction cleanUpEdgeSet( arr ) {\n\n\t\tfor ( let i = 0; i < arr.length; i ++ ) {\n\n\t\t\tif ( isEdgeDegenerate( arr[ i ] ) ) {\n\n\t\t\t\tarr.splice( i, 1 );\n\t\t\t\ti --;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction areDistancesDegenerate( start, end ) {\n\n\t\treturn Math.abs( end - start ) < eps;\n\n\t}\n\n\tfunction isEdgeDegenerate( e ) {\n\n\t\treturn Math.abs( e.end - e.start ) < eps;\n\n\t}\n\n}\n","const DIST_EPSILON = 1e-5;\nconst ANGLE_EPSILON = 1e-4;\n\nexport class RaySet {\n\n\tconstructor() {\n\n\t\tthis._rays = [];\n\n\t}\n\n\taddRay( ray ) {\n\n\t\tthis._rays.push( ray );\n\n\t}\n\n\tfindClosestRay( ray ) {\n\n\t\tconst rays = this._rays;\n\t\tconst inv = ray.clone();\n\t\tinv.direction.multiplyScalar( - 1 );\n\n\t\tlet bestScore = Infinity;\n\t\tlet bestRay = null;\n\t\tfor ( let i = 0, l = rays.length; i < l; i ++ ) {\n\n\t\t\tconst r = rays[ i ];\n\t\t\tif ( skipRay( r, ray ) && skipRay( r, inv ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst rayScore = scoreRays( r, ray );\n\t\t\tconst invScore = scoreRays( r, inv );\n\t\t\tconst score = Math.min( rayScore, invScore );\n\t\t\tif ( score < bestScore ) {\n\n\t\t\t\tbestScore = score;\n\t\t\t\tbestRay = r;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bestRay;\n\n\t\tfunction skipRay( r0, r1 ) {\n\n\t\t\tconst distOutOfThreshold = r0.origin.distanceTo( r1.origin ) > DIST_EPSILON;\n\t\t\tconst angleOutOfThreshold = r0.direction.angleTo( r1.direction ) > ANGLE_EPSILON;\n\t\t\treturn angleOutOfThreshold || distOutOfThreshold;\n\n\t\t}\n\n\t\tfunction scoreRays( r0, r1 ) {\n\n\t\t\tconst originDistance = r0.origin.distanceTo( r1.origin );\n\t\t\tconst angleDistance = r0.direction.angleTo( r1.direction );\n\t\t\treturn originDistance / DIST_EPSILON + angleDistance / ANGLE_EPSILON;\n\n\t\t}\n\n\t}\n\n}\n","import { Vector3, Ray } from 'three';\nimport { toEdgeIndex, toTriIndex, matchEdges, getProjectedDistance } from './halfEdgeUtils.js';\nimport { toNormalizedRay } from './hashUtils.js';\nimport { RaySet } from './RaySet.js';\n\nconst _v0 = new Vector3();\nconst _v1 = new Vector3();\nconst _ray = new Ray();\n\nexport function computeDisjointEdges(\n\tgeometry,\n\tunmatchedSet,\n\teps,\n) {\n\n\tconst attributes = geometry.attributes;\n\tconst indexAttr = geometry.index;\n\tconst posAttr = attributes.position;\n\n\tconst disjointConnectivityMap = new Map();\n\tconst fragmentMap = new Map();\n\tconst edges = Array.from( unmatchedSet );\n\tconst rays = new RaySet();\n\n\tfor ( let i = 0, l = edges.length; i < l; i ++ ) {\n\n\t\t// get the triangle edge\n\t\tconst index = edges[ i ];\n\t\tconst triIndex = toTriIndex( index );\n\t\tconst edgeIndex = toEdgeIndex( index );\n\n\t\tlet i0 = 3 * triIndex + edgeIndex;\n\t\tlet i1 = 3 * triIndex + ( edgeIndex + 1 ) % 3;\n\t\tif ( indexAttr ) {\n\n\t\t\ti0 = indexAttr.getX( i0 );\n\t\t\ti1 = indexAttr.getX( i1 );\n\n\t\t}\n\n\t\t_v0.fromBufferAttribute( posAttr, i0 );\n\t\t_v1.fromBufferAttribute( posAttr, i1 );\n\n\t\t// get the ray corresponding to the edge\n\t\ttoNormalizedRay( _v0, _v1, _ray );\n\n\t\t// find the shared ray with other edges\n\t\tlet info;\n\t\tlet commonRay = rays.findClosestRay( _ray );\n\t\tif ( commonRay === null ) {\n\n\t\t\tcommonRay = _ray.clone();\n\t\t\trays.addRay( commonRay );\n\n\t\t}\n\n\t\tif ( ! fragmentMap.has( commonRay ) ) {\n\n\t\t\tfragmentMap.set( commonRay, {\n\n\t\t\t\tforward: [],\n\t\t\t\treverse: [],\n\t\t\t\tray: commonRay,\n\n\t\t\t} );\n\n\t\t}\n\n\t\tinfo = fragmentMap.get( commonRay );\n\n\t\t// store the stride of edge endpoints along the ray\n\t\tlet start = getProjectedDistance( commonRay, _v0 );\n\t\tlet end = getProjectedDistance( commonRay, _v1 );\n\t\tif ( start > end ) {\n\n\t\t\t[ start, end ] = [ end, start ];\n\n\t\t}\n\n\t\tif ( _ray.direction.dot( commonRay.direction ) < 0 ) {\n\n\t\t\tinfo.reverse.push( { start, end, index } );\n\n\t\t} else {\n\n\t\t\tinfo.forward.push( { start, end, index } );\n\n\t\t}\n\n\t}\n\n\t// match the found sibling edges\n\tfragmentMap.forEach( ( { forward, reverse }, ray ) => {\n\n\t\tmatchEdges( forward, reverse, disjointConnectivityMap, eps );\n\n\t\tif ( forward.length === 0 && reverse.length === 0 ) {\n\n\t\t\tfragmentMap.delete( ray );\n\n\t\t}\n\n\t} );\n\n\treturn {\n\t\tdisjointConnectivityMap,\n\t\tfragmentMap,\n\t};\n\n}\n\n","import { Vector2, Vector3, Vector4 } from 'three';\nimport { hashNumber, hashVertex2, hashVertex3, hashVertex4 } from './utils/hashUtils.js';\nimport { getTriCount } from './utils/geometryUtils.js';\nimport { computeDisjointEdges } from './utils/computeDisjointEdges.js';\n\nconst _vec2 = new Vector2();\nconst _vec3 = new Vector3();\nconst _vec4 = new Vector4();\nconst _hashes = [ '', '', '' ];\n\nexport class HalfEdgeMap {\n\n\tconstructor( geometry = null ) {\n\n\t\t// result data\n\t\tthis.data = null;\n\t\tthis.disjointConnections = null;\n\t\tthis.unmatchedDisjointEdges = null;\n\t\tthis.unmatchedEdges = - 1;\n\t\tthis.matchedEdges = - 1;\n\n\t\t// options\n\t\tthis.useDrawRange = true;\n\t\tthis.useAllAttributes = false;\n\t\tthis.matchDisjointEdges = false;\n\t\tthis.degenerateEpsilon = 1e-8;\n\n\t\tif ( geometry ) {\n\n\t\t\tthis.updateFrom( geometry );\n\n\t\t}\n\n\t}\n\n\tgetSiblingTriangleIndex( triIndex, edgeIndex ) {\n\n\t\tconst otherIndex = this.data[ triIndex * 3 + edgeIndex ];\n\t\treturn otherIndex === - 1 ? - 1 : ~ ~ ( otherIndex / 3 );\n\n\t}\n\n\tgetSiblingEdgeIndex( triIndex, edgeIndex ) {\n\n\t\tconst otherIndex = this.data[ triIndex * 3 + edgeIndex ];\n\t\treturn otherIndex === - 1 ? - 1 : ( otherIndex % 3 );\n\n\t}\n\n\tgetDisjointSiblingTriangleIndices( triIndex, edgeIndex ) {\n\n\t\tconst index = triIndex * 3 + edgeIndex;\n\t\tconst arr = this.disjointConnections.get( index );\n\t\treturn arr ? arr.map( i => ~ ~ ( i / 3 ) ) : [];\n\n\t}\n\n\tgetDisjointSiblingEdgeIndices( triIndex, edgeIndex ) {\n\n\t\tconst index = triIndex * 3 + edgeIndex;\n\t\tconst arr = this.disjointConnections.get( index );\n\t\treturn arr ? arr.map( i => i % 3 ) : [];\n\n\t}\n\n\tisFullyConnected() {\n\n\t\treturn this.unmatchedEdges === 0;\n\n\t}\n\n\tupdateFrom( geometry ) {\n\n\t\tconst { useAllAttributes, useDrawRange, matchDisjointEdges, degenerateEpsilon } = this;\n\t\tconst hashFunction = useAllAttributes ? hashAllAttributes : hashPositionAttribute;\n\n\t\t// runs on the assumption that there is a 1 : 1 match of edges\n\t\tconst map = new Map();\n\n\t\t// attributes\n\t\tconst { attributes } = geometry;\n\t\tconst attrKeys = useAllAttributes ? Object.keys( attributes ) : null;\n\t\tconst indexAttr = geometry.index;\n\t\tconst posAttr = attributes.position;\n\n\t\t// get the potential number of triangles\n\t\tlet triCount = getTriCount( geometry );\n\t\tconst maxTriCount = triCount;\n\n\t\t// get the real number of triangles from the based on the draw range\n\t\tlet offset = 0;\n\t\tif ( useDrawRange ) {\n\n\t\t\toffset = geometry.drawRange.start;\n\t\t\tif ( geometry.drawRange.count !== Infinity ) {\n\n\t\t\t\ttriCount = ~ ~ ( geometry.drawRange.count / 3 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// initialize the connectivity buffer - 1 means no connectivity\n\t\tlet data = this.data;\n\t\tif ( ! data || data.length < 3 * maxTriCount ) {\n\n\t\t\tdata = new Int32Array( 3 * maxTriCount );\n\n\t\t}\n\n\t\tdata.fill( - 1 );\n\n\t\t// iterate over all triangles\n\t\tlet matchedEdges = 0;\n\t\tlet unmatchedSet = new Set();\n\t\tfor ( let i = offset, l = triCount * 3 + offset; i < l; i += 3 ) {\n\n\t\t\tconst i3 = i;\n\t\t\tfor ( let e = 0; e < 3; e ++ ) {\n\n\t\t\t\tlet i0 = i3 + e;\n\t\t\t\tif ( indexAttr ) {\n\n\t\t\t\t\ti0 = indexAttr.getX( i0 );\n\n\t\t\t\t}\n\n\t\t\t\t_hashes[ e ] = hashFunction( i0 );\n\n\t\t\t}\n\n\t\t\tfor ( let e = 0; e < 3; e ++ ) {\n\n\t\t\t\tconst nextE = ( e + 1 ) % 3;\n\t\t\t\tconst vh0 = _hashes[ e ];\n\t\t\t\tconst vh1 = _hashes[ nextE ];\n\n\t\t\t\tconst reverseHash = `${ vh1 }_${ vh0 }`;\n\t\t\t\tif ( map.has( reverseHash ) ) {\n\n\t\t\t\t\t// create a reference between the two triangles and clear the hash\n\t\t\t\t\tconst index = i3 + e;\n\t\t\t\t\tconst otherIndex = map.get( reverseHash );\n\t\t\t\t\tdata[ index ] = otherIndex;\n\t\t\t\t\tdata[ otherIndex ] = index;\n\t\t\t\t\tmap.delete( reverseHash );\n\t\t\t\t\tmatchedEdges += 2;\n\t\t\t\t\tunmatchedSet.delete( otherIndex );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// save the triangle and triangle edge index captured in one value\n\t\t\t\t\t// triIndex = ~ ~ ( i0 / 3 );\n\t\t\t\t\t// edgeIndex = i0 % 3;\n\t\t\t\t\tconst hash = `${ vh0 }_${ vh1 }`;\n\t\t\t\t\tconst index = i3 + e;\n\t\t\t\t\tmap.set( hash, index );\n\t\t\t\t\tunmatchedSet.add( index );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( matchDisjointEdges ) {\n\n\t\t\tconst {\n\t\t\t\tfragmentMap,\n\t\t\t\tdisjointConnectivityMap,\n\t\t\t} = computeDisjointEdges( geometry, unmatchedSet, degenerateEpsilon );\n\n\t\t\tunmatchedSet.clear();\n\t\t\tfragmentMap.forEach( ( { forward, reverse } ) => {\n\n\t\t\t\tforward.forEach( ( { index } ) => unmatchedSet.add( index ) );\n\t\t\t\treverse.forEach( ( { index } ) => unmatchedSet.add( index ) );\n\n\t\t\t} );\n\n\t\t\tthis.unmatchedDisjointEdges = fragmentMap;\n\t\t\tthis.disjointConnections = disjointConnectivityMap;\n\t\t\tmatchedEdges = triCount * 3 - unmatchedSet.size;\n\n\t\t}\n\n\t\tthis.matchedEdges = matchedEdges;\n\t\tthis.unmatchedEdges = unmatchedSet.size;\n\t\tthis.data = data;\n\n\t\tfunction hashPositionAttribute( i ) {\n\n\t\t\t_vec3.fromBufferAttribute( posAttr, i );\n\t\t\treturn hashVertex3( _vec3 );\n\n\t\t}\n\n\t\tfunction hashAllAttributes( i ) {\n\n\t\t\tlet result = '';\n\t\t\tfor ( let k = 0, l = attrKeys.length; k < l; k ++ ) {\n\n\t\t\t\tconst attr = attributes[ attrKeys[ k ] ];\n\t\t\t\tlet str;\n\t\t\t\tswitch ( attr.itemSize ) {\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tstr = hashNumber( attr.getX( i ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tstr = hashVertex2( _vec2.fromBufferAttribute( attr, i ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tstr = hashVertex3( _vec3.fromBufferAttribute( attr, i ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tstr = hashVertex4( _vec4.fromBufferAttribute( attr, i ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( result !== '' ) {\n\n\t\t\t\t\tresult += '|';\n\n\t\t\t\t}\n\n\t\t\t\tresult += str;\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t}\n\n}\n","import { Mesh, Matrix4 } from 'three';\nimport { MeshBVH } from 'three-mesh-bvh';\nimport { HalfEdgeMap } from './HalfEdgeMap.js';\nimport { areSharedArrayBuffersSupported, convertToSharedArrayBuffer, ensureIndex, getTriCount } from './utils/geometryUtils.js';\n\nexport class Brush extends Mesh {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.isBrush = true;\n\t\tthis._previousMatrix = new Matrix4();\n\t\tthis._previousMatrix.elements.fill( 0 );\n\n\t}\n\n\tmarkUpdated() {\n\n\t\tthis._previousMatrix.copy( this.matrix );\n\n\t}\n\n\tisDirty() {\n\n\t\tconst { matrix, _previousMatrix } = this;\n\t\tconst el1 = matrix.elements;\n\t\tconst el2 = _previousMatrix.elements;\n\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\tif ( el1[ i ] !== el2[ i ] ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tprepareGeometry() {\n\n\t\t// generate shared array buffers\n\t\tconst geometry = this.geometry;\n\t\tconst attributes = geometry.attributes;\n\t\tconst useSharedArrayBuffer = areSharedArrayBuffersSupported();\n\t\tif ( useSharedArrayBuffer ) {\n\n\t\t\tfor ( const key in attributes ) {\n\n\t\t\t\tconst attribute = attributes[ key ];\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\tthrow new Error( 'Brush: InterleavedBufferAttributes are not supported.' );\n\n\t\t\t\t}\n\n\t\t\t\tattribute.array = convertToSharedArrayBuffer( attribute.array );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate bounds tree\n\t\tif ( ! geometry.boundsTree ) {\n\n\t\t\tensureIndex( geometry, { useSharedArrayBuffer } );\n\t\t\tgeometry.boundsTree = new MeshBVH( geometry, { maxLeafTris: 3, indirect: true, useSharedArrayBuffer } );\n\n\t\t}\n\n\t\t// generate half edges\n\t\tif ( ! geometry.halfEdges ) {\n\n\t\t\tgeometry.halfEdges = new HalfEdgeMap( geometry );\n\n\t\t}\n\n\t\t// save group indices for materials\n\t\tif ( ! geometry.groupIndices ) {\n\n\t\t\tconst triCount = getTriCount( geometry );\n\t\t\tconst array = new Uint16Array( triCount );\n\t\t\tconst groups = geometry.groups;\n\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\tconst { start, count } = groups[ i ];\n\t\t\t\tfor ( let g = start / 3, lg = ( start + count ) / 3; g < lg; g ++ ) {\n\n\t\t\t\t\tarray[ g ] = i;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.groupIndices = array;\n\n\t\t}\n\n\t}\n\n\tdisposeCacheData() {\n\n\t\tconst { geometry } = this;\n\t\tgeometry.halfEdges = null;\n\t\tgeometry.boundsTree = null;\n\t\tgeometry.groupIndices = null;\n\n\t}\n\n}\n","import { Vector3 } from 'three';\n\nconst EPSILON = 1e-14;\nconst _AB = new Vector3();\nconst _AC = new Vector3();\nconst _CB = new Vector3();\n\nexport function isTriDegenerate( tri, eps = EPSILON ) {\n\n\t// compute angles to determine whether they're degenerate\n\t_AB.subVectors( tri.b, tri.a );\n\t_AC.subVectors( tri.c, tri.a );\n\t_CB.subVectors( tri.b, tri.c );\n\n\tconst angle1 = _AB.angleTo( _AC );\t\t\t\t// AB v AC\n\tconst angle2 = _AB.angleTo( _CB );\t\t\t\t// AB v BC\n\tconst angle3 = Math.PI - angle1 - angle2;\t\t// 180deg - angle1 - angle2\n\n\treturn Math.abs( angle1 ) < eps ||\n\t\tMath.abs( angle2 ) < eps ||\n\t\tMath.abs( angle3 ) < eps ||\n\t\ttri.a.distanceToSquared( tri.b ) < eps ||\n\t\ttri.a.distanceToSquared( tri.c ) < eps ||\n\t\ttri.b.distanceToSquared( tri.c ) < eps;\n\n}\n","import { Triangle, Line3, Vector3, Plane } from 'three';\nimport { ExtendedTriangle } from 'three-mesh-bvh';\nimport { isTriDegenerate } from './utils/triangleUtils.js';\n\n// NOTE: these epsilons likely should all be the same since they're used to measure the\n// distance from a point to a plane which needs to be done consistently\nconst EPSILON = 1e-10;\nconst COPLANAR_EPSILON = 1e-10;\nconst PARALLEL_EPSILON = 1e-10;\nconst _edge = new Line3();\nconst _foundEdge = new Line3();\nconst _vec = new Vector3();\nconst _triangleNormal = new Vector3();\nconst _planeNormal = new Vector3();\nconst _plane = new Plane();\nconst _splittingTriangle = new ExtendedTriangle();\n\n// A pool of triangles to avoid unnecessary triangle creation\nclass TrianglePool {\n\n\tconstructor() {\n\n\t\tthis._pool = [];\n\t\tthis._index = 0;\n\n\t}\n\n\tgetTriangle() {\n\n\t\tif ( this._index >= this._pool.length ) {\n\n\t\t\tthis._pool.push( new Triangle() );\n\n\t\t}\n\n\t\treturn this._pool[ this._index ++ ];\n\n\t}\n\n\tclear() {\n\n\t\tthis._index = 0;\n\n\t}\n\n\treset() {\n\n\t\tthis._pool.length = 0;\n\t\tthis._index = 0;\n\n\t}\n\n}\n\n// Utility class for splitting triangles\nexport class TriangleSplitter {\n\n\tconstructor() {\n\n\t\tthis.trianglePool = new TrianglePool();\n\t\tthis.triangles = [];\n\t\tthis.normal = new Vector3();\n\t\tthis.coplanarTriangleUsed = false;\n\n\t}\n\n\t// initialize the class with a triangle\n\tinitialize( tri ) {\n\n\t\tthis.reset();\n\n\t\tconst { triangles, trianglePool, normal } = this;\n\t\tif ( Array.isArray( tri ) ) {\n\n\t\t\tfor ( let i = 0, l = tri.length; i < l; i ++ ) {\n\n\t\t\t\tconst t = tri[ i ];\n\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\tt.getNormal( normal );\n\n\t\t\t\t} else if ( Math.abs( 1.0 - t.getNormal( _vec ).dot( normal ) ) > EPSILON ) {\n\n\t\t\t\t\tthrow new Error( 'Triangle Splitter: Cannot initialize with triangles that have different normals.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst poolTri = trianglePool.getTriangle();\n\t\t\t\tpoolTri.copy( t );\n\t\t\t\ttriangles.push( poolTri );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\ttri.getNormal( normal );\n\n\t\t\tconst poolTri = trianglePool.getTriangle();\n\t\t\tpoolTri.copy( tri );\n\t\t\ttriangles.push( poolTri );\n\n\t\t}\n\n\t}\n\n\t// Split the current set of triangles by passing a single triangle in. If the triangle is\n\t// coplanar it will attempt to split by the triangle edge planes\n\tsplitByTriangle( triangle ) {\n\n\t\tconst { normal, triangles } = this;\n\t\ttriangle.getNormal( _triangleNormal ).normalize();\n\n\t\tif ( Math.abs( 1.0 - Math.abs( _triangleNormal.dot( normal ) ) ) < PARALLEL_EPSILON ) {\n\n\t\t\tthis.coplanarTriangleUsed = true;\n\n\t\t\tfor ( let i = 0, l = triangles.length; i < l; i ++ ) {\n\n\t\t\t\tconst t = triangles[ i ];\n\t\t\t\tt.coplanarCount = 0;\n\n\t\t\t}\n\n\t\t\t// if the triangle is coplanar then split by the edge planes\n\t\t\tconst arr = [ triangle.a, triangle.b, triangle.c ];\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst nexti = ( i + 1 ) % 3;\n\n\t\t\t\tconst v0 = arr[ i ];\n\t\t\t\tconst v1 = arr[ nexti ];\n\n\t\t\t\t// plane positive direction is toward triangle center\n\t\t\t\t_vec.subVectors( v1, v0 ).normalize();\n\t\t\t\t_planeNormal.crossVectors( _triangleNormal, _vec );\n\t\t\t\t_plane.setFromNormalAndCoplanarPoint( _planeNormal, v0 );\n\n\t\t\t\tthis.splitByPlane( _plane, triangle );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// otherwise split by the triangle plane\n\t\t\ttriangle.getPlane( _plane );\n\t\t\tthis.splitByPlane( _plane, triangle );\n\n\t\t}\n\n\t}\n\n\t// Split the triangles by the given plan. If a triangle is provided then we ensure we\n\t// intersect the triangle before splitting the plane\n\tsplitByPlane( plane, clippingTriangle ) {\n\n\t\tconst { triangles, trianglePool } = this;\n\n\t\t// init our triangle to check for intersection\n\t\t_splittingTriangle.copy( clippingTriangle );\n\t\t_splittingTriangle.needsUpdate = true;\n\n\t\t// try to split every triangle in the class\n\t\tfor ( let i = 0, l = triangles.length; i < l; i ++ ) {\n\n\t\t\tconst tri = triangles[ i ];\n\n\t\t\t// skip the triangle if we don't intersect with it\n\t\t\tif ( ! _splittingTriangle.intersectsTriangle( tri, _edge, true ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst { a, b, c } = tri;\n\t\t\tlet intersects = 0;\n\t\t\tlet vertexSplitEnd = - 1;\n\t\t\tlet coplanarEdge = false;\n\t\t\tlet posSideVerts = [];\n\t\t\tlet negSideVerts = [];\n\t\t\tconst arr = [ a, b, c ];\n\t\t\tfor ( let t = 0; t < 3; t ++ ) {\n\n\t\t\t\t// get the triangle edge\n\t\t\t\tconst tNext = ( t + 1 ) % 3;\n\t\t\t\t_edge.start.copy( arr[ t ] );\n\t\t\t\t_edge.end.copy( arr[ tNext ] );\n\n\t\t\t\t// track if the start point sits on the plane or if it's on the positive side of it\n\t\t\t\t// so we can use that information to determine whether to split later.\n\t\t\t\tconst startDist = plane.distanceToPoint( _edge.start );\n\t\t\t\tconst endDist = plane.distanceToPoint( _edge.end );\n\t\t\t\tif ( Math.abs( startDist ) < COPLANAR_EPSILON && Math.abs( endDist ) < COPLANAR_EPSILON ) {\n\n\t\t\t\t\tcoplanarEdge = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( startDist > 0 ) {\n\n\t\t\t\t\tposSideVerts.push( t );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnegSideVerts.push( t );\n\n\t\t\t\t}\n\n\t\t\t\t// we only don't consider this an intersection if the start points hits the plane\n\t\t\t\tif ( Math.abs( startDist ) < COPLANAR_EPSILON ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// double check the end point since the \"intersectLine\" function sometimes does not\n\t\t\t\t// return it as an intersection (see issue #28)\n\t\t\t\t// Because we ignore the start point intersection above we have to make sure we check the end\n\t\t\t\t// point intersection here.\n\t\t\t\tlet didIntersect = ! ! plane.intersectLine( _edge, _vec );\n\t\t\t\tif ( ! didIntersect && Math.abs( endDist ) < COPLANAR_EPSILON ) {\n\n\t\t\t\t\t_vec.copy( _edge.end );\n\t\t\t\t\tdidIntersect = true;\n\n\t\t\t\t}\n\n\t\t\t\t// check if we intersect the plane (ignoring the start point so we don't double count)\n\t\t\t\tif ( didIntersect && ! ( _vec.distanceTo( _edge.start ) < EPSILON ) ) {\n\n\t\t\t\t\t// if we intersect at the end point then we track that point as one that we\n\t\t\t\t\t// have to split down the middle\n\t\t\t\t\tif ( _vec.distanceTo( _edge.end ) < EPSILON ) {\n\n\t\t\t\t\t\tvertexSplitEnd = t;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// track the split edge\n\t\t\t\t\tif ( intersects === 0 ) {\n\n\t\t\t\t\t\t_foundEdge.start.copy( _vec );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_foundEdge.end.copy( _vec );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tintersects ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// skip splitting if:\n\t\t\t// - we have two points on the plane then the plane intersects the triangle exactly on an edge\n\t\t\t// - the plane does not intersect on 2 points\n\t\t\t// - the intersection edge is too small\n\t\t\t// - we're not along a coplanar edge\n\t\t\tif ( ! coplanarEdge && intersects === 2 && _foundEdge.distance() > COPLANAR_EPSILON ) {\n\n\t\t\t\tif ( vertexSplitEnd !== - 1 ) {\n\n\t\t\t\t\tvertexSplitEnd = ( vertexSplitEnd + 1 ) % 3;\n\n\t\t\t\t\t// we're splitting along a vertex\n\t\t\t\t\tlet otherVert1 = 0;\n\t\t\t\t\tif ( otherVert1 === vertexSplitEnd ) {\n\n\t\t\t\t\t\totherVert1 = ( otherVert1 + 1 ) % 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet otherVert2 = otherVert1 + 1;\n\t\t\t\t\tif ( otherVert2 === vertexSplitEnd ) {\n\n\t\t\t\t\t\totherVert2 = ( otherVert2 + 1 ) % 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst nextTri = trianglePool.getTriangle();\n\t\t\t\t\tnextTri.a.copy( arr[ otherVert2 ] );\n\t\t\t\t\tnextTri.b.copy( _foundEdge.end );\n\t\t\t\t\tnextTri.c.copy( _foundEdge.start );\n\n\t\t\t\t\tif ( ! isTriDegenerate( nextTri ) ) {\n\n\t\t\t\t\t\ttriangles.push( nextTri );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttri.a.copy( arr[ otherVert1 ] );\n\t\t\t\t\ttri.b.copy( _foundEdge.start );\n\t\t\t\t\ttri.c.copy( _foundEdge.end );\n\n\t\t\t\t\t// finish off the adjusted triangle\n\t\t\t\t\tif ( isTriDegenerate( tri ) ) {\n\n\t\t\t\t\t\ttriangles.splice( i, 1 );\n\t\t\t\t\t\ti --;\n\t\t\t\t\t\tl --;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// we're splitting with a quad and a triangle\n\t\t\t\t\t// TODO: what happens when we find that about the pos and negative\n\t\t\t\t\t// sides have only a single vertex?\n\t\t\t\t\tconst singleVert =\n\t\t\t\t\t\tposSideVerts.length >= 2 ?\n\t\t\t\t\t\t\tnegSideVerts[ 0 ] :\n\t\t\t\t\t\t\tposSideVerts[ 0 ];\n\n\t\t\t\t\t// swap the direction of the intersection edge depending on which\n\t\t\t\t\t// side of the plane the single vertex is on to align with the\n\t\t\t\t\t// correct winding order.\n\t\t\t\t\tif ( singleVert === 0 ) {\n\n\t\t\t\t\t\tlet tmp = _foundEdge.start;\n\t\t\t\t\t\t_foundEdge.start = _foundEdge.end;\n\t\t\t\t\t\t_foundEdge.end = tmp;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst nextVert1 = ( singleVert + 1 ) % 3;\n\t\t\t\t\tconst nextVert2 = ( singleVert + 2 ) % 3;\n\n\t\t\t\t\tconst nextTri1 = trianglePool.getTriangle();\n\t\t\t\t\tconst nextTri2 = trianglePool.getTriangle();\n\n\t\t\t\t\t// choose the triangle that has the larger areas (shortest split distance)\n\t\t\t\t\tif ( arr[ nextVert1 ].distanceToSquared( _foundEdge.start ) < arr[ nextVert2 ].distanceToSquared( _foundEdge.end ) ) {\n\n\t\t\t\t\t\tnextTri1.a.copy( arr[ nextVert1 ] );\n\t\t\t\t\t\tnextTri1.b.copy( _foundEdge.start );\n\t\t\t\t\t\tnextTri1.c.copy( _foundEdge.end );\n\n\t\t\t\t\t\tnextTri2.a.copy( arr[ nextVert1 ] );\n\t\t\t\t\t\tnextTri2.b.copy( arr[ nextVert2 ] );\n\t\t\t\t\t\tnextTri2.c.copy( _foundEdge.start );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnextTri1.a.copy( arr[ nextVert2 ] );\n\t\t\t\t\t\tnextTri1.b.copy( _foundEdge.start );\n\t\t\t\t\t\tnextTri1.c.copy( _foundEdge.end );\n\n\t\t\t\t\t\tnextTri2.a.copy( arr[ nextVert1 ] );\n\t\t\t\t\t\tnextTri2.b.copy( arr[ nextVert2 ] );\n\t\t\t\t\t\tnextTri2.c.copy( _foundEdge.end );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttri.a.copy( arr[ singleVert ] );\n\t\t\t\t\ttri.b.copy( _foundEdge.end );\n\t\t\t\t\ttri.c.copy( _foundEdge.start );\n\n\t\t\t\t\t// don't add degenerate triangles to the list\n\t\t\t\t\tif ( ! isTriDegenerate( nextTri1 ) ) {\n\n\t\t\t\t\t\ttriangles.push( nextTri1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! isTriDegenerate( nextTri2 ) ) {\n\n\t\t\t\t\t\ttriangles.push( nextTri2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// finish off the adjusted triangle\n\t\t\t\t\tif ( isTriDegenerate( tri ) ) {\n\n\t\t\t\t\t\ttriangles.splice( i, 1 );\n\t\t\t\t\t\ti --;\n\t\t\t\t\t\tl --;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( intersects === 3 ) {\n\n\t\t\t\tconsole.warn( 'TriangleClipper: Coplanar clip not handled' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treset() {\n\n\t\tthis.triangles.length = 0;\n\t\tthis.trianglePool.clear();\n\t\tthis.coplanarTriangleUsed = false;\n\n\t}\n\n}\n","import { areSharedArrayBuffersSupported } from './utils/geometryUtils.js';\n\nfunction ceilToFourByteStride( byteLength ) {\n\n\tbyteLength = ~ ~ byteLength;\n\treturn byteLength + 4 - byteLength % 4;\n\n}\n\n// Make a new array wrapper class that more easily affords expansion when reaching it's max capacity\nexport class TypeBackedArray {\n\n\tconstructor( type, initialSize = 500 ) {\n\n\n\t\tthis.expansionFactor = 1.5;\n\t\tthis.type = type;\n\t\tthis.length = 0;\n\t\tthis.array = null;\n\n\t\tthis.setSize( initialSize );\n\n\t}\n\n\tsetType( type ) {\n\n\t\tif ( this.length !== 0 ) {\n\n\t\t\tthrow new Error( 'TypeBackedArray: Cannot change the type while there is used data in the buffer.' );\n\n\t\t}\n\n\t\tconst buffer = this.array.buffer;\n\t\tthis.array = new type( buffer );\n\t\tthis.type = type;\n\n\t}\n\n\tsetSize( size ) {\n\n\t\tif ( this.array && size === this.array.length ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// ceil to the nearest 4 bytes so we can replace the array with any type using the same buffer\n\t\tconst type = this.type;\n\t\tconst bufferType = areSharedArrayBuffersSupported() ? SharedArrayBuffer : ArrayBuffer;\n\t\tconst newArray = new type( new bufferType( ceilToFourByteStride( size * type.BYTES_PER_ELEMENT ) ) );\n\t\tif ( this.array ) {\n\n\t\t\tnewArray.set( this.array, 0 );\n\n\t\t}\n\n\t\tthis.array = newArray;\n\n\t}\n\n\texpand() {\n\n\t\tconst { array, expansionFactor } = this;\n\t\tthis.setSize( array.length * expansionFactor );\n\n\t}\n\n\tpush( ...args ) {\n\n\t\tlet { array, length } = this;\n\t\tif ( length + args.length > array.length ) {\n\n\t\t\tthis.expand();\n\t\t\tarray = this.array;\n\n\t\t}\n\n\t\tfor ( let i = 0, l = args.length; i < l; i ++ ) {\n\n\t\t\tarray[ length + i ] = args[ i ];\n\n\t\t}\n\n\t\tthis.length += args.length;\n\n\t}\n\n\tclear() {\n\n\t\tthis.length = 0;\n\n\t}\n\n}\n","import { TypeBackedArray } from './TypeBackedArray.js';\n\n// Utility class for for tracking attribute data in type-backed arrays for a set\n// of groups. The set of attributes is kept for each group and are expected to be the\n// same buffer type.\nexport class TypedAttributeData {\n\n\tconstructor() {\n\n\t\tthis.groupAttributes = [ {} ];\n\t\tthis.groupCount = 0;\n\n\t}\n\n\t// returns the buffer type for the given attribute\n\tgetType( name ) {\n\n\t\treturn this.groupAttributes[ 0 ][ name ].type;\n\n\t}\n\n\tgetItemSize( name ) {\n\n\t\treturn this.groupAttributes[ 0 ][ name ].itemSize;\n\n\t}\n\n\tgetNormalized( name ) {\n\n\t\treturn this.groupAttributes[ 0 ][ name ].normalized;\n\n\t}\n\n\tgetCount( index ) {\n\n\t\tif ( this.groupCount <= index ) {\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst pos = this.getGroupAttrArray( 'position', index );\n\t\treturn pos.length / pos.itemSize;\n\n\t}\n\n\t// returns the total length required for all groups for the given attribute\n\tgetTotalLength( name ) {\n\n\t\tconst { groupCount, groupAttributes } = this;\n\n\t\tlet length = 0;\n\t\tfor ( let i = 0; i < groupCount; i ++ ) {\n\n\t\t\tconst attrSet = groupAttributes[ i ];\n\t\t\tlength += attrSet[ name ].length;\n\n\t\t}\n\n\t\treturn length;\n\n\t}\n\n\tgetGroupAttrSet( index = 0 ) {\n\n\t\t// TODO: can this be abstracted?\n\t\t// Return the exiting group set if necessary\n\t\tconst { groupAttributes } = this;\n\t\tif ( groupAttributes[ index ] ) {\n\n\t\t\tthis.groupCount = Math.max( this.groupCount, index + 1 );\n\t\t\treturn groupAttributes[ index ];\n\n\t\t}\n\n\t\t// add any new group sets required\n\t\tconst refAttrSet = groupAttributes[ 0 ];\n\t\tthis.groupCount = Math.max( this.groupCount, index + 1 );\n\t\twhile ( index >= groupAttributes.length ) {\n\n\t\t\tconst newAttrSet = {};\n\t\t\tgroupAttributes.push( newAttrSet );\n\t\t\tfor ( const key in refAttrSet ) {\n\n\t\t\t\tconst refAttr = refAttrSet[ key ];\n\t\t\t\tconst newAttr = new TypeBackedArray( refAttr.type );\n\t\t\t\tnewAttr.itemSize = refAttr.itemSize;\n\t\t\t\tnewAttr.normalized = refAttr.normalized;\n\t\t\t\tnewAttrSet[ key ] = newAttr;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn groupAttributes[ index ];\n\n\t}\n\n\t// Get the raw array for the group set of data\n\tgetGroupAttrArray( name, index = 0 ) {\n\n\t\t// throw an error if we've never\n\t\tconst { groupAttributes } = this;\n\t\tconst referenceAttrSet = groupAttributes[ 0 ];\n\t\tconst referenceAttr = referenceAttrSet[ name ];\n\t\tif ( ! referenceAttr ) {\n\n\t\t\tthrow new Error( `TypedAttributeData: Attribute with \"${ name }\" has not been initialized` );\n\n\t\t}\n\n\t\treturn this.getGroupAttrSet( index )[ name ];\n\n\t}\n\n\t// initializes an attribute array with the given name, type, and size\n\tinitializeArray( name, type, itemSize, normalized ) {\n\n\t\tconst { groupAttributes } = this;\n\t\tconst referenceAttrSet = groupAttributes[ 0 ];\n\t\tconst referenceAttr = referenceAttrSet[ name ];\n\t\tif ( referenceAttr ) {\n\n\t\t\tif ( referenceAttr.type !== type ) {\n\n\t\t\t\tfor ( let i = 0, l = groupAttributes.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst arr = groupAttributes[ i ][ name ];\n\t\t\t\t\tarr.setType( type );\n\t\t\t\t\tarr.itemSize = itemSize;\n\t\t\t\t\tarr.normalized = normalized;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0, l = groupAttributes.length; i < l; i ++ ) {\n\n\t\t\t\tconst arr = new TypeBackedArray( type );\n\t\t\t\tarr.itemSize = itemSize;\n\t\t\t\tarr.normalized = normalized;\n\t\t\t\tgroupAttributes[ i ][ name ] = arr;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Clear all the data\n\tclear() {\n\n\t\tthis.groupCount = 0;\n\n\t\tconst { groupAttributes } = this;\n\t\tgroupAttributes.forEach( attrSet => {\n\n\t\t\tfor ( const key in attrSet ) {\n\n\t\t\t\tattrSet[ key ].clear();\n\n\t\t\t}\n\n\n\t\t} );\n\n\t}\n\n\t// Remove the given key\n\tdelete( key ) {\n\n\t\tthis.groupAttributes.forEach( attrSet => {\n\n\t\t\tdelete attrSet[ key ];\n\n\t\t} );\n\n\t}\n\n\t// Reset the datasets completely\n\treset() {\n\n\t\tthis.groupAttributes = [];\n\t\tthis.groupCount = 0;\n\n\t}\n\n}\n","export class IntersectionMap {\n\n\tconstructor() {\n\n\t\tthis.intersectionSet = {};\n\t\tthis.ids = [];\n\n\t}\n\n\tadd( id, intersectionId ) {\n\n\t\tconst { intersectionSet, ids } = this;\n\t\tif ( ! intersectionSet[ id ] ) {\n\n\t\t\tintersectionSet[ id ] = [];\n\t\t\tids.push( id );\n\n\t\t}\n\n\t\tintersectionSet[ id ].push( intersectionId );\n\n\t}\n\n}\n","import { Ray, Matrix4, DoubleSide, Vector3, Vector4, Triangle, Line3 } from 'three';\nimport { IntersectionMap } from '../IntersectionMap.js';\nimport {\n\tADDITION,\n\tSUBTRACTION,\n\tREVERSE_SUBTRACTION,\n\tINTERSECTION,\n\tDIFFERENCE,\n\tHOLLOW_SUBTRACTION,\n\tHOLLOW_INTERSECTION,\n} from '../constants.js';\nimport { isTriDegenerate } from '../utils/triangleUtils.js';\n\nconst _ray = new Ray();\nconst _matrix = new Matrix4();\nconst _tri = new Triangle();\nconst _vec3 = new Vector3();\nconst _vec4a = new Vector4();\nconst _vec4b = new Vector4();\nconst _vec4c = new Vector4();\nconst _vec4_0 = new Vector4();\nconst _vec4_1 = new Vector4();\nconst _vec4_2 = new Vector4();\nconst _edge = new Line3();\nconst _normal = new Vector3();\nconst JITTER_EPSILON = 1e-8;\nconst OFFSET_EPSILON = 1e-15;\n\nexport const BACK_SIDE = - 1;\nexport const FRONT_SIDE = 1;\nexport const COPLANAR_OPPOSITE = - 2;\nexport const COPLANAR_ALIGNED = 2;\n\nexport const INVERT_TRI = 0;\nexport const ADD_TRI = 1;\nexport const SKIP_TRI = 2;\n\nconst FLOATING_COPLANAR_EPSILON = 1e-14;\n\nlet _debugContext = null;\nexport function setDebugContext( debugData ) {\n\n\t_debugContext = debugData;\n\n}\n\nexport function getHitSide( tri, bvh ) {\n\n\ttri.getMidpoint( _ray.origin );\n\ttri.getNormal( _ray.direction );\n\n\tconst hit = bvh.raycastFirst( _ray, DoubleSide );\n\tconst hitBackSide = Boolean( hit && _ray.direction.dot( hit.face.normal ) > 0 );\n\treturn hitBackSide ? BACK_SIDE : FRONT_SIDE;\n\n}\n\nexport function getHitSideWithCoplanarCheck( tri, bvh ) {\n\n\t// random function that returns [ - 0.5, 0.5 ];\n\tfunction rand() {\n\n\t\treturn Math.random() - 0.5;\n\n\t}\n\n\t// get the ray the check the triangle for\n\ttri.getNormal( _normal );\n\t_ray.direction.copy( _normal );\n\ttri.getMidpoint( _ray.origin );\n\n\tconst total = 3;\n\tlet count = 0;\n\tlet minDistance = Infinity;\n\tfor ( let i = 0; i < total; i ++ ) {\n\n\t\t// jitter the ray slightly\n\t\t_ray.direction.x += rand() * JITTER_EPSILON;\n\t\t_ray.direction.y += rand() * JITTER_EPSILON;\n\t\t_ray.direction.z += rand() * JITTER_EPSILON;\n\n\t\t// and invert it so we can account for floating point error by checking both directions\n\t\t// to catch coplanar distances\n\t\t_ray.direction.multiplyScalar( - 1 );\n\n\t\t// check if the ray hit the backside\n\t\tconst hit = bvh.raycastFirst( _ray, DoubleSide );\n\t\tlet hitBackSide = Boolean( hit && _ray.direction.dot( hit.face.normal ) > 0 );\n\t\tif ( hitBackSide ) {\n\n\t\t\tcount ++;\n\n\t\t}\n\n\t\tif ( hit !== null ) {\n\n\t\t\tminDistance = Math.min( minDistance, hit.distance );\n\n\t\t}\n\n\t\t// if we're right up against another face then we're coplanar\n\t\tif ( minDistance <= OFFSET_EPSILON ) {\n\n\t\t\treturn hit.face.normal.dot( _normal ) > 0 ? COPLANAR_ALIGNED : COPLANAR_OPPOSITE;\n\n\t\t}\n\n\t\t// if our current casts meet our requirements then early out\n\t\tif ( count / total > 0.5 || ( i - count + 1 ) / total > 0.5 ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\treturn count / total > 0.5 ? BACK_SIDE : FRONT_SIDE;\n\n}\n\n// returns the intersected triangles and returns objects mapping triangle indices to\n// the other triangles intersected\nexport function collectIntersectingTriangles( a, b ) {\n\n\tconst aIntersections = new IntersectionMap();\n\tconst bIntersections = new IntersectionMap();\n\n\t_matrix\n\t\t.copy( a.matrixWorld )\n\t\t.invert()\n\t\t.multiply( b.matrixWorld );\n\n\ta.geometry.boundsTree.bvhcast( b.geometry.boundsTree, _matrix, {\n\n\t\tintersectsTriangles( triangleA, triangleB, ia, ib ) {\n\n\t\t\tif ( ! isTriDegenerate( triangleA ) && ! isTriDegenerate( triangleB ) ) {\n\n\t\t\t\t// due to floating point error it's possible that we can have two overlapping, coplanar triangles\n\t\t\t\t// that are a _tiny_ fraction of a value away from each other. If we find that case then check the\n\t\t\t\t// distance between triangles and if it's small enough consider them intersecting.\n\t\t\t\tlet intersected = triangleA.intersectsTriangle( triangleB, _edge, true );\n\t\t\t\tif ( ! intersected ) {\n\n\t\t\t\t\tconst pa = triangleA.plane;\n\t\t\t\t\tconst pb = triangleB.plane;\n\t\t\t\t\tconst na = pa.normal;\n\t\t\t\t\tconst nb = pb.normal;\n\n\t\t\t\t\tif ( na.dot( nb ) === 1 && Math.abs( pa.constant - pb.constant ) < FLOATING_COPLANAR_EPSILON ) {\n\n\t\t\t\t\t\tintersected = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( intersected ) {\n\n\t\t\t\t\tlet va = a.geometry.boundsTree.resolveTriangleIndex( ia );\n\t\t\t\t\tlet vb = b.geometry.boundsTree.resolveTriangleIndex( ib );\n\t\t\t\t\taIntersections.add( va, vb );\n\t\t\t\t\tbIntersections.add( vb, va );\n\n\t\t\t\t\tif ( _debugContext ) {\n\n\t\t\t\t\t\t_debugContext.addEdge( _edge );\n\t\t\t\t\t\t_debugContext.addIntersectingTriangles( ia, triangleA, ib, triangleB );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\t} );\n\n\treturn { aIntersections, bIntersections };\n\n}\n\n// Add the barycentric interpolated values fro the triangle into the new attribute data\nexport function appendAttributeFromTriangle(\n\ttriIndex,\n\tbaryCoordTri,\n\tgeometry,\n\tmatrixWorld,\n\tnormalMatrix,\n\tattributeData,\n\tinvert = false,\n) {\n\n\tconst attributes = geometry.attributes;\n\tconst indexAttr = geometry.index;\n\tconst i3 = triIndex * 3;\n\tconst i0 = indexAttr.getX( i3 + 0 );\n\tconst i1 = indexAttr.getX( i3 + 1 );\n\tconst i2 = indexAttr.getX( i3 + 2 );\n\n\tfor ( const key in attributeData ) {\n\n\t\t// check if the key we're asking for is in the geometry at all\n\t\tconst attr = attributes[ key ];\n\t\tconst arr = attributeData[ key ];\n\t\tif ( ! ( key in attributes ) ) {\n\n\t\t\tthrow new Error( `CSG Operations: Attribute ${ key } not available on geometry.` );\n\n\t\t}\n\n\t\t// handle normals and positions specially because they require transforming\n\t\t// TODO: handle tangents\n\t\tconst itemSize = attr.itemSize;\n\t\tif ( key === 'position' ) {\n\n\t\t\t_tri.a.fromBufferAttribute( attr, i0 ).applyMatrix4( matrixWorld );\n\t\t\t_tri.b.fromBufferAttribute( attr, i1 ).applyMatrix4( matrixWorld );\n\t\t\t_tri.c.fromBufferAttribute( attr, i2 ).applyMatrix4( matrixWorld );\n\n\t\t\tpushBarycoordInterpolatedValues( _tri.a, _tri.b, _tri.c, baryCoordTri, 3, arr, invert );\n\n\t\t} else if ( key === 'normal' ) {\n\n\t\t\t_tri.a.fromBufferAttribute( attr, i0 ).applyNormalMatrix( normalMatrix );\n\t\t\t_tri.b.fromBufferAttribute( attr, i1 ).applyNormalMatrix( normalMatrix );\n\t\t\t_tri.c.fromBufferAttribute( attr, i2 ).applyNormalMatrix( normalMatrix );\n\n\t\t\tif ( invert ) {\n\n\t\t\t\t_tri.a.multiplyScalar( - 1 );\n\t\t\t\t_tri.b.multiplyScalar( - 1 );\n\t\t\t\t_tri.c.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t\tpushBarycoordInterpolatedValues( _tri.a, _tri.b, _tri.c, baryCoordTri, 3, arr, invert, true );\n\n\t\t} else {\n\n\t\t\t_vec4a.fromBufferAttribute( attr, i0 );\n\t\t\t_vec4b.fromBufferAttribute( attr, i1 );\n\t\t\t_vec4c.fromBufferAttribute( attr, i2 );\n\n\t\t\tpushBarycoordInterpolatedValues( _vec4a, _vec4b, _vec4c, baryCoordTri, itemSize, arr, invert );\n\n\t\t}\n\n\t}\n\n}\n\n// Append all the values of the attributes for the triangle onto the new attribute arrays\nexport function appendAttributesFromIndices(\n\ti0,\n\ti1,\n\ti2,\n\tattributes,\n\tmatrixWorld,\n\tnormalMatrix,\n\tattributeData,\n\tinvert = false,\n) {\n\n\tappendAttributeFromIndex( i0, attributes, matrixWorld, normalMatrix, attributeData, invert );\n\tappendAttributeFromIndex( invert ? i2 : i1, attributes, matrixWorld, normalMatrix, attributeData, invert );\n\tappendAttributeFromIndex( invert ? i1 : i2, attributes, matrixWorld, normalMatrix, attributeData, invert );\n\n}\n\n// Returns the triangle to add when performing an operation\nexport function getOperationAction( operation, hitSide, invert = false ) {\n\n\tswitch ( operation ) {\n\n\t\tcase ADDITION:\n\n\t\t\tif ( hitSide === FRONT_SIDE || ( hitSide === COPLANAR_ALIGNED && ! invert ) ) {\n\n\t\t\t\treturn ADD_TRI;\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase SUBTRACTION:\n\n\t\t\tif ( invert ) {\n\n\t\t\t\tif ( hitSide === BACK_SIDE ) {\n\n\t\t\t\t\treturn INVERT_TRI;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( hitSide === FRONT_SIDE || hitSide === COPLANAR_OPPOSITE ) {\n\n\t\t\t\t\treturn ADD_TRI;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase REVERSE_SUBTRACTION:\n\n\t\t\tif ( invert ) {\n\n\t\t\t\tif ( hitSide === FRONT_SIDE || hitSide === COPLANAR_OPPOSITE ) {\n\n\t\t\t\t\treturn ADD_TRI;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( hitSide === BACK_SIDE ) {\n\n\t\t\t\t\treturn INVERT_TRI;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase DIFFERENCE:\n\n\t\t\tif ( hitSide === BACK_SIDE ) {\n\n\t\t\t\treturn INVERT_TRI;\n\n\t\t\t} else if ( hitSide === FRONT_SIDE ) {\n\n\t\t\t\treturn ADD_TRI;\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase INTERSECTION:\n\t\t\tif ( hitSide === BACK_SIDE || ( hitSide === COPLANAR_ALIGNED && ! invert ) ) {\n\n\t\t\t\treturn ADD_TRI;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase HOLLOW_SUBTRACTION:\n\t\t\tif ( ! invert && ( hitSide === FRONT_SIDE || hitSide === COPLANAR_OPPOSITE ) ) {\n\n\t\t\t\treturn ADD_TRI;\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase HOLLOW_INTERSECTION:\n\t\t\tif ( ! invert && ( hitSide === BACK_SIDE || hitSide === COPLANAR_ALIGNED ) ) {\n\n\t\t\t\treturn ADD_TRI;\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new Error( `Unrecognized CSG operation enum \"${ operation }\".` );\n\n\t}\n\n\treturn SKIP_TRI;\n\n}\n\n// takes a set of barycentric values in the form of a triangle, a set of vectors, number of components,\n// and whether to invert the result and pushes the new values onto the provided attribute array\nfunction pushBarycoordInterpolatedValues( v0, v1, v2, baryCoordTri, itemSize, attrArr, invert = false, normalize = false ) {\n\n\t// adds the appropriate number of values for the vector onto the array\n\tconst addValues = v => {\n\n\t\tattrArr.push( v.x );\n\t\tif ( itemSize > 1 ) attrArr.push( v.y );\n\t\tif ( itemSize > 2 ) attrArr.push( v.z );\n\t\tif ( itemSize > 3 ) attrArr.push( v.w );\n\n\t};\n\n\t// barycentric interpolate the first component\n\t_vec4_0.set( 0, 0, 0, 0 )\n\t\t.addScaledVector( v0, baryCoordTri.a.x )\n\t\t.addScaledVector( v1, baryCoordTri.a.y )\n\t\t.addScaledVector( v2, baryCoordTri.a.z );\n\n\t_vec4_1.set( 0, 0, 0, 0 )\n\t\t.addScaledVector( v0, baryCoordTri.b.x )\n\t\t.addScaledVector( v1, baryCoordTri.b.y )\n\t\t.addScaledVector( v2, baryCoordTri.b.z );\n\n\t_vec4_2.set( 0, 0, 0, 0 )\n\t\t.addScaledVector( v0, baryCoordTri.c.x )\n\t\t.addScaledVector( v1, baryCoordTri.c.y )\n\t\t.addScaledVector( v2, baryCoordTri.c.z );\n\n\tif ( normalize ) {\n\n\t\t_vec4_0.normalize();\n\t\t_vec4_1.normalize();\n\t\t_vec4_2.normalize();\n\n\t}\n\n\t// if the face is inverted then add the values in an inverted order\n\taddValues( _vec4_0 );\n\n\tif ( invert ) {\n\n\t\taddValues( _vec4_2 );\n\t\taddValues( _vec4_1 );\n\n\t} else {\n\n\t\taddValues( _vec4_1 );\n\t\taddValues( _vec4_2 );\n\n\t}\n\n}\n\n// Adds the values for the given vertex index onto the new attribute arrays\nfunction appendAttributeFromIndex(\n\tindex,\n\tattributes,\n\tmatrixWorld,\n\tnormalMatrix,\n\tattributeData,\n\tinvert = false,\n) {\n\n\tfor ( const key in attributeData ) {\n\n\t\t// check if the key we're asking for is in the geometry at all\n\t\tconst attr = attributes[ key ];\n\t\tconst arr = attributeData[ key ];\n\t\tif ( ! ( key in attributes ) ) {\n\n\t\t\tthrow new Error( `CSG Operations: Attribute ${ key } no available on geometry.` );\n\n\t\t}\n\n\t\t// specially handle the position and normal attributes because they require transforms\n\t\t// TODO: handle tangents\n\t\tconst itemSize = attr.itemSize;\n\t\tif ( key === 'position' ) {\n\n\t\t\t_vec3.fromBufferAttribute( attr, index ).applyMatrix4( matrixWorld );\n\t\t\tarr.push( _vec3.x, _vec3.y, _vec3.z );\n\n\t\t} else if ( key === 'normal' ) {\n\n\t\t\t_vec3.fromBufferAttribute( attr, index ).applyNormalMatrix( normalMatrix );\n\t\t\tif ( invert ) {\n\n\t\t\t\t_vec3.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t\tarr.push( _vec3.x, _vec3.y, _vec3.z );\n\n\t\t} else {\n\n\t\t\tarr.push( attr.getX( index ) );\n\t\t\tif ( itemSize > 1 ) arr.push( attr.getY( index ) );\n\t\t\tif ( itemSize > 2 ) arr.push( attr.getZ( index ) );\n\t\t\tif ( itemSize > 3 ) arr.push( attr.getW( index ) );\n\n\t\t}\n\n\t}\n\n}\n","import { Triangle } from 'three';\nimport { setDebugContext } from '../operations/operationsUtils.js';\n\nclass TriangleIntersectData {\n\n\tconstructor( tri ) {\n\n\t\tthis.triangle = new Triangle().copy( tri );\n\t\tthis.intersects = {};\n\n\t}\n\n\taddTriangle( index, tri ) {\n\n\t\tthis.intersects[ index ] = new Triangle().copy( tri );\n\n\t}\n\n\tgetIntersectArray() {\n\n\t\tconst array = [];\n\t\tconst { intersects } = this;\n\t\tfor ( const key in intersects ) {\n\n\t\t\tarray.push( intersects[ key ] );\n\n\t\t}\n\n\t\treturn array;\n\n\t}\n\n}\n\nclass TriangleIntersectionSets {\n\n\tconstructor() {\n\n\t\tthis.data = {};\n\n\t}\n\n\taddTriangleIntersection( ia, triA, ib, triB ) {\n\n\t\tconst { data } = this;\n\t\tif ( ! data[ ia ] ) {\n\n\t\t\tdata[ ia ] = new TriangleIntersectData( triA );\n\n\t\t}\n\n\t\tdata[ ia ].addTriangle( ib, triB );\n\n\t}\n\n\tgetTrianglesAsArray( id = null ) {\n\n\t\tconst { data } = this;\n\t\tconst arr = [];\n\n\t\tif ( id !== null ) {\n\n\t\t\tif ( id in data ) {\n\n\t\t\t\tarr.push( data[ id ].triangle );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( const key in data ) {\n\n\t\t\t\tarr.push( data[ key ].triangle );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn arr;\n\n\t}\n\n\tgetTriangleIndices() {\n\n\t\treturn Object.keys( this.data ).map( i => parseInt( i ) );\n\n\t}\n\n\tgetIntersectionIndices( id ) {\n\n\t\tconst { data } = this;\n\t\tif ( ! data[ id ] ) {\n\n\t\t\treturn [];\n\n\t\t} else {\n\n\t\t\treturn Object.keys( data[ id ].intersects ).map( i => parseInt( i ) );\n\n\n\t\t}\n\n\t}\n\n\tgetIntersectionsAsArray( id = null, id2 = null ) {\n\n\t\tconst { data } = this;\n\t\tconst triSet = new Set();\n\t\tconst arr = [];\n\n\t\tconst addTriangles = key => {\n\n\t\t\tif ( ! data[ key ] ) return;\n\n\t\t\tif ( id2 !== null ) {\n\n\t\t\t\tif ( data[ key ].intersects[ id2 ] ) {\n\n\t\t\t\t\tarr.push( data[ key ].intersects[ id2 ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst intersects = data[ key ].intersects;\n\t\t\t\tfor ( const key2 in intersects ) {\n\n\t\t\t\t\tif ( ! triSet.has( key2 ) ) {\n\n\t\t\t\t\t\ttriSet.add( key2 );\n\t\t\t\t\t\tarr.push( intersects[ key2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tif ( id !== null ) {\n\n\t\t\taddTriangles( id );\n\n\t\t} else {\n\n\t\t\tfor ( const key in data ) {\n\n\t\t\t\taddTriangles( key );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn arr;\n\n\t}\n\n\treset() {\n\n\t\tthis.data = {};\n\n\t}\n\n}\n\nexport class OperationDebugData {\n\n\tconstructor() {\n\n\t\tthis.enabled = false;\n\t\tthis.triangleIntersectsA = new TriangleIntersectionSets();\n\t\tthis.triangleIntersectsB = new TriangleIntersectionSets();\n\t\tthis.intersectionEdges = [];\n\n\t}\n\n\taddIntersectingTriangles( ia, triA, ib, triB ) {\n\n\t\tconst { triangleIntersectsA, triangleIntersectsB } = this;\n\t\ttriangleIntersectsA.addTriangleIntersection( ia, triA, ib, triB );\n\t\ttriangleIntersectsB.addTriangleIntersection( ib, triB, ia, triA );\n\n\t}\n\n\taddEdge( edge ) {\n\n\t\tthis.intersectionEdges.push( edge.clone() );\n\n\t}\n\n\treset() {\n\n\t\tthis.triangleIntersectsA.reset();\n\t\tthis.triangleIntersectsB.reset();\n\t\tthis.intersectionEdges = [];\n\n\t}\n\n\tinit() {\n\n\t\tif ( this.enabled ) {\n\n\t\t\tthis.reset();\n\t\t\tsetDebugContext( this );\n\n\t\t}\n\n\t}\n\n\tcomplete() {\n\n\t\tif ( this.enabled ) {\n\n\t\t\tsetDebugContext( null );\n\n\t\t}\n\n\t}\n\n}\n","import { Matrix4, Matrix3, Triangle } from 'three';\nimport {\n\tgetHitSideWithCoplanarCheck,\n\tgetHitSide,\n\tcollectIntersectingTriangles,\n\tappendAttributeFromTriangle,\n\tappendAttributesFromIndices,\n\tgetOperationAction,\n\tSKIP_TRI, INVERT_TRI,\n} from './operationsUtils.js';\nimport { getTriCount } from '../utils/geometryUtils.js';\nimport { HOLLOW_INTERSECTION, HOLLOW_SUBTRACTION } from '../constants.js';\nimport { isTriDegenerate } from '../utils/triangleUtils.js';\n\nconst _matrix = new Matrix4();\nconst _normalMatrix = new Matrix3();\nconst _triA = new Triangle();\nconst _triB = new Triangle();\nconst _tri = new Triangle();\nconst _barycoordTri = new Triangle();\nconst _attr = [];\nconst _actions = [];\n\nfunction getFirstIdFromSet( set ) {\n\n\tfor ( const id of set ) return id;\n\n}\n\n// runs the given operation against a and b using the splitter and appending data to the\n// attributeData object.\nexport function performOperation(\n\ta,\n\tb,\n\toperations,\n\tsplitter,\n\tattributeData,\n\toptions = {},\n) {\n\n\tconst { useGroups = true } = options;\n\tconst { aIntersections, bIntersections } = collectIntersectingTriangles( a, b );\n\n\tconst resultGroups = [];\n\tlet resultMaterials = null;\n\n\tlet groupOffset;\n\tgroupOffset = useGroups ? 0 : - 1;\n\tperformSplitTriangleOperations( a, b, aIntersections, operations, false, splitter, attributeData, groupOffset );\n\tperformWholeTriangleOperations( a, b, aIntersections, operations, false, attributeData, groupOffset );\n\n\t// find whether the set of operations contains a non-hollow operations. If it does then we need\n\t// to perform the second set of triangle additions\n\tconst nonHollow = operations\n\t\t.findIndex( op => op !== HOLLOW_INTERSECTION && op !== HOLLOW_SUBTRACTION ) !== - 1;\n\n\tif ( nonHollow ) {\n\n\t\tgroupOffset = useGroups ? a.geometry.groups.length || 1 : - 1;\n\t\tperformSplitTriangleOperations( b, a, bIntersections, operations, true, splitter, attributeData, groupOffset );\n\t\tperformWholeTriangleOperations( b, a, bIntersections, operations, true, attributeData, groupOffset );\n\n\t}\n\n\t_attr.length = 0;\n\t_actions.length = 0;\n\n\treturn {\n\t\tgroups: resultGroups,\n\t\tmaterials: resultMaterials\n\t};\n\n}\n\n// perform triangle splitting and CSG operations on the set of split triangles\nfunction performSplitTriangleOperations(\n\ta,\n\tb,\n\tintersectionMap,\n\toperations,\n\tinvert,\n\tsplitter,\n\tattributeData,\n\tgroupOffset = 0,\n) {\n\n\tconst invertedGeometry = a.matrixWorld.determinant() < 0;\n\n\t// transforms into the local frame of matrix b\n\t_matrix\n\t\t.copy( b.matrixWorld )\n\t\t.invert()\n\t\t.multiply( a.matrixWorld );\n\n\t_normalMatrix\n\t\t.getNormalMatrix( a.matrixWorld )\n\t\t.multiplyScalar( invertedGeometry ? - 1 : 1 );\n\n\tconst groupIndices = a.geometry.groupIndices;\n\tconst aIndex = a.geometry.index;\n\tconst aPosition = a.geometry.attributes.position;\n\n\tconst bBVH = b.geometry.boundsTree;\n\tconst bIndex = b.geometry.index;\n\tconst bPosition = b.geometry.attributes.position;\n\tconst splitIds = intersectionMap.ids;\n\tconst intersectionSet = intersectionMap.intersectionSet;\n\n\t// iterate over all split triangle indices\n\tfor ( let i = 0, l = splitIds.length; i < l; i ++ ) {\n\n\t\tconst ia = splitIds[ i ];\n\t\tconst groupIndex = groupOffset === - 1 ? 0 : groupIndices[ ia ] + groupOffset;\n\n\t\t// get the triangle in the geometry B local frame\n\t\tconst ia3 = 3 * ia;\n\t\tconst ia0 = aIndex.getX( ia3 + 0 );\n\t\tconst ia1 = aIndex.getX( ia3 + 1 );\n\t\tconst ia2 = aIndex.getX( ia3 + 2 );\n\t\t_triA.a.fromBufferAttribute( aPosition, ia0 ).applyMatrix4( _matrix );\n\t\t_triA.b.fromBufferAttribute( aPosition, ia1 ).applyMatrix4( _matrix );\n\t\t_triA.c.fromBufferAttribute( aPosition, ia2 ).applyMatrix4( _matrix );\n\n\t\t// initialize the splitter with the triangle from geometry A\n\t\tsplitter.reset();\n\t\tsplitter.initialize( _triA );\n\n\t\t// split the triangle with the intersecting triangles from B\n\t\tconst intersectingIndices = intersectionSet[ ia ];\n\t\tfor ( let ib = 0, l = intersectingIndices.length; ib < l; ib ++ ) {\n\n\t\t\tconst ib3 = 3 * intersectingIndices[ ib ];\n\t\t\tconst ib0 = bIndex.getX( ib3 + 0 );\n\t\t\tconst ib1 = bIndex.getX( ib3 + 1 );\n\t\t\tconst ib2 = bIndex.getX( ib3 + 2 );\n\t\t\t_triB.a.fromBufferAttribute( bPosition, ib0 );\n\t\t\t_triB.b.fromBufferAttribute( bPosition, ib1 );\n\t\t\t_triB.c.fromBufferAttribute( bPosition, ib2 );\n\t\t\tsplitter.splitByTriangle( _triB );\n\n\t\t}\n\n\t\t// for all triangles in the split result\n\t\tconst triangles = splitter.triangles;\n\t\tfor ( let ib = 0, l = triangles.length; ib < l; ib ++ ) {\n\n\t\t\t// get the barycentric coordinates of the clipped triangle to add\n\t\t\tconst clippedTri = triangles[ ib ];\n\n\t\t\t// try to use the side derived from the clipping but if it turns out to be\n\t\t\t// uncertain then fall back to the raycasting approach\n\t\t\tconst hitSide = splitter.coplanarTriangleUsed ?\n\t\t\t\tgetHitSideWithCoplanarCheck( clippedTri, bBVH ) :\n\t\t\t\tgetHitSide( clippedTri, bBVH );\n\n\t\t\t_attr.length = 0;\n\t\t\t_actions.length = 0;\n\t\t\tfor ( let o = 0, lo = operations.length; o < lo; o ++ ) {\n\n\t\t\t\tconst op = getOperationAction( operations[ o ], hitSide, invert );\n\t\t\t\tif ( op !== SKIP_TRI ) {\n\n\t\t\t\t\t_actions.push( op );\n\t\t\t\t\t_attr.push( attributeData[ o ].getGroupAttrSet( groupIndex ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( _attr.length !== 0 ) {\n\n\t\t\t\t_triA.getBarycoord( clippedTri.a, _barycoordTri.a );\n\t\t\t\t_triA.getBarycoord( clippedTri.b, _barycoordTri.b );\n\t\t\t\t_triA.getBarycoord( clippedTri.c, _barycoordTri.c );\n\n\t\t\t\tfor ( let k = 0, lk = _attr.length; k < lk; k ++ ) {\n\n\t\t\t\t\tconst attrSet = _attr[ k ];\n\t\t\t\t\tconst action = _actions[ k ];\n\t\t\t\t\tconst invertTri = action === INVERT_TRI;\n\t\t\t\t\tappendAttributeFromTriangle( ia, _barycoordTri, a.geometry, a.matrixWorld, _normalMatrix, attrSet, invertedGeometry !== invertTri );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn splitIds.length;\n\n}\n\n// perform CSG operations on the set of whole triangles using a half edge structure\n// at the moment this isn't always faster due to overhead of building the half edge structure\n// and degraded connectivity due to split triangles.\n\nfunction performWholeTriangleOperations(\n\ta,\n\tb,\n\tsplitTriSet,\n\toperations,\n\tinvert,\n\tattributeData,\n\tgroupOffset = 0,\n) {\n\n\tconst invertedGeometry = a.matrixWorld.determinant() < 0;\n\n\t// matrix for transforming into the local frame of geometry b\n\t_matrix\n\t\t.copy( b.matrixWorld )\n\t\t.invert()\n\t\t.multiply( a.matrixWorld );\n\n\t_normalMatrix\n\t\t.getNormalMatrix( a.matrixWorld )\n\t\t.multiplyScalar( invertedGeometry ? - 1 : 1 );\n\n\tconst bBVH = b.geometry.boundsTree;\n\tconst groupIndices = a.geometry.groupIndices;\n\tconst aIndex = a.geometry.index;\n\tconst aAttributes = a.geometry.attributes;\n\tconst aPosition = aAttributes.position;\n\n\tconst stack = [];\n\tconst halfEdges = a.geometry.halfEdges;\n\tconst traverseSet = new Set();\n\tconst triCount = getTriCount( a.geometry );\n\tfor ( let i = 0, l = triCount; i < l; i ++ ) {\n\n\t\tif ( ! ( i in splitTriSet.intersectionSet ) ) {\n\n\t\t\ttraverseSet.add( i );\n\n\t\t}\n\n\t}\n\n\twhile ( traverseSet.size > 0 ) {\n\n\t\tconst id = getFirstIdFromSet( traverseSet );\n\t\ttraverseSet.delete( id );\n\n\t\tstack.push( id );\n\n\t\t// get the vertex indices\n\t\tconst i3 = 3 * id;\n\t\tconst i0 = aIndex.getX( i3 + 0 );\n\t\tconst i1 = aIndex.getX( i3 + 1 );\n\t\tconst i2 = aIndex.getX( i3 + 2 );\n\n\t\t// get the vertex position in the frame of geometry b so we can\n\t\t// perform hit testing\n\t\t_tri.a.fromBufferAttribute( aPosition, i0 ).applyMatrix4( _matrix );\n\t\t_tri.b.fromBufferAttribute( aPosition, i1 ).applyMatrix4( _matrix );\n\t\t_tri.c.fromBufferAttribute( aPosition, i2 ).applyMatrix4( _matrix );\n\n\t\t// get the side and decide if we need to cull the triangle based on the operation\n\t\tconst hitSide = getHitSide( _tri, bBVH );\n\n\t\t_actions.length = 0;\n\t\t_attr.length = 0;\n\t\tfor ( let o = 0, lo = operations.length; o < lo; o ++ ) {\n\n\t\t\tconst op = getOperationAction( operations[ o ], hitSide, invert );\n\t\t\tif ( op !== SKIP_TRI ) {\n\n\t\t\t\t_actions.push( op );\n\t\t\t\t_attr.push( attributeData[ o ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\twhile ( stack.length > 0 ) {\n\n\t\t\tconst currId = stack.pop();\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst sid = halfEdges.getSiblingTriangleIndex( currId, i );\n\t\t\t\tif ( sid !== - 1 && traverseSet.has( sid ) ) {\n\n\t\t\t\t\tstack.push( sid );\n\t\t\t\t\ttraverseSet.delete( sid );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( _attr.length !== 0 ) {\n\n\t\t\t\tconst i3 = 3 * currId;\n\t\t\t\tconst i0 = aIndex.getX( i3 + 0 );\n\t\t\t\tconst i1 = aIndex.getX( i3 + 1 );\n\t\t\t\tconst i2 = aIndex.getX( i3 + 2 );\n\t\t\t\tconst groupIndex = groupOffset === - 1 ? 0 : groupIndices[ currId ] + groupOffset;\n\n\t\t\t\t_tri.a.fromBufferAttribute( aPosition, i0 );\n\t\t\t\t_tri.b.fromBufferAttribute( aPosition, i1 );\n\t\t\t\t_tri.c.fromBufferAttribute( aPosition, i2 );\n\t\t\t\tif ( ! isTriDegenerate( _tri ) ) {\n\n\t\t\t\t\tfor ( let k = 0, lk = _attr.length; k < lk; k ++ ) {\n\n\t\t\t\t\t\tconst action = _actions[ k ];\n\t\t\t\t\t\tconst attrSet = _attr[ k ].getGroupAttrSet( groupIndex );\n\t\t\t\t\t\tconst invertTri = action === INVERT_TRI;\n\t\t\t\t\t\tappendAttributesFromIndices( i0, i1, i2, aAttributes, a.matrixWorld, _normalMatrix, attrSet, invertTri !== invertedGeometry );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n","import { BufferAttribute } from 'three';\nimport { TriangleSplitter } from './TriangleSplitter.js';\nimport { TypedAttributeData } from './TypedAttributeData.js';\nimport { OperationDebugData } from './debug/OperationDebugData.js';\nimport { performOperation } from './operations/operations.js';\nimport { Brush } from './Brush.js';\n\n// merges groups with common material indices in place\nfunction joinGroups( groups ) {\n\n\tfor ( let i = 0; i < groups.length - 1; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\t\tconst nextGroup = groups[ i + 1 ];\n\t\tif ( group.materialIndex === nextGroup.materialIndex ) {\n\n\t\t\tconst start = group.start;\n\t\t\tconst end = nextGroup.start + nextGroup.count;\n\t\t\tnextGroup.start = start;\n\t\t\tnextGroup.count = end - start;\n\n\t\t\tgroups.splice( i, 1 );\n\t\t\ti --;\n\n\t\t}\n\n\t}\n\n}\n\n// initialize the target geometry and attribute data to be based on\n// the given reference geometry\nfunction prepareAttributesData( referenceGeometry, targetGeometry, attributeData, relevantAttributes ) {\n\n\tattributeData.clear();\n\n\t// initialize and clear unused data from the attribute buffers and vice versa\n\tconst aAttributes = referenceGeometry.attributes;\n\tfor ( let i = 0, l = relevantAttributes.length; i < l; i ++ ) {\n\n\t\tconst key = relevantAttributes[ i ];\n\t\tconst aAttr = aAttributes[ key ];\n\t\tattributeData.initializeArray( key, aAttr.array.constructor, aAttr.itemSize, aAttr.normalized );\n\n\t}\n\n\tfor ( const key in attributeData.attributes ) {\n\n\t\tif ( ! relevantAttributes.includes( key ) ) {\n\n\t\t\tattributeData.delete( key );\n\n\t\t}\n\n\t}\n\n\tfor ( const key in targetGeometry.attributes ) {\n\n\t\tif ( ! relevantAttributes.includes( key ) ) {\n\n\t\t\ttargetGeometry.deleteAttribute( key );\n\t\t\ttargetGeometry.dispose();\n\n\t\t}\n\n\t}\n\n}\n\n// Assigns the given tracked attribute data to the geometry and returns whether the\n// geometry needs to be disposed of.\nfunction assignBufferData( geometry, attributeData, groupOrder ) {\n\n\tlet needsDisposal = false;\n\tlet drawRange = - 1;\n\n\t// set the data\n\tconst attributes = geometry.attributes;\n\tconst referenceAttrSet = attributeData.groupAttributes[ 0 ];\n\tfor ( const key in referenceAttrSet ) {\n\n\t\tconst requiredLength = attributeData.getTotalLength( key );\n\t\tconst type = attributeData.getType( key );\n\t\tconst itemSize = attributeData.getItemSize( key );\n\t\tconst normalized = attributeData.getNormalized( key );\n\t\tlet geoAttr = attributes[ key ];\n\t\tif ( ! geoAttr || geoAttr.array.length < requiredLength ) {\n\n\t\t\t// create the attribute if it doesn't exist yet\n\t\t\tgeoAttr = new BufferAttribute( new type( requiredLength ), itemSize, normalized );\n\t\t\tgeometry.setAttribute( key, geoAttr );\n\t\t\tneedsDisposal = true;\n\n\t\t}\n\n\t\t// assign the data to the geometry attribute buffers in the provided order\n\t\t// of the groups list\n\t\tlet offset = 0;\n\t\tfor ( let i = 0, l = Math.min( groupOrder.length, attributeData.groupCount ); i < l; i ++ ) {\n\n\t\t\tconst index = groupOrder[ i ].index;\n\t\t\tconst { array, type, length } = attributeData.groupAttributes[ index ][ key ];\n\t\t\tconst trimmedArray = new type( array.buffer, 0, length );\n\t\t\tgeoAttr.array.set( trimmedArray, offset );\n\t\t\toffset += trimmedArray.length;\n\n\t\t}\n\n\t\tgeoAttr.needsUpdate = true;\n\t\tdrawRange = requiredLength / geoAttr.itemSize;\n\n\t}\n\n\t// remove or update the index appropriately\n\tif ( geometry.index ) {\n\n\t\tconst indexArray = geometry.index.array;\n\t\tif ( indexArray.length < drawRange ) {\n\n\t\t\tgeometry.index = null;\n\t\t\tneedsDisposal = true;\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0, l = indexArray.length; i < l; i ++ ) {\n\n\t\t\t\tindexArray[ i ] = i;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// initialize the groups\n\tlet groupOffset = 0;\n\tgeometry.clearGroups();\n\tfor ( let i = 0, l = Math.min( groupOrder.length, attributeData.groupCount ); i < l; i ++ ) {\n\n\t\tconst { index, materialIndex } = groupOrder[ i ];\n\t\tconst vertCount = attributeData.getCount( index );\n\t\tif ( vertCount !== 0 ) {\n\n\t\t\tgeometry.addGroup( groupOffset, vertCount, materialIndex );\n\t\t\tgroupOffset += vertCount;\n\n\t\t}\n\n\t}\n\n\t// update the draw range\n\tgeometry.setDrawRange( 0, drawRange );\n\n\t// remove the bounds tree if it exists because its now out of date\n\t// TODO: can we have this dispose in the same way that a brush does?\n\t// TODO: why are half edges and group indices not removed here?\n\tgeometry.boundsTree = null;\n\n\tif ( needsDisposal ) {\n\n\t\tgeometry.dispose();\n\n\t}\n\n}\n\n// Returns the list of materials used for the given set of groups\nfunction getMaterialList( groups, materials ) {\n\n\tlet result = materials;\n\tif ( ! Array.isArray( materials ) ) {\n\n\t\tresult = [];\n\t\tgroups.forEach( g => {\n\n\t\t\tresult[ g.materialIndex ] = materials;\n\n\t\t} );\n\n\t}\n\n\treturn result;\n\n}\n\n// Utility class for performing CSG operations\nexport class Evaluator {\n\n\tconstructor() {\n\n\t\tthis.triangleSplitter = new TriangleSplitter();\n\t\tthis.attributeData = [];\n\t\tthis.attributes = [ 'position', 'uv', 'normal' ];\n\t\tthis.useGroups = true;\n\t\tthis.consolidateGroups = true;\n\t\tthis.debug = new OperationDebugData();\n\n\t}\n\n\tgetGroupRanges( geometry ) {\n\n\t\treturn ! this.useGroups || geometry.groups.length === 0 ?\n\t\t\t[ { start: 0, count: Infinity, materialIndex: 0 } ] :\n\t\t\tgeometry.groups.map( group => ( { ...group } ) );\n\n\t}\n\n\tevaluate( a, b, operations, targetBrushes = new Brush() ) {\n\n\t\tlet wasArray = true;\n\t\tif ( ! Array.isArray( operations ) ) {\n\n\t\t\toperations = [ operations ];\n\n\t\t}\n\n\t\tif ( ! Array.isArray( targetBrushes ) ) {\n\n\t\t\ttargetBrushes = [ targetBrushes ];\n\t\t\twasArray = false;\n\n\t\t}\n\n\t\tif ( targetBrushes.length !== operations.length ) {\n\n\t\t\tthrow new Error( 'Evaluator: operations and target array passed as different sizes.' );\n\n\t\t}\n\n\t\ta.prepareGeometry();\n\t\tb.prepareGeometry();\n\n\t\tconst {\n\t\t\ttriangleSplitter,\n\t\t\tattributeData,\n\t\t\tattributes,\n\t\t\tuseGroups,\n\t\t\tconsolidateGroups,\n\t\t\tdebug,\n\t\t} = this;\n\n\t\t// expand the attribute data array to the necessary size\n\t\twhile ( attributeData.length < targetBrushes.length ) {\n\n\t\t\tattributeData.push( new TypedAttributeData() );\n\n\t\t}\n\n\t\t// prepare the attribute data buffer information\n\t\ttargetBrushes.forEach( ( brush, i ) => {\n\n\t\t\tprepareAttributesData( a.geometry, brush.geometry, attributeData[ i ], attributes );\n\n\t\t} );\n\n\t\t// run the operation to fill the list of attribute data\n\t\tdebug.init();\n\t\tperformOperation( a, b, operations, triangleSplitter, attributeData, { useGroups } );\n\t\tdebug.complete();\n\n\t\t// get the materials and group ranges\n\t\tconst aGroups = this.getGroupRanges( a.geometry );\n\t\tconst aMaterials = getMaterialList( aGroups, a.material );\n\n\t\tconst bGroups = this.getGroupRanges( b.geometry );\n\t\tconst bMaterials = getMaterialList( bGroups, b.material );\n\t\tbGroups.forEach( g => g.materialIndex += aMaterials.length );\n\n\t\tlet groups = [ ...aGroups, ...bGroups ]\n\t\t\t.map( ( group, index ) => ( { ...group, index } ) );\n\n\t\t// generate the minimum set of materials needed for the list of groups and adjust the groups\n\t\t// if they're needed\n\t\tif ( useGroups ) {\n\n\t\t\tconst allMaterials = [ ...aMaterials, ...bMaterials ];\n\t\t\tif ( consolidateGroups ) {\n\n\t\t\t\tgroups = groups\n\t\t\t\t\t.map( group => {\n\n\t\t\t\t\t\tconst mat = allMaterials[ group.materialIndex ];\n\t\t\t\t\t\tgroup.materialIndex = allMaterials.indexOf( mat );\n\t\t\t\t\t\treturn group;\n\n\t\t\t\t\t} )\n\t\t\t\t\t.sort( ( a, b ) => {\n\n\t\t\t\t\t\treturn a.materialIndex - b.materialIndex;\n\n\t\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\t// create a map from old to new index and remove materials that aren't used\n\t\t\tconst finalMaterials = [];\n\t\t\tfor ( let i = 0, l = allMaterials.length; i < l; i ++ ) {\n\n\t\t\t\tlet foundGroup = false;\n\t\t\t\tfor ( let g = 0, lg = groups.length; g < lg; g ++ ) {\n\n\t\t\t\t\tconst group = groups[ g ];\n\t\t\t\t\tif ( group.materialIndex === i ) {\n\n\t\t\t\t\t\tfoundGroup = true;\n\t\t\t\t\t\tgroup.materialIndex = finalMaterials.length;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( foundGroup ) {\n\n\t\t\t\t\tfinalMaterials.push( allMaterials[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttargetBrushes.forEach( tb => {\n\n\t\t\t\ttb.material = finalMaterials;\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\tgroups = [ { start: 0, count: Infinity, index: 0, materialIndex: 0 } ];\n\t\t\ttargetBrushes.forEach( tb => {\n\n\t\t\t\ttb.material = aMaterials[ 0 ];\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// apply groups and attribute data to the geometry\n\t\ttargetBrushes.forEach( ( brush, i ) => {\n\n\t\t\tconst targetGeometry = brush.geometry;\n\t\t\tassignBufferData( targetGeometry, attributeData[ i ], groups );\n\t\t\tif ( consolidateGroups ) {\n\n\t\t\t\tjoinGroups( targetGeometry.groups );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn wasArray ? targetBrushes : targetBrushes[ 0 ];\n\n\t}\n\n\t// TODO: fix\n\tevaluateHierarchy( root, target = new Brush() ) {\n\n\t\troot.updateMatrixWorld( true );\n\n\t\tconst flatTraverse = ( obj, cb ) => {\n\n\t\t\tconst children = obj.children;\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = children[ i ];\n\t\t\t\tif ( child.isOperationGroup ) {\n\n\t\t\t\t\tflatTraverse( child, cb );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcb( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\n\t\tconst traverse = brush => {\n\n\t\t\tconst children = brush.children;\n\t\t\tlet didChange = false;\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = children[ i ];\n\t\t\t\tdidChange = traverse( child ) || didChange;\n\n\t\t\t}\n\n\t\t\tconst isDirty = brush.isDirty();\n\t\t\tif ( isDirty ) {\n\n\t\t\t\tbrush.markUpdated();\n\n\t\t\t}\n\n\t\t\tif ( didChange && ! brush.isOperationGroup ) {\n\n\t\t\t\tlet result;\n\t\t\t\tflatTraverse( brush, child => {\n\n\t\t\t\t\tif ( ! result ) {\n\n\t\t\t\t\t\tresult = this.evaluate( brush, child, child.operation );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tresult = this.evaluate( result, child, child.operation );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tbrush._cachedGeometry = result.geometry;\n\t\t\t\tbrush._cachedMaterials = result.material;\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn didChange || isDirty;\n\n\t\t\t}\n\n\t\t};\n\n\t\ttraverse( root );\n\n\t\ttarget.geometry = root._cachedGeometry;\n\t\ttarget.material = root._cachedMaterials;\n\n\t\treturn target;\n\n\t}\n\n\treset() {\n\n\t\tthis.triangleSplitter.reset();\n\n\t}\n\n}\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { extend } from '@react-three/fiber';\nimport { Evaluator, ADDITION, Brush, SUBTRACTION, REVERSE_SUBTRACTION, DIFFERENCE, INTERSECTION } from 'three-bvh-csg';\n\nconst TYPES = {\n  subtraction: SUBTRACTION,\n  reverseSubtraction: REVERSE_SUBTRACTION,\n  addition: ADDITION,\n  difference: DIFFERENCE,\n  intersection: INTERSECTION\n};\n\nfunction dispose(geometry) {\n  geometry.dispose();\n  geometry.attributes = {};\n  geometry.groups = [];\n  geometry.boundsTree = geometry.index = geometry.boundingBox = geometry.boundingSphere = null;\n  geometry.drawRange = {\n    start: 0,\n    count: Infinity\n  };\n}\n\nfunction resolve(op) {\n  let currentOp = null;\n\n  if (op instanceof Brush) {\n    op.updateMatrixWorld();\n    currentOp = op;\n  } else {\n    op.traverse(obj => {\n      obj.updateMatrixWorld();\n      if (!currentOp && obj instanceof Brush) currentOp = obj;\n    });\n  }\n\n  return currentOp;\n}\n\nconst csgContext = /*#__PURE__*/React.createContext(null);\nconst Geometry = /*#__PURE__*/React.forwardRef(({\n  children,\n  computeVertexNormals = false,\n  useGroups = false,\n  showOperations = false\n}, fref) => {\n  const geo = React.useRef(null);\n  const operations = React.useRef(null);\n  const ev = React.useMemo(() => Object.assign(new Evaluator(), {\n    useGroups\n  }), [useGroups]);\n  const update = React.useCallback(() => {\n    try {\n      const ops = operations.current.children.slice();\n\n      if (ops.length > 0) {\n        // Dispose old geometry\n        dispose(geo.current); // Set the ops groups matrix to identiy\n\n        operations.current.matrixWorld.identity();\n        let root = resolve(ops.shift());\n\n        if (root) {\n          var _geo$current, _geo$current$__r3f, _geo$current$__r3f$pa;\n\n          while (ops.length) {\n            const op = resolve(ops.shift());\n            if (op) root = ev.evaluate(root, op, TYPES[op.operator] || ADDITION);\n          }\n\n          ;\n          geo.current.boundsTree = root.geometry.boundsTree;\n          geo.current.index = root.geometry.index;\n          geo.current.attributes = root.geometry.attributes;\n          geo.current.groups = root.geometry.groups;\n          geo.current.drawRange = root.geometry.drawRange;\n          if (ev.useGroups && (_geo$current = geo.current) != null && (_geo$current$__r3f = _geo$current.__r3f) != null && (_geo$current$__r3f$pa = _geo$current$__r3f.parent) != null && _geo$current$__r3f$pa.material) geo.current.__r3f.parent.material = root.material;\n          if (computeVertexNormals) geo.current.computeVertexNormals();\n        }\n      }\n    } catch (e) {\n      console.log(e);\n    }\n  }, [computeVertexNormals, ev]);\n  const api = React.useMemo(() => ({\n    computeVertexNormals,\n    showOperations,\n    useGroups,\n    update\n  }), [computeVertexNormals, showOperations, useGroups]);\n  React.useLayoutEffect(() => void update());\n  React.useImperativeHandle(fref, () => ({\n    geometry: geo.current,\n    operations: operations.current,\n    ...api\n  }), [api]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"group\", {\n    matrixAutoUpdate: false,\n    ref: operations\n  }, /*#__PURE__*/React.createElement(csgContext.Provider, {\n    value: api\n  }, children)), /*#__PURE__*/React.createElement(\"bufferGeometry\", {\n    ref: geo\n  }));\n});\nconst Base = /*#__PURE__*/React.forwardRef(({\n  showOperation = false,\n  operator = 'addition',\n  ...props\n}, fref) => {\n  extend({\n    Brush: Brush\n  });\n  const {\n    showOperations\n  } = React.useContext(csgContext);\n  return /*#__PURE__*/React.createElement(\"brush\", _extends({\n    operator: operator,\n    raycast: () => null,\n    visible: showOperation || showOperations,\n    ref: fref\n  }, props));\n});\nconst Addition = /*#__PURE__*/React.forwardRef((props, fref) => /*#__PURE__*/React.createElement(Base, _extends({\n  ref: fref,\n  operator: \"addition\"\n}, props)));\nconst Subtraction = /*#__PURE__*/React.forwardRef((props, fref) => /*#__PURE__*/React.createElement(Base, _extends({\n  ref: fref,\n  operator: \"subtraction\"\n}, props)));\nconst ReverseSubtraction = /*#__PURE__*/React.forwardRef((props, fref) => /*#__PURE__*/React.createElement(Base, _extends({\n  ref: fref,\n  operator: \"reverseSubtraction\"\n}, props)));\nconst Difference = /*#__PURE__*/React.forwardRef((props, fref) => /*#__PURE__*/React.createElement(Base, _extends({\n  ref: fref,\n  operator: \"difference\"\n}, props)));\nconst Intersection = /*#__PURE__*/React.forwardRef((props, fref) => /*#__PURE__*/React.createElement(Base, _extends({\n  ref: fref,\n  operator: \"intersection\"\n}, props)));\nfunction useCSG() {\n  return React.useContext(csgContext);\n}\n\nexport { Addition, Base, Difference, Geometry, Intersection, ReverseSubtraction, Subtraction, useCSG };\n"],"names":["ADDITION","SUBTRACTION","REVERSE_SUBTRACTION","INTERSECTION","DIFFERENCE","HOLLOW_SUBTRACTION","HOLLOW_INTERSECTION","CENTER","AVERAGE","SAH","CONTAINED","TRIANGLE_INTERSECT_COST","TRAVERSAL_COST","IS_LEAFNODE_FLAG","FLOAT32_EPSILON","Math","pow","SKIP_GENERATION","Symbol","getTriCount","geo","index","count","attributes","position","getVertexCount","ensureIndex","options","vertexCount","BufferConstructor","arguments","length","undefined","ArrayBuffer","Uint32Array","Uint16Array","getIndexArray","useSharedArrayBuffer","SharedArrayBuffer","setIndex","BufferAttribute","i","getFullGeometryRange","triCount","drawRange","start","end","offset","max","min","floor","getRootIndexRanges","groups","ranges","rangeBoundaries","Set","drawRangeStart","drawRangeEnd","group","groupStart","groupEnd","add","sortedBoundaries","Array","from","values","sort","a","b","push","arrayToBox","nodeIndex32","array","target","x","y","z","getLongestEdgeIndex","bounds","splitDimIdx","splitDist","Infinity","dist","copyBounds","source","set","unionBounds","aVal","bVal","d","d3","expandByTriangleBounds","startIndex","triangleBounds","tCenter","tHalf","tMin","tMax","computeSurfaceArea","d0","d1","d2","getBounds","centroidTarget","minx","miny","minz","maxx","maxy","maxz","cminx","cminy","cminz","cmaxx","cmaxy","cmaxz","includeCentroid","cx","hx","lx","rx","cy","hy","ly","ry","cz","hz","lz","rz","BIN_COUNT","binsSort","candidate","sahBins","fill","map","Float32Array","rightCacheBounds","leftCacheBounds","leftBounds","MeshBVHNode","constructor","partition","indirectBuffer","split","left","right","pos","axisOffset","axis","t0","tb","partition_indirect","t","buildTree","bvh","geometry","indexArray","maxDepth","verbose","maxLeafTris","strategy","onProgress","totalTriangles","_indirectBuffer","reachedMaxDepth","fullBounds","cacheCentroidBoundingData","posAttr","normalized","posArr","bufferOffset","stride","isInterleavedBufferAttribute","data","getters","tri","tri3","tri6","ai","bi","ci","el","c","halfExtents","el2","abs","computeTriangleBounds","partionFunc","indirect","roots","range","root","boundingData","getCentroidBounds","splitNode","triggerProgress","trianglesProcessed","node","centroidBoundingData","depth","console","warn","concat","nodeBoundingData","avg","getAverage","rootSurfaceArea","bestCost","cStart","cEnd","axisLeft","binWidth","truncatedBins","bin","splitCount","splice","center","leftCount","rightCount","rightBounds","leftProb","rightProb","cost","binIndex","lastBin","nextBin","binCount","getOptimalSplit","splitOffset","splitAxis","lstart","lcount","rstart","rcount","buildPackedTree","useUint32","byteCount","buffer","l","generateIndirectBuffer","finalGroup","total","forEach","_ref","hasGroupGaps","float32Array","uint32Array","uint16Array","packedRoots","countNodes","populateBuffer","_roots","byteOffset","stride4Offset","stride2Offset","isLeaf","nextUnusedPointer","Error","SeparatingAxisBounds","this","setFromPointsField","points","field","val","setFromPoints","p","dot","isSeparated","other","prototype","setFromBox","Vector3","box","boxMin","boxMax","cacheSatBounds","closestPointLineToLine","dir1","dir2","v02","l1","l2","result","v0","v10","v2","v32","subVectors","d0232","d3210","d3232","d0210","denom","closestPointsSegmentToSegment","paramResult","Vector2","temp1","temp2","target1","target2","at","closestPointToPoint","p2","closestPoint","closestPoint2","distanceToSquared","copy","sphereIntersectTriangle","closestPointTemp","projectedPointTemp","planeTemp","Plane","lineTemp","Line3","sphere","triangle","radius","distanceTo","plane","getPlane","distanceToPoint","pp","projectPoint","containsPoint","isNearZero","value","ExtendedTriangle","Triangle","super","isExtendedTriangle","satAxes","satBounds","Sphere","needsUpdate","intersectsSphere","update","axis0","sab0","getNormal","axis1","sab1","axis2","sab2","axis3","sab3","setFromNormalAndCoplanarPoint","closestPointToSegment","point1","point2","edge","segment","distSq","closestDistanceSq","nexti","sqrt","intersectsTriangle","saTri2","arr1","arr2","cachedSatBounds","cachedSatBounds2","cachedAxis","dir","tempDir","edge1","edge2","tempPoint","triIntersectPlane","targetEdge","startPointIntersection","delta","startIntersects","normal","doesIntersect","intersectLine","suppressLog","plane1","plane2","satBounds1","satAxes1","sb","sa","satBounds2","satAxes2","sa1","i2","sa2","crossVectors","count1","count2","tmp","s1","e1","s2","e2","point","distanceToTriangle","cornerFields","line1","line2","lineTarget","getCenter","otherVec","thisVec","f11","f12","f21","f22","OrientedBox","matrix","isOrientedBox","Matrix4","invMatrix","alignedSatBounds","v","applyMatrix4","minVec","pi","invert","intersectsBox","aabbBounds","saTri","pointsArr","triSatBounds","triSatAxes","clamp","distanceToBox","xyzFields","segments1","segments2","threshold","threshold2","i1","nextIndex","nextIndex2","index2","p1","f1","f2","f3","PrimitivePool","getNewPrimitive","_getNewPrimitive","_primitives","getPrimitive","primitives","pop","releasePrimitive","primitive","ExtendedTrianglePoolBase","ExtendedTrianglePool","IS_LEAF","n16","OFFSET","n32","COUNT","LEFT_NODE","RIGHT_NODE","SPLIT_AXIS","BufferStack","stack","prevBuffer","setBuffer","clearBuffer","_box1","_box2","boxStack","boxPool","Box3","shapecast","intersectsBounds","intersectsRange","boundsTraverseOrder","shapecastTraverse","intersectsBoundsFunc","intersectsRangeFunc","nodeScoreFunc","nodeIndexByteOffset","nodeIndex16","score1","score2","box1","box2","c1","c2","temp","c1Intersection","c1StopTraversal","getLeftOffset","getRightEndOffset","c2Intersection","c2StopTraversal","_vA","_vB","_vC","_uvA","_uvB","_uvC","_normalA","_normalB","_normalC","_intersectionPoint","checkBufferGeometryIntersection","ray","uv","uv1","side","fromBufferAttribute","intersection","pA","pB","pC","intersect","BackSide","intersectTriangle","DoubleSide","distance","origin","clone","checkIntersection","getInterpolation","direction","multiplyScalar","face","materialIndex","faceIndex","intersectTri","intersections","triOffset","getX","setTriangle","ta","tc","i0","getY","getZ","iterateOverTriangles","intersectsTriangleFunc","contained","refit","nodeIndices","isArray","indexArr","_traverse","byteLength","node32Index","force","node16Index","offsetLeft","offsetRight","forceChildren","includesLeft","includesRight","has","traverseRight","leftChange","rightChange","didChange","lefti","righti","minLeftValue","maxLeftValue","minRightValue","maxRightValue","_boundingBox","intersectRay","intersectBox","_boxIntersection","raycast","intersects","_raycast","intersectTris","leftIndex","rightIndex","_xyzFields","raycastFirst","_raycastFirst","res","intersectClosestTri","xyzAxis","leftToRight","c1Result","c2Result","boundingBox","triangle2","invertedMat","obb","obb2","intersectsGeometry","otherGeometry","geometryToBvh","_intersectsGeometry","cachedObb","computeBoundingBox","thisGeometry","thisIndex","thisPos","boundsTree","tempMatrix","temp3","temp4","closestPointToGeometry","minThreshold","maxThreshold","otherPos","otherIndex","tempTarget1","tempTargetDest1","tempTarget2","tempTargetDest2","closestDistance","closestDistanceTriIndex","closestDistanceOtherTriIndex","score","otherOffset","otherCount","sub","iterateOverTriangles_indirect","resolveTriangleIndex","refit_indirect","j","raycast_indirect","intersectTris_indirect","raycastFirst_indirect","intersectClosestTri_indirect","intersectsGeometry_indirect","ti","closestPointToGeometry_indirect","otherBvh","ti2","_bufferStack1","_bufferStack2","_boxPool","_leftBox1","_rightBox1","_leftBox2","_rightBox2","_active","node1Index32","node2Index32","matrix2to1","matrix1to2","intersectsRangesFunc","bufferStack1","bufferStack2","node1IndexByteOffset","node2IndexByteOffset","depth1","depth2","currBox","reversed","float32Array1","uint32Array1","uint16Array1","float32Array2","uint32Array2","uint16Array2","node2Index16","isLeaf1","isLeaf2","newBox","cl1","cr1","intersectCl1","intersectCr1","cl2","cr2","leftIntersects","rightIntersects","tempBox","MeshBVH","serialize","cloneBuffers","rootData","indexAttribute","getIndex","slice","deserialize","Boolean","newIndex","isBufferGeometry","Object","assign","setBoundingBox","getBoundingBox","traverse","callback","rootIndex","BYTES_PER_NODE","materialOrSide","FrontSide","isMaterial","isArrayMaterial","raycastFunc","materialSide","startCount","jl","closestResult","raycastFirstFunc","geomToMesh","intersectsGeometryFunc","callbacks","iterateFunc","originalIntersectsRange","nodeIndex","bvhcast","matrixToLocal","intersectsRanges","intersectsTriangles","triangle1","indexAttr1","positionAttr1","assignTriangle1","indexAttr2","positionAttr2","assignTriangle2","iterateOverDoubleTriangles","offset1","offset2","index1","originalIntersectsRanges","otherRoots","invMat","il","localBox","boxToMesh","minThresholdSq","maxThresholdSq","triIndex","makeEmpty","union","HASH_WIDTH","HASH_MULTIPLIER","log10","HASH_ADDITION","hashNumber","hashVertex3","hashVertex4","w","toNormalizedRay","v1","normalize","scalar","addScaledVector","areSharedArrayBuffersSupported","convertToSharedArrayBuffer","cons","sharedBuffer","uintArray","Uint8Array","DEGENERATE_EPSILON","_tempVec","toEdgeIndex","sortEdgeFunc","getProjectedDistance","vec","DIST_EPSILON","ANGLE_EPSILON","RaySet","_rays","addRay","findClosestRay","rays","inv","bestScore","bestRay","r","skipRay","rayScore","scoreRays","invScore","r0","r1","distOutOfThreshold","angleTo","originDistance","angleDistance","_v0","_v1","_ray","Ray","computeDisjointEdges","unmatchedSet","eps","indexAttr","disjointConnectivityMap","Map","fragmentMap","edges","edgeIndex","info","commonRay","forward","reverse","get","e0","o","areDistancesDegenerate","isEdgeDegenerate","cleanUpEdgeSet","arr","e","matchEdges","delete","_vec2","_vec3","_vec4","Vector4","_hashes","HalfEdgeMap","disjointConnections","unmatchedDisjointEdges","unmatchedEdges","matchedEdges","useDrawRange","useAllAttributes","matchDisjointEdges","degenerateEpsilon","updateFrom","getSiblingTriangleIndex","getSiblingEdgeIndex","getDisjointSiblingTriangleIndices","getDisjointSiblingEdgeIndices","isFullyConnected","hashFunction","k","attrKeys","attr","str","itemSize","keys","maxTriCount","Int32Array","i3","nextE","vh0","vh1","reverseHash","hash","clear","_ref2","_ref3","size","Brush","Mesh","isBrush","_previousMatrix","elements","markUpdated","isDirty","el1","prepareGeometry","key","attribute","halfEdges","groupIndices","g","lg","disposeCacheData","EPSILON","_AB","_AC","_CB","isTriDegenerate","angle1","angle2","angle3","PI","COPLANAR_EPSILON","_edge","_foundEdge","_vec","_triangleNormal","_planeNormal","_plane","_splittingTriangle","TrianglePool","_pool","_index","getTriangle","reset","TriangleSplitter","trianglePool","triangles","coplanarTriangleUsed","initialize","poolTri","splitByTriangle","coplanarCount","splitByPlane","clippingTriangle","vertexSplitEnd","coplanarEdge","posSideVerts","negSideVerts","tNext","startDist","endDist","didIntersect","otherVert1","otherVert2","nextTri","singleVert","nextVert1","nextVert2","nextTri1","nextTri2","TypeBackedArray","type","initialSize","expansionFactor","setSize","setType","newArray","BYTES_PER_ELEMENT","expand","TypedAttributeData","groupAttributes","groupCount","getType","name","getItemSize","getNormalized","getCount","getGroupAttrArray","getTotalLength","getGroupAttrSet","refAttrSet","newAttrSet","refAttr","newAttr","initializeArray","referenceAttr","attrSet","IntersectionMap","intersectionSet","ids","id","intersectionId","_matrix","_tri","_vec4a","_vec4b","_vec4c","_vec4_0","_vec4_1","_vec4_2","_normal","JITTER_EPSILON","OFFSET_EPSILON","BACK_SIDE","FRONT_SIDE","COPLANAR_OPPOSITE","COPLANAR_ALIGNED","INVERT_TRI","ADD_TRI","SKIP_TRI","FLOATING_COPLANAR_EPSILON","_debugContext","setDebugContext","debugData","getHitSide","getMidpoint","hit","getHitSideWithCoplanarCheck","rand","random","minDistance","appendAttributeFromTriangle","baryCoordTri","matrixWorld","normalMatrix","attributeData","pushBarycoordInterpolatedValues","applyNormalMatrix","appendAttributesFromIndices","appendAttributeFromIndex","getOperationAction","operation","hitSide","attrArr","addValues","getW","TriangleIntersectData","addTriangle","getIntersectArray","TriangleIntersectionSets","addTriangleIntersection","ia","triA","ib","triB","getTrianglesAsArray","getTriangleIndices","parseInt","getIntersectionIndices","getIntersectionsAsArray","id2","triSet","addTriangles","key2","OperationDebugData","enabled","triangleIntersectsA","triangleIntersectsB","intersectionEdges","addIntersectingTriangles","addEdge","init","complete","_normalMatrix","Matrix3","_triA","_triB","_barycoordTri","_attr","_actions","getFirstIdFromSet","performOperation","operations","splitter","useGroups","aIntersections","bIntersections","multiply","triangleA","triangleB","intersected","pa","pb","na","nb","constant","va","vb","collectIntersectingTriangles","groupOffset","performSplitTriangleOperations","performWholeTriangleOperations","findIndex","op","materials","intersectionMap","invertedGeometry","determinant","getNormalMatrix","aIndex","aPosition","bBVH","bIndex","bPosition","splitIds","groupIndex","ia3","ia0","ia1","ia2","intersectingIndices","ib3","ib0","ib1","ib2","clippedTri","lo","getBarycoord","lk","invertTri","splitTriSet","aAttributes","traverseSet","currId","sid","action","getMaterialList","Evaluator","triangleSplitter","consolidateGroups","debug","getGroupRanges","evaluate","targetBrushes","wasArray","brush","referenceGeometry","targetGeometry","relevantAttributes","aAttr","includes","deleteAttribute","dispose","prepareAttributesData","aGroups","aMaterials","material","bGroups","bMaterials","allMaterials","mat","indexOf","finalMaterials","foundGroup","groupOrder","needsDisposal","referenceAttrSet","requiredLength","geoAttr","setAttribute","trimmedArray","clearGroups","vertCount","addGroup","setDrawRange","assignBufferData","nextGroup","joinGroups","evaluateHierarchy","updateMatrixWorld","flatTraverse","obj","cb","children","child","isOperationGroup","_cachedGeometry","_cachedMaterials","TYPES","subtraction","reverseSubtraction","addition","difference","resolve","currentOp","csgContext","React","Geometry","fref","computeVertexNormals","showOperations","ev","ops","current","boundingSphere","identity","shift","_geo$current","_geo$current$__r3f","_geo$current$__r3f$pa","operator","__r3f","parent","log","api","matrixAutoUpdate","ref","Provider","Base","showOperation","props","extend","_extends","visible","Subtraction"],"sourceRoot":""}