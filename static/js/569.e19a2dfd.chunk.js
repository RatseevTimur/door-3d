"use strict";(self.webpackChunkdoor=self.webpackChunkdoor||[]).push([[569],{4569:(t,e,n)=>{n.d(e,{C6:()=>zr,V2:()=>Ir,ZO:()=>Er});var r=n(8168),o=n(5043),i=n(7551);const s=0,a=1,c=2,l=3,u=4,d=5,f=6;var h=n(9408);const p=0,g=1,y=2,m=2,x=1.25,w=1,b=65535,B=Math.pow(2,-24),A=Symbol("SKIP_GENERATION");function v(t){return function(t){return t.index?t.index.count:t.attributes.position.count}(t)/3}function T(t,e){if(!t.index){const n=t.attributes.position.count,r=function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ArrayBuffer;return t>65535?new Uint32Array(new e(4*t)):new Uint16Array(new e(2*t))}(n,e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer);t.setIndex(new h.BufferAttribute(r,1));for(let t=0;t<n;t++)r[t]=t}}function M(t){const e=v(t),n=t.drawRange,r=n.start/3,o=(n.start+n.count)/3,i=Math.max(0,r),s=Math.min(e,o)-i;return[{offset:Math.floor(i),count:Math.floor(s)}]}function S(t){if(!t.groups||!t.groups.length)return M(t);const e=[],n=new Set,r=t.drawRange,o=r.start/3,i=(r.start+r.count)/3;for(const a of t.groups){const t=a.start/3,e=(a.start+a.count)/3;n.add(Math.max(o,t)),n.add(Math.min(i,e))}const s=Array.from(n.values()).sort(((t,e)=>t-e));for(let a=0;a<s.length-1;a++){const t=s[a],n=s[a+1];e.push({offset:Math.floor(t),count:Math.floor(n-t)})}return e}function V(t,e,n){return n.min.x=e[t],n.min.y=e[t+1],n.min.z=e[t+2],n.max.x=e[t+3],n.max.y=e[t+4],n.max.z=e[t+5],n}function P(t){let e=-1,n=-1/0;for(let r=0;r<3;r++){const o=t[r+3]-t[r];o>n&&(n=o,e=r)}return e}function I(t,e){e.set(t)}function z(t,e,n){let r,o;for(let i=0;i<3;i++){const s=i+3;r=t[i],o=e[i],n[i]=r<o?r:o,r=t[s],o=e[s],n[s]=r>o?r:o}}function E(t,e,n){for(let r=0;r<3;r++){const o=e[t+2*r],i=e[t+2*r+1],s=o-i,a=o+i;s<n[r]&&(n[r]=s),a>n[r+3]&&(n[r+3]=a)}}function U(t){const e=t[3]-t[0],n=t[4]-t[1],r=t[5]-t[2];return 2*(e*n+n*r+r*e)}function _(t,e,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,i=1/0,s=1/0,a=1/0,c=-1/0,l=-1/0,u=-1/0,d=1/0,f=1/0,h=1/0,p=-1/0,g=-1/0,y=-1/0;const m=null!==o;for(let x=6*e,w=6*(e+n);x<w;x+=6){const e=t[x+0],n=t[x+1],r=e-n,o=e+n;r<i&&(i=r),o>c&&(c=o),m&&e<d&&(d=e),m&&e>p&&(p=e);const w=t[x+2],b=t[x+3],B=w-b,A=w+b;B<s&&(s=B),A>l&&(l=A),m&&w<f&&(f=w),m&&w>g&&(g=w);const v=t[x+4],T=t[x+5],M=v-T,S=v+T;M<a&&(a=M),S>u&&(u=S),m&&v<h&&(h=v),m&&v>y&&(y=v)}r[0]=i,r[1]=s,r[2]=a,r[3]=c,r[4]=l,r[5]=u,m&&(o[0]=d,o[1]=f,o[2]=h,o[3]=p,o[4]=g,o[5]=y)}const C=32,F=(t,e)=>t.candidate-e.candidate,G=new Array(C).fill().map((()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0}))),R=new Float32Array(6);class X{constructor(){}}function k(t,e,n,r,o,i){let s=r,a=r+o-1;const c=i.pos,l=2*i.axis;for(;;){for(;s<=a&&n[6*s+l]<c;)s++;for(;s<=a&&n[6*a+l]>=c;)a--;if(!(s<a))return s;for(let t=0;t<3;t++){let n=e[3*s+t];e[3*s+t]=e[3*a+t],e[3*a+t]=n}for(let t=0;t<6;t++){let e=n[6*s+t];n[6*s+t]=n[6*a+t],n[6*a+t]=e}s++,a--}}function D(t,e,n,r,o,i){let s=r,a=r+o-1;const c=i.pos,l=2*i.axis;for(;;){for(;s<=a&&n[6*s+l]<c;)s++;for(;s<=a&&n[6*a+l]>=c;)a--;if(!(s<a))return s;{let e=t[s];t[s]=t[a],t[a]=e;for(let t=0;t<6;t++){let e=n[6*s+t];n[6*s+t]=n[6*a+t],n[6*a+t]=e}s++,a--}}}function N(t,e){const n=t.geometry,r=n.index?n.index.array:null,o=e.maxDepth,i=e.verbose,s=e.maxLeafTris,a=e.strategy,c=e.onProgress,l=v(n),u=t._indirectBuffer;let d=!1;const f=new Float32Array(6),h=new Float32Array(6),m=function(t,e){var n;(n=e)[0]=n[1]=n[2]=1/0,n[3]=n[4]=n[5]=-1/0;const r=t.attributes.position,o=t.index?t.index.array:null,i=v(t),s=new Float32Array(6*i),a=r.normalized,c=r.array,l=r.offset||0;let u=3;r.isInterleavedBufferAttribute&&(u=r.data.stride);const d=["getX","getY","getZ"];for(let f=0;f<i;f++){const t=3*f,n=6*f;let i=t+0,h=t+1,p=t+2;o&&(i=o[i],h=o[h],p=o[p]),a||(i=i*u+l,h=h*u+l,p=p*u+l);for(let o=0;o<3;o++){let t,l,u;a?(t=r[d[o]](i),l=r[d[o]](h),u=r[d[o]](p)):(t=c[i+o],l=c[h+o],u=c[p+o]);let f=t;l<f&&(f=l),u<f&&(f=u);let g=t;l>g&&(g=l),u>g&&(g=u);const y=(g-f)/2,m=2*o;s[n+m+0]=f+y,s[n+m+1]=y+(Math.abs(f)+y)*B,f<e[o]&&(e[o]=f),g>e[o+3]&&(e[o+3]=g)}}return s}(n,f),b=e.indirect?D:k,A=[],T=e.indirect?M(n):S(n);if(1===T.length){const t=T[0],e=new X;e.boundingData=f,function(t,e,n,r){let o=1/0,i=1/0,s=1/0,a=-1/0,c=-1/0,l=-1/0;for(let u=6*e,d=6*(e+n);u<d;u+=6){const e=t[u+0];e<o&&(o=e),e>a&&(a=e);const n=t[u+2];n<i&&(i=n),n>c&&(c=n);const r=t[u+4];r<s&&(s=r),r>l&&(l=r)}r[0]=o,r[1]=i,r[2]=s,r[3]=a,r[4]=c,r[5]=l}(m,t.offset,t.count,h),N(e,t.offset,t.count,h),A.push(e)}else for(let p of T){const t=new X;t.boundingData=new Float32Array(6),_(m,p.offset,p.count,t.boundingData,h),N(t,p.offset,p.count,h),A.push(t)}return A;function V(t){c&&c(t/l)}function N(t,e,c){let l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,f=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;if(!d&&f>=o&&(d=!0,i&&(console.warn("MeshBVH: Max depth of ".concat(o," reached when generating BVH. Consider increasing maxDepth.")),console.warn(n))),c<=s||f>=o)return V(e+c),t.offset=e,t.count=c,t;const B=function(t,e,n,r,o,i){let s=-1,a=0;if(i===p)s=P(e),-1!==s&&(a=(e[s]+e[s+3])/2);else if(i===g)s=P(t),-1!==s&&(a=function(t,e,n,r){let o=0;for(let i=e,s=e+n;i<s;i++)o+=t[6*i+2*r];return o/n}(n,r,o,s));else if(i===y){const i=U(t);let c=x*o;const l=6*r,u=6*(r+o);for(let t=0;t<3;t++){const r=e[t],d=(e[t+3]-r)/C;if(o<C/4){const e=[...G];e.length=o;let r=0;for(let o=l;o<u;o+=6,r++){const i=e[r];i.candidate=n[o+2*t],i.count=0;const{bounds:s,leftCacheBounds:a,rightCacheBounds:c}=i;for(let t=0;t<3;t++)c[t]=1/0,c[t+3]=-1/0,a[t]=1/0,a[t+3]=-1/0,s[t]=1/0,s[t+3]=-1/0;E(o,n,s)}e.sort(F);let d=o;for(let t=0;t<d;t++){const n=e[t];for(;t+1<d&&e[t+1].candidate===n.candidate;)e.splice(t+1,1),d--}for(let o=l;o<u;o+=6){const r=n[o+2*t];for(let t=0;t<d;t++){const i=e[t];r>=i.candidate?E(o,n,i.rightCacheBounds):(E(o,n,i.leftCacheBounds),i.count++)}}for(let n=0;n<d;n++){const r=e[n],l=r.count,u=o-r.count,d=r.leftCacheBounds,f=r.rightCacheBounds;let h=0;0!==l&&(h=U(d)/i);let p=0;0!==u&&(p=U(f)/i);const g=w+x*(h*l+p*u);g<c&&(s=t,c=g,a=r.candidate)}}else{for(let t=0;t<C;t++){const e=G[t];e.count=0,e.candidate=r+d+t*d;const n=e.bounds;for(let t=0;t<3;t++)n[t]=1/0,n[t+3]=-1/0}for(let o=l;o<u;o+=6){let e=~~((n[o+2*t]-r)/d);e>=C&&(e=C-1);const i=G[e];i.count++,E(o,n,i.bounds)}const e=G[C-1];I(e.bounds,e.rightCacheBounds);for(let t=C-2;t>=0;t--){const e=G[t],n=G[t+1];z(e.bounds,n.rightCacheBounds,e.rightCacheBounds)}let f=0;for(let n=0;n<C-1;n++){const e=G[n],r=e.count,l=e.bounds,u=G[n+1].rightCacheBounds;0!==r&&(0===f?I(l,R):z(l,R,R)),f+=r;let d=0,h=0;0!==f&&(d=U(R)/i);const p=o-f;0!==p&&(h=U(u)/i);const g=w+x*(d*f+h*p);g<c&&(s=t,c=g,a=e.candidate)}}}}else console.warn("MeshBVH: Invalid build strategy value ".concat(i," used."));return{axis:s,pos:a}}(t.boundingData,l,m,e,c,a);if(-1===B.axis)return V(e+c),t.offset=e,t.count=c,t;const A=b(u,r,m,e,c,B);if(A===e||A===e+c)V(e+c),t.offset=e,t.count=c;else{t.splitAxis=B.axis;const n=new X,r=e,o=A-e;t.left=n,n.boundingData=new Float32Array(6),_(m,r,o,n.boundingData,h),N(n,r,o,h,f+1);const i=new X,s=A,a=c-o;t.right=i,i.boundingData=new Float32Array(6),_(m,s,a,i.boundingData,h),N(i,s,a,h,f+1)}return t}}function q(t,e){const n=t.geometry;e.indirect&&(t._indirectBuffer=function(t,e){const n=(t.index?t.index.count:t.attributes.position.count)/3,r=n>65536,o=r?4:2,i=e?new SharedArrayBuffer(n*o):new ArrayBuffer(n*o),s=r?new Uint32Array(i):new Uint16Array(i);for(let a=0,c=s.length;a<c;a++)s[a]=a;return s}(n,e.useSharedArrayBuffer),function(t){if(0===t.groups.length)return!1;const e=v(t),n=S(t).sort(((t,e)=>t.offset-e.offset)),r=n[n.length-1];r.count=Math.min(e-r.offset,r.count);let o=0;return n.forEach((t=>{let{count:e}=t;return o+=e})),e!==o}(n)&&!e.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),t._indirectBuffer||T(n,e);const r=N(t,e);let o,i,s;const a=[],c=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let d=0;d<r.length;d++){const t=r[d];const e=new c(32*l(t));o=new Float32Array(e),i=new Uint32Array(e),s=new Uint16Array(e),u(0,t),a.push(e)}return void(t._roots=a);function l(t){return t.count?1:1+l(t.left)+l(t.right)}function u(t,e){const n=t/4,r=t/2,a=!!e.count,c=e.boundingData;for(let i=0;i<6;i++)o[n+i]=c[i];if(a){const o=e.offset,a=e.count;return i[n+6]=o,s[r+14]=a,s[r+15]=b,t+32}{const r=e.left,o=e.right,s=e.splitAxis;let a;if(a=u(t+32,r),a/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return i[n+6]=a/4,a=u(a,o),i[n+7]=s,a}}}class L{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,r=-1/0;for(let o=0,i=t.length;o<i;o++){const i=t[o][e];n=i<n?i:n,r=i>r?i:r}this.min=n,this.max=r}setFromPoints(t,e){let n=1/0,r=-1/0;for(let o=0,i=e.length;o<i;o++){const i=e[o],s=t.dot(i);n=s<n?s:n,r=s>r?s:r}this.min=n,this.max=r}isSeparated(t){return this.min>t.max||t.min>this.max}}L.prototype.setFromBox=function(){const t=new h.Vector3;return function(e,n){const r=n.min,o=n.max;let i=1/0,s=-1/0;for(let a=0;a<=1;a++)for(let n=0;n<=1;n++)for(let c=0;c<=1;c++){t.x=r.x*a+o.x*(1-a),t.y=r.y*n+o.y*(1-n),t.z=r.z*c+o.z*(1-c);const l=e.dot(t);i=Math.min(l,i),s=Math.max(l,s)}this.min=i,this.max=s}}();!function(){const t=new L}();const O=function(){const t=new h.Vector3,e=new h.Vector3,n=new h.Vector3;return function(r,o,i){const s=r.start,a=t,c=o.start,l=e;n.subVectors(s,c),t.subVectors(r.end,r.start),e.subVectors(o.end,o.start);const u=n.dot(l),d=l.dot(a),f=l.dot(l),h=n.dot(a),p=a.dot(a)*f-d*d;let g,y;g=0!==p?(u*d-h*f)/p:0,y=(u+g*d)/f,i.x=g,i.y=y}}(),j=function(){const t=new h.Vector2,e=new h.Vector3,n=new h.Vector3;return function(r,o,i,s){O(r,o,t);let a=t.x,c=t.y;if(a>=0&&a<=1&&c>=0&&c<=1)return r.at(a,i),void o.at(c,s);if(a>=0&&a<=1)return c<0?o.at(0,s):o.at(1,s),void r.closestPointToPoint(s,!0,i);if(c>=0&&c<=1)return a<0?r.at(0,i):r.at(1,i),void o.closestPointToPoint(i,!0,s);{let t,l;t=a<0?r.start:r.end,l=c<0?o.start:o.end;const u=e,d=n;return r.closestPointToPoint(l,!0,e),o.closestPointToPoint(t,!0,n),u.distanceToSquared(l)<=d.distanceToSquared(t)?(i.copy(u),void s.copy(l)):(i.copy(t),void s.copy(d))}}}(),W=function(){const t=new h.Vector3,e=new h.Vector3,n=new h.Plane,r=new h.Line3;return function(o,i){const{radius:s,center:a}=o,{a:c,b:l,c:u}=i;r.start=c,r.end=l;if(r.closestPointToPoint(a,!0,t).distanceTo(a)<=s)return!0;r.start=c,r.end=u;if(r.closestPointToPoint(a,!0,t).distanceTo(a)<=s)return!0;r.start=l,r.end=u;if(r.closestPointToPoint(a,!0,t).distanceTo(a)<=s)return!0;const d=i.getPlane(n);if(Math.abs(d.distanceToPoint(a))<=s){const t=d.projectPoint(a,e);if(i.containsPoint(t))return!0}return!1}}();function H(t){return Math.abs(t)<1e-15}class Y extends h.Triangle{constructor(){super(...arguments),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map((()=>new h.Vector3)),this.satBounds=new Array(4).fill().map((()=>new L)),this.points=[this.a,this.b,this.c],this.sphere=new h.Sphere,this.plane=new h.Plane,this.needsUpdate=!0}intersectsSphere(t){return W(t,this)}update(){const t=this.a,e=this.b,n=this.c,r=this.points,o=this.satAxes,i=this.satBounds,s=o[0],a=i[0];this.getNormal(s),a.setFromPoints(s,r);const c=o[1],l=i[1];c.subVectors(t,e),l.setFromPoints(c,r);const u=o[2],d=i[2];u.subVectors(e,n),d.setFromPoints(u,r);const f=o[3],h=i[3];f.subVectors(n,t),h.setFromPoints(f,r),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(s,t),this.needsUpdate=!1}}Y.prototype.closestPointToSegment=function(){const t=new h.Vector3,e=new h.Vector3,n=new h.Line3;return function(r){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;const{start:s,end:a}=r,c=this.points;let l,u=1/0;for(let d=0;d<3;d++){const s=(d+1)%3;n.start.copy(c[d]),n.end.copy(c[s]),j(n,r,t,e),l=t.distanceToSquared(e),l<u&&(u=l,o&&o.copy(t),i&&i.copy(e))}return this.closestPointToPoint(s,t),l=s.distanceToSquared(t),l<u&&(u=l,o&&o.copy(t),i&&i.copy(s)),this.closestPointToPoint(a,t),l=a.distanceToSquared(t),l<u&&(u=l,o&&o.copy(t),i&&i.copy(a)),Math.sqrt(u)}}(),Y.prototype.intersectsTriangle=function(){const t=new Y,e=new Array(3),n=new Array(3),r=new L,o=new L,i=new h.Vector3,s=new h.Vector3,a=new h.Vector3,c=new h.Vector3,l=new h.Vector3,u=new h.Line3,d=new h.Line3,f=new h.Line3,p=new h.Vector3;function g(t,e,n){const r=t.points;let o=0,i=-1;for(let a=0;a<3;a++){const{start:t,end:c}=u;t.copy(r[a]),c.copy(r[(a+1)%3]),u.delta(s);const l=H(e.distanceToPoint(t));if(H(e.normal.dot(s))&&l){n.copy(u),o=2;break}const d=e.intersectLine(u,p);if(!d&&l&&p.copy(t),(d||l)&&!H(p.distanceTo(c))){if(o<=1){(1===o?n.start:n.end).copy(p),l&&(i=o)}else if(o>=2){(1===i?n.start:n.end).copy(p),o=2;break}if(o++,2===o&&-1===i)break}}return o}return function(s){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,h=arguments.length>2&&void 0!==arguments[2]&&arguments[2];this.needsUpdate&&this.update(),s.isExtendedTriangle?s.needsUpdate&&s.update():(t.copy(s),t.update(),s=t);const p=this.plane,y=s.plane;if(Math.abs(p.normal.dot(y.normal))>1-1e-10){const t=this.satBounds,a=this.satAxes;n[0]=s.a,n[1]=s.b,n[2]=s.c;for(let e=0;e<4;e++){const o=t[e],i=a[e];if(r.setFromPoints(i,n),o.isSeparated(r))return!1}const c=s.satBounds,l=s.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let n=0;n<4;n++){const t=c[n],o=l[n];if(r.setFromPoints(o,e),t.isSeparated(r))return!1}for(let s=0;s<4;s++){const t=a[s];for(let s=0;s<4;s++){const a=l[s];if(i.crossVectors(t,a),r.setFromPoints(i,e),o.setFromPoints(i,n),r.isSeparated(o))return!1}}return u&&(h||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),u.start.set(0,0,0),u.end.set(0,0,0)),!0}{const t=g(this,y,d);if(1===t&&s.containsPoint(d.end))return u&&(u.start.copy(d.end),u.end.copy(d.end)),!0;if(2!==t)return!1;const e=g(s,p,f);if(1===e&&this.containsPoint(f.end))return u&&(u.start.copy(f.end),u.end.copy(f.end)),!0;if(2!==e)return!1;if(d.delta(a),f.delta(c),a.dot(c)<0){let t=f.start;f.start=f.end,f.end=t}const n=d.start.dot(a),r=d.end.dot(a),o=f.start.dot(a),i=f.end.dot(a);return(n===i||o===r||r<o!==n<i)&&(u&&(l.subVectors(d.start,f.start),l.dot(a)>0?u.start.copy(d.start):u.start.copy(f.start),l.subVectors(d.end,f.end),l.dot(a)<0?u.end.copy(d.end):u.end.copy(f.end)),!0)}}}(),Y.prototype.distanceToPoint=function(){const t=new h.Vector3;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),Y.prototype.distanceToTriangle=function(){const t=new h.Vector3,e=new h.Vector3,n=["a","b","c"],r=new h.Line3,o=new h.Line3;return function(i){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;const c=s||a?r:null;if(this.intersectsTriangle(i,c))return(s||a)&&(s&&c.getCenter(s),a&&c.getCenter(a)),0;let l=1/0;for(let e=0;e<3;e++){let r;const o=n[e],c=i[o];this.closestPointToPoint(c,t),r=c.distanceToSquared(t),r<l&&(l=r,s&&s.copy(t),a&&a.copy(c));const u=this[o];i.closestPointToPoint(u,t),r=u.distanceToSquared(t),r<l&&(l=r,s&&s.copy(u),a&&a.copy(t))}for(let u=0;u<3;u++){const c=n[u],d=n[(u+1)%3];r.set(this[c],this[d]);for(let u=0;u<3;u++){const c=n[u],d=n[(u+1)%3];o.set(i[c],i[d]),j(r,o,t,e);const f=t.distanceToSquared(e);f<l&&(l=f,s&&s.copy(t),a&&a.copy(e))}}return Math.sqrt(l)}}();class Z{constructor(t,e,n){this.isOrientedBox=!0,this.min=new h.Vector3,this.max=new h.Vector3,this.matrix=new h.Matrix4,this.invMatrix=new h.Matrix4,this.points=new Array(8).fill().map((()=>new h.Vector3)),this.satAxes=new Array(3).fill().map((()=>new h.Vector3)),this.satBounds=new Array(3).fill().map((()=>new L)),this.alignedSatBounds=new Array(3).fill().map((()=>new L)),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),n&&this.matrix.copy(n)}set(t,e,n){this.min.copy(t),this.max.copy(e),this.matrix.copy(n),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}Z.prototype.update=function(){const t=this.matrix,e=this.min,n=this.max,r=this.points;for(let c=0;c<=1;c++)for(let o=0;o<=1;o++)for(let i=0;i<=1;i++){const s=r[1*c|2*o|4*i];s.x=c?n.x:e.x,s.y=o?n.y:e.y,s.z=i?n.z:e.z,s.applyMatrix4(t)}const o=this.satBounds,i=this.satAxes,s=r[0];for(let c=0;c<3;c++){const t=i[c],e=o[c],n=r[1<<c];t.subVectors(s,n),e.setFromPoints(t,r)}const a=this.alignedSatBounds;a[0].setFromPointsField(r,"x"),a[1].setFromPointsField(r,"y"),a[2].setFromPointsField(r,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1},Z.prototype.intersectsBox=function(){const t=new L;return function(e){this.needsUpdate&&this.update();const n=e.min,r=e.max,o=this.satBounds,i=this.satAxes,s=this.alignedSatBounds;if(t.min=n.x,t.max=r.x,s[0].isSeparated(t))return!1;if(t.min=n.y,t.max=r.y,s[1].isSeparated(t))return!1;if(t.min=n.z,t.max=r.z,s[2].isSeparated(t))return!1;for(let a=0;a<3;a++){const n=i[a],r=o[a];if(t.setFromBox(n,e),r.isSeparated(t))return!1}return!0}}(),Z.prototype.intersectsTriangle=function(){const t=new Y,e=new Array(3),n=new L,r=new L,o=new h.Vector3;return function(i){this.needsUpdate&&this.update(),i.isExtendedTriangle?i.needsUpdate&&i.update():(t.copy(i),t.update(),i=t);const s=this.satBounds,a=this.satAxes;e[0]=i.a,e[1]=i.b,e[2]=i.c;for(let t=0;t<3;t++){const r=s[t],o=a[t];if(n.setFromPoints(o,e),r.isSeparated(n))return!1}const c=i.satBounds,l=i.satAxes,u=this.points;for(let t=0;t<3;t++){const e=c[t],r=l[t];if(n.setFromPoints(r,u),e.isSeparated(n))return!1}for(let t=0;t<3;t++){const i=a[t];for(let t=0;t<4;t++){const s=l[t];if(o.crossVectors(i,s),n.setFromPoints(o,e),r.setFromPoints(o,u),n.isSeparated(r))return!1}}return!0}}(),Z.prototype.closestPointToPoint=function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e},Z.prototype.distanceToPoint=function(){const t=new h.Vector3;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),Z.prototype.distanceToBox=function(){const t=["x","y","z"],e=new Array(12).fill().map((()=>new h.Line3)),n=new Array(12).fill().map((()=>new h.Line3)),r=new h.Vector3,o=new h.Vector3;return function(i){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;if(this.needsUpdate&&this.update(),this.intersectsBox(i))return(a||c)&&(i.getCenter(o),this.closestPointToPoint(o,r),i.closestPointToPoint(r,o),a&&a.copy(r),c&&c.copy(o)),0;const l=s*s,u=i.min,d=i.max,f=this.points;let h=1/0;for(let t=0;t<8;t++){const e=f[t];o.copy(e).clamp(u,d);const n=e.distanceToSquared(o);if(n<h&&(h=n,a&&a.copy(e),c&&c.copy(o),n<l))return Math.sqrt(n)}let p=0;for(let r=0;r<3;r++)for(let o=0;o<=1;o++)for(let i=0;i<=1;i++){const s=(r+1)%3,a=(r+2)%3,c=1<<r|o<<s|i<<a,l=f[o<<s|i<<a],h=f[c];e[p].set(l,h);const g=t[r],y=t[s],m=t[a],x=n[p],w=x.start,b=x.end;w[g]=u[g],w[y]=o?u[y]:d[y],w[m]=i?u[m]:d[y],b[g]=d[g],b[y]=o?u[y]:d[y],b[m]=i?u[m]:d[y],p++}for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)for(let n=0;n<=1;n++){o.x=t?d.x:u.x,o.y=e?d.y:u.y,o.z=n?d.z:u.z,this.closestPointToPoint(o,r);const i=o.distanceToSquared(r);if(i<h&&(h=i,a&&a.copy(r),c&&c.copy(o),i<l))return Math.sqrt(i)}for(let t=0;t<12;t++){const i=e[t];for(let t=0;t<12;t++){const e=n[t];j(i,e,r,o);const s=r.distanceToSquared(o);if(s<h&&(h=s,a&&a.copy(r),c&&c.copy(o),s<l))return Math.sqrt(s)}}return Math.sqrt(h)}}();class K{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return 0===t.length?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class J extends K{constructor(){super((()=>new Y))}}const Q=new J;function $(t,e){return 65535===e[t+15]}function tt(t,e){return e[t+6]}function et(t,e){return e[t+14]}function nt(t){return t+8}function rt(t,e){return e[t+6]}function ot(t,e){return e[t+7]}const it=new class{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=n=>{e&&t.push(e),e=n,this.float32Array=new Float32Array(n),this.uint16Array=new Uint16Array(n),this.uint32Array=new Uint32Array(n)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,0!==t.length&&this.setBuffer(t.pop())}}};let st,at;const ct=[],lt=new K((()=>new h.Box3));function ut(t,e,n,r,o,i){st=lt.getPrimitive(),at=lt.getPrimitive(),ct.push(st,at),it.setBuffer(t._roots[e]);const s=dt(0,t.geometry,n,r,o,i);it.clearBuffer(),lt.releasePrimitive(st),lt.releasePrimitive(at),ct.pop(),ct.pop();const a=ct.length;return a>0&&(at=ct[a-1],st=ct[a-2]),s}function dt(t,e,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const{float32Array:a,uint16Array:c,uint32Array:l}=it;let u=2*t;if($(u,c)){const d=tt(t,l),f=et(u,c);return V(t,a,st),r(d,f,!1,s,i+t,st)}{const h=nt(t),p=rt(t,l);let g,y,x,w,b=h,B=p;if(o&&(x=st,w=at,V(b,a,x),V(B,a,w),g=o(x),y=o(w),y<g)){b=p,B=h;const I=g;g=y,y=I,x=w}x||(x=st,V(b,a,x));const A=n(x,$(2*b,c),g,s+1,i+b);let v;if(A===m){const z=S(b);v=r(z,P(b)-z,!0,s+1,i+b,x)}else v=A&&dt(b,e,n,r,o,i,s+1);if(v)return!0;w=at,V(B,a,w);const T=n(w,$(2*B,c),y,s+1,i+B);let M;if(T===m){const E=S(B);M=r(E,P(B)-E,!0,s+1,i+B,w)}else M=T&&dt(B,e,n,r,o,i,s+1);return!!M;function S(t){const{uint16Array:e,uint32Array:n}=it;let r=2*t;for(;!$(r,e);)r=2*(t=nt(t));return tt(t,n)}function P(t){const{uint16Array:e,uint32Array:n}=it;let r=2*t;for(;!$(r,e);)r=2*(t=rt(t,n));return tt(t,n)+et(r,e)}}}const ft=new h.Vector3,ht=new h.Vector3;const pt=new h.Vector3,gt=new h.Vector3,yt=new h.Vector3,mt=new h.Vector2,xt=new h.Vector2,wt=new h.Vector2,bt=new h.Vector3,Bt=new h.Vector3,At=new h.Vector3,vt=new h.Vector3;function Tt(t,e,n,r,o,i,s,a,c){pt.fromBufferAttribute(e,i),gt.fromBufferAttribute(e,s),yt.fromBufferAttribute(e,a);const l=function(t,e,n,r,o,i){let s;return s=i===h.BackSide?t.intersectTriangle(r,n,e,!0,o):t.intersectTriangle(e,n,r,i!==h.DoubleSide,o),null===s?null:{distance:t.origin.distanceTo(o),point:o.clone()}}(t,pt,gt,yt,vt,c);if(l){r&&(mt.fromBufferAttribute(r,i),xt.fromBufferAttribute(r,s),wt.fromBufferAttribute(r,a),l.uv=h.Triangle.getInterpolation(vt,pt,gt,yt,mt,xt,wt,new h.Vector2)),o&&(mt.fromBufferAttribute(o,i),xt.fromBufferAttribute(o,s),wt.fromBufferAttribute(o,a),l.uv1=h.Triangle.getInterpolation(vt,pt,gt,yt,mt,xt,wt,new h.Vector2)),n&&(bt.fromBufferAttribute(n,i),Bt.fromBufferAttribute(n,s),At.fromBufferAttribute(n,a),l.normal=h.Triangle.getInterpolation(vt,pt,gt,yt,bt,Bt,At,new h.Vector3),l.normal.dot(t.direction)>0&&l.normal.multiplyScalar(-1));const e={a:i,b:s,c:a,normal:new h.Vector3,materialIndex:0};h.Triangle.getNormal(pt,gt,yt,e.normal),l.face=e,l.faceIndex=i}return l}function Mt(t,e,n,r,o){const i=3*r;let s=i+0,a=i+1,c=i+2;const l=t.index;t.index&&(s=l.getX(s),a=l.getX(a),c=l.getX(c));const{position:u,normal:d,uv:f,uv1:h}=t.attributes,p=Tt(n,u,d,f,h,s,a,c,e);return p?(p.faceIndex=r,o&&o.push(p),p):null}function St(t,e,n,r){const o=t.a,i=t.b,s=t.c;let a=e,c=e+1,l=e+2;n&&(a=n.getX(a),c=n.getX(c),l=n.getX(l)),o.x=r.getX(a),o.y=r.getY(a),o.z=r.getZ(a),i.x=r.getX(c),i.y=r.getY(c),i.z=r.getZ(c),s.x=r.getX(l),s.y=r.getY(l),s.z=r.getZ(l)}function Vt(t,e,n,r,o,i,s){const{geometry:a}=n,{index:c}=a,l=a.attributes.position;for(let u=t,d=e+t;u<d;u++){let t;if(t=u,St(s,3*t,c,l),s.needsUpdate=!0,r(s,t,o,i))return!0}return!1}function Pt(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;e&&Array.isArray(e)&&(e=new Set(e));const n=t.geometry,r=n.index?n.index.array:null,o=n.attributes.position;let i,s,a,c,l=0;const u=t._roots;for(let f=0,h=u.length;f<h;f++)i=u[f],s=new Uint32Array(i),a=new Uint16Array(i),c=new Float32Array(i),d(0,l),l+=i.byteLength;function d(t,n){let i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const l=2*t;if(a[l+15]===b){const e=s[t+6];let n=1/0,i=1/0,u=1/0,d=-1/0,f=-1/0,h=-1/0;for(let t=3*e,s=3*(e+a[l+14]);t<s;t++){let e=r[t];const s=o.getX(e),a=o.getY(e),c=o.getZ(e);s<n&&(n=s),s>d&&(d=s),a<i&&(i=a),a>f&&(f=a),c<u&&(u=c),c>h&&(h=c)}return(c[t+0]!==n||c[t+1]!==i||c[t+2]!==u||c[t+3]!==d||c[t+4]!==f||c[t+5]!==h)&&(c[t+0]=n,c[t+1]=i,c[t+2]=u,c[t+3]=d,c[t+4]=f,c[t+5]=h,!0)}{const r=t+8,o=s[t+6],a=r+n,l=o+n;let u=i,f=!1,h=!1;e?u||(f=e.has(a),h=e.has(l),u=!f&&!h):(f=!0,h=!0);const p=u||h;let g=!1;(u||f)&&(g=d(r,n,u));let y=!1;p&&(y=d(o,n,u));const m=g||y;if(m)for(let e=0;e<3;e++){const n=r+e,i=o+e,s=c[n],a=c[n+3],l=c[i],u=c[i+3];c[t+e]=s<l?s:l,c[t+e+3]=a>u?a:u}return m}}}const It=new h.Box3;function zt(t,e,n,r){return V(t,e,It),n.intersectBox(It,r)}const Et=new h.Vector3;function Ut(t,e,n,r,o){it.setBuffer(t._roots[e]),_t(0,t,n,r,o),it.clearBuffer()}function _t(t,e,n,r,o){const{float32Array:i,uint16Array:s,uint32Array:a}=it,c=2*t;if($(c,s)){!function(t,e,n,r,o,i){const{geometry:s,_indirectBuffer:a}=t;for(let c=r,l=r+o;c<l;c++)Mt(s,e,n,c,i)}(e,n,r,tt(t,a),et(c,s),o)}else{const s=nt(t);zt(s,i,r,Et)&&_t(s,e,n,r,o);const c=rt(t,a);zt(c,i,r,Et)&&_t(c,e,n,r,o)}}const Ct=new h.Vector3,Ft=["x","y","z"];function Gt(t,e,n,r){it.setBuffer(t._roots[e]);const o=Rt(0,t,n,r);return it.clearBuffer(),o}function Rt(t,e,n,r){const{float32Array:o,uint16Array:i,uint32Array:s}=it;let a=2*t;if($(a,i)){return function(t,e,n,r,o){const{geometry:i,_indirectBuffer:s}=t;let a=1/0,c=null;for(let l=r,u=r+o;l<u;l++){let t;t=Mt(i,e,n,l),t&&t.distance<a&&(c=t,a=t.distance)}return c}(e,n,r,tt(t,s),et(a,i))}{const i=ot(t,s),a=Ft[i],c=r.direction[a]>=0;let l,u;c?(l=nt(t),u=rt(t,s)):(l=rt(t,s),u=nt(t));const d=zt(l,o,r,Ct)?Rt(l,e,n,r):null;if(d){const t=d.point[a];if(c?t<=o[u+i]:t>=o[u+i+3])return d}const f=zt(u,o,r,Ct)?Rt(u,e,n,r):null;return d&&f?d.distance<=f.distance?d:f:d||f||null}}const Xt=new h.Box3,kt=new Y,Dt=new Y,Nt=new h.Matrix4,qt=new Z,Lt=new Z;function Ot(t,e,n,r){it.setBuffer(t._roots[e]);const o=jt(0,t,n,r);return it.clearBuffer(),o}function jt(t,e,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const{float32Array:i,uint16Array:s,uint32Array:a}=it;let c=2*t;null===o&&(n.boundingBox||n.computeBoundingBox(),qt.set(n.boundingBox.min,n.boundingBox.max,r),o=qt);if(!$(c,s)){const s=t+8,c=a[t+6];V(s,i,Xt);if(o.intersectsBox(Xt)&&jt(s,e,n,r,o))return!0;V(c,i,Xt);return!!(o.intersectsBox(Xt)&&jt(c,e,n,r,o))}{const o=e.geometry,l=o.index,u=o.attributes.position,d=n.index,f=n.attributes.position,h=tt(t,a),p=et(c,s);if(Nt.copy(r).invert(),n.boundsTree){V(t,i,Lt),Lt.matrix.copy(Nt),Lt.needsUpdate=!0;return n.boundsTree.shapecast({intersectsBounds:t=>Lt.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(r),t.b.applyMatrix4(r),t.c.applyMatrix4(r),t.needsUpdate=!0;for(let e=3*h,n=3*(p+h);e<n;e+=3)if(St(Dt,e,l,u),Dt.needsUpdate=!0,t.intersectsTriangle(Dt))return!0;return!1}})}for(let t=3*h,e=3*(p+h);t<e;t+=3){St(kt,t,l,u),kt.a.applyMatrix4(Nt),kt.b.applyMatrix4(Nt),kt.c.applyMatrix4(Nt),kt.needsUpdate=!0;for(let t=0,e=d.count;t<e;t+=3)if(St(Dt,t,d,f),Dt.needsUpdate=!0,kt.intersectsTriangle(Dt))return!0}}}const Wt=new h.Matrix4,Ht=new Z,Yt=new Z,Zt=new h.Vector3,Kt=new h.Vector3,Jt=new h.Vector3,Qt=new h.Vector3;function $t(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{},i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1/0;e.boundingBox||e.computeBoundingBox(),Ht.set(e.boundingBox.min,e.boundingBox.max,n),Ht.needsUpdate=!0;const a=t.geometry,c=a.attributes.position,l=a.index,u=e.attributes.position,d=e.index,f=Q.getPrimitive(),h=Q.getPrimitive();let p=Zt,g=Kt,y=null,m=null;o&&(y=Jt,m=Qt);let x=1/0,w=null,b=null;return Wt.copy(n).invert(),Yt.matrix.copy(Wt),t.shapecast({boundsTraverseOrder:t=>Ht.distanceToBox(t),intersectsBounds:(t,e,n)=>n<x&&n<s&&(e&&(Yt.min.copy(t.min),Yt.max.copy(t.max),Yt.needsUpdate=!0),!0),intersectsRange:(t,r)=>{if(e.boundsTree){return e.boundsTree.shapecast({boundsTraverseOrder:t=>Yt.distanceToBox(t),intersectsBounds:(t,e,n)=>n<x&&n<s,intersectsRange:(e,o)=>{for(let s=e,a=e+o;s<a;s++){St(h,3*s,d,u),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let e=t,n=t+r;e<n;e++){St(f,3*e,l,c),f.needsUpdate=!0;const t=f.distanceToTriangle(h,p,y);if(t<x&&(g.copy(p),m&&m.copy(y),x=t,w=e,b=s),t<i)return!0}}}})}for(let o=0,s=v(e);o<s;o++){St(h,3*o,d,u),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let e=t,n=t+r;e<n;e++){St(f,3*e,l,c),f.needsUpdate=!0;const t=f.distanceToTriangle(h,p,y);if(t<x&&(g.copy(p),m&&m.copy(y),x=t,w=e,b=o),t<i)return!0}}}}),Q.releasePrimitive(f),Q.releasePrimitive(h),x===1/0?null:(r.point?r.point.copy(g):r.point=g.clone(),r.distance=x,r.faceIndex=w,o&&(o.point?o.point.copy(m):o.point=m.clone(),o.point.applyMatrix4(Wt),g.applyMatrix4(Wt),o.distance=g.sub(o.point).length(),o.faceIndex=b),r)}function te(t,e,n,r,o,i,s){const{geometry:a}=n,{index:c}=a,l=a.attributes.position;for(let u=t,d=e+t;u<d;u++){let t;if(t=n.resolveTriangleIndex(u),St(s,3*t,c,l),s.needsUpdate=!0,r(s,t,o,i))return!0}return!1}function ee(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;e&&Array.isArray(e)&&(e=new Set(e));const n=t.geometry,r=n.index?n.index.array:null,o=n.attributes.position;let i,s,a,c,l=0;const u=t._roots;for(let f=0,h=u.length;f<h;f++)i=u[f],s=new Uint32Array(i),a=new Uint16Array(i),c=new Float32Array(i),d(0,l),l+=i.byteLength;function d(n,i){let l=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const u=2*n;if(a[u+15]===b){const e=s[n+6];let i=1/0,l=1/0,d=1/0,f=-1/0,h=-1/0,p=-1/0;for(let n=e,s=e+a[u+14];n<s;n++){const e=3*t.resolveTriangleIndex(n);for(let t=0;t<3;t++){let n=e+t;n=r?r[n]:n;const s=o.getX(n),a=o.getY(n),c=o.getZ(n);s<i&&(i=s),s>f&&(f=s),a<l&&(l=a),a>h&&(h=a),c<d&&(d=c),c>p&&(p=c)}}return(c[n+0]!==i||c[n+1]!==l||c[n+2]!==d||c[n+3]!==f||c[n+4]!==h||c[n+5]!==p)&&(c[n+0]=i,c[n+1]=l,c[n+2]=d,c[n+3]=f,c[n+4]=h,c[n+5]=p,!0)}{const t=n+8,r=s[n+6],o=t+i,a=r+i;let u=l,f=!1,h=!1;e?u||(f=e.has(o),h=e.has(a),u=!f&&!h):(f=!0,h=!0);const p=u||h;let g=!1;(u||f)&&(g=d(t,i,u));let y=!1;p&&(y=d(r,i,u));const m=g||y;if(m)for(let e=0;e<3;e++){const o=t+e,i=r+e,s=c[o],a=c[o+3],l=c[i],u=c[i+3];c[n+e]=s<l?s:l,c[n+e+3]=a>u?a:u}return m}}}const ne=new h.Vector3;function re(t,e,n,r,o){it.setBuffer(t._roots[e]),oe(0,t,n,r,o),it.clearBuffer()}function oe(t,e,n,r,o){const{float32Array:i,uint16Array:s,uint32Array:a}=it,c=2*t;if($(c,s)){!function(t,e,n,r,o,i){const{geometry:s,_indirectBuffer:a}=t;for(let c=r,l=r+o;c<l;c++)Mt(s,e,n,a?a[c]:c,i)}(e,n,r,tt(t,a),et(c,s),o)}else{const s=nt(t);zt(s,i,r,ne)&&oe(s,e,n,r,o);const c=rt(t,a);zt(c,i,r,ne)&&oe(c,e,n,r,o)}}const ie=new h.Vector3,se=["x","y","z"];function ae(t,e,n,r){it.setBuffer(t._roots[e]);const o=ce(0,t,n,r);return it.clearBuffer(),o}function ce(t,e,n,r){const{float32Array:o,uint16Array:i,uint32Array:s}=it;let a=2*t;if($(a,i)){return function(t,e,n,r,o){const{geometry:i,_indirectBuffer:s}=t;let a=1/0,c=null;for(let l=r,u=r+o;l<u;l++){let t;t=Mt(i,e,n,s?s[l]:l),t&&t.distance<a&&(c=t,a=t.distance)}return c}(e,n,r,tt(t,s),et(a,i))}{const i=ot(t,s),a=se[i],c=r.direction[a]>=0;let l,u;c?(l=nt(t),u=rt(t,s)):(l=rt(t,s),u=nt(t));const d=zt(l,o,r,ie)?ce(l,e,n,r):null;if(d){const t=d.point[a];if(c?t<=o[u+i]:t>=o[u+i+3])return d}const f=zt(u,o,r,ie)?ce(u,e,n,r):null;return d&&f?d.distance<=f.distance?d:f:d||f||null}}const le=new h.Box3,ue=new Y,de=new Y,fe=new h.Matrix4,he=new Z,pe=new Z;function ge(t,e,n,r){it.setBuffer(t._roots[e]);const o=ye(0,t,n,r);return it.clearBuffer(),o}function ye(t,e,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const{float32Array:i,uint16Array:s,uint32Array:a}=it;let c=2*t;null===o&&(n.boundingBox||n.computeBoundingBox(),he.set(n.boundingBox.min,n.boundingBox.max,r),o=he);if(!$(c,s)){const s=t+8,c=a[t+6];V(s,i,le);if(o.intersectsBox(le)&&ye(s,e,n,r,o))return!0;V(c,i,le);return!!(o.intersectsBox(le)&&ye(c,e,n,r,o))}{const o=e.geometry,l=o.index,u=o.attributes.position,d=n.index,f=n.attributes.position,h=tt(t,a),p=et(c,s);if(fe.copy(r).invert(),n.boundsTree){V(t,i,pe),pe.matrix.copy(fe),pe.needsUpdate=!0;return n.boundsTree.shapecast({intersectsBounds:t=>pe.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(r),t.b.applyMatrix4(r),t.c.applyMatrix4(r),t.needsUpdate=!0;for(let n=h,r=p+h;n<r;n++)if(St(de,3*e.resolveTriangleIndex(n),l,u),de.needsUpdate=!0,t.intersectsTriangle(de))return!0;return!1}})}for(let t=h,n=p+h;t<n;t++){const n=e.resolveTriangleIndex(t);St(ue,3*n,l,u),ue.a.applyMatrix4(fe),ue.b.applyMatrix4(fe),ue.c.applyMatrix4(fe),ue.needsUpdate=!0;for(let t=0,e=d.count;t<e;t+=3)if(St(de,t,d,f),de.needsUpdate=!0,ue.intersectsTriangle(de))return!0}}}const me=new h.Matrix4,xe=new Z,we=new Z,be=new h.Vector3,Be=new h.Vector3,Ae=new h.Vector3,ve=new h.Vector3;function Te(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{},i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1/0;e.boundingBox||e.computeBoundingBox(),xe.set(e.boundingBox.min,e.boundingBox.max,n),xe.needsUpdate=!0;const a=t.geometry,c=a.attributes.position,l=a.index,u=e.attributes.position,d=e.index,f=Q.getPrimitive(),h=Q.getPrimitive();let p=be,g=Be,y=null,m=null;o&&(y=Ae,m=ve);let x=1/0,w=null,b=null;return me.copy(n).invert(),we.matrix.copy(me),t.shapecast({boundsTraverseOrder:t=>xe.distanceToBox(t),intersectsBounds:(t,e,n)=>n<x&&n<s&&(e&&(we.min.copy(t.min),we.max.copy(t.max),we.needsUpdate=!0),!0),intersectsRange:(r,o)=>{if(e.boundsTree){const a=e.boundsTree;return a.shapecast({boundsTraverseOrder:t=>we.distanceToBox(t),intersectsBounds:(t,e,n)=>n<x&&n<s,intersectsRange:(e,s)=>{for(let B=e,A=e+s;B<A;B++){const e=a.resolveTriangleIndex(B);St(h,3*e,d,u),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let n=r,s=r+o;n<s;n++){const e=t.resolveTriangleIndex(n);St(f,3*e,l,c),f.needsUpdate=!0;const r=f.distanceToTriangle(h,p,y);if(r<x&&(g.copy(p),m&&m.copy(y),x=r,w=n,b=B),r<i)return!0}}}})}for(let s=0,a=v(e);s<a;s++){St(h,3*s,d,u),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let e=r,n=r+o;e<n;e++){const n=t.resolveTriangleIndex(e);St(f,3*n,l,c),f.needsUpdate=!0;const r=f.distanceToTriangle(h,p,y);if(r<x&&(g.copy(p),m&&m.copy(y),x=r,w=e,b=s),r<i)return!0}}}}),Q.releasePrimitive(f),Q.releasePrimitive(h),x===1/0?null:(r.point?r.point.copy(g):r.point=g.clone(),r.distance=x,r.faceIndex=w,o&&(o.point?o.point.copy(m):o.point=m.clone(),o.point.applyMatrix4(me),g.applyMatrix4(me),o.distance=g.sub(o.point).length(),o.faceIndex=b),r)}const Me=new it.constructor,Se=new it.constructor,Ve=new K((()=>new h.Box3)),Pe=new h.Box3,Ie=new h.Box3,ze=new h.Box3,Ee=new h.Box3;let Ue=!1;function _e(t,e,n,r,o){let i,s,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,c=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,l=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,u=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0,d=arguments.length>9&&void 0!==arguments[9]?arguments[9]:null,f=arguments.length>10&&void 0!==arguments[10]&&arguments[10];f?(i=Se,s=Me):(i=Me,s=Se);const h=i.float32Array,p=i.uint32Array,g=i.uint16Array,y=s.float32Array,m=s.uint32Array,x=s.uint16Array,w=2*e,b=$(2*t,g),B=$(w,x);let A=!1;if(B&&b)A=f?o(tt(e,m),et(2*e,x),tt(t,p),et(2*t,g),u,c+e,l,a+t):o(tt(t,p),et(2*t,g),tt(e,m),et(2*e,x),l,a+t,u,c+e);else if(B){const i=Ve.getPrimitive();V(e,y,i),i.applyMatrix4(n);const s=nt(t),d=rt(t,p);V(s,h,Pe),V(d,h,Ie);const g=i.intersectsBox(Pe),m=i.intersectsBox(Ie);A=g&&_e(e,s,r,n,o,c,a,u,l+1,i,!f)||m&&_e(e,d,r,n,o,c,a,u,l+1,i,!f),Ve.releasePrimitive(i)}else{const i=nt(e),s=rt(e,m);V(i,y,ze),V(s,y,Ee);const g=d.intersectsBox(ze),x=d.intersectsBox(Ee);if(g&&x)A=_e(t,i,n,r,o,a,c,l,u+1,d,f)||_e(t,s,n,r,o,a,c,l,u+1,d,f);else if(g)if(b)A=_e(t,i,n,r,o,a,c,l,u+1,d,f);else{const e=Ve.getPrimitive();e.copy(ze).applyMatrix4(n);const s=nt(t),d=rt(t,p);V(s,h,Pe),V(d,h,Ie);const g=e.intersectsBox(Pe),y=e.intersectsBox(Ie);A=g&&_e(i,s,r,n,o,c,a,u,l+1,e,!f)||y&&_e(i,d,r,n,o,c,a,u,l+1,e,!f),Ve.releasePrimitive(e)}else if(x)if(b)A=_e(t,s,n,r,o,a,c,l,u+1,d,f);else{const e=Ve.getPrimitive();e.copy(Ee).applyMatrix4(n);const i=nt(t),d=rt(t,p);V(i,h,Pe),V(d,h,Ie);const g=e.intersectsBox(Pe),y=e.intersectsBox(Ie);A=g&&_e(s,i,r,n,o,c,a,u,l+1,e,!f)||y&&_e(s,d,r,n,o,c,a,u,l+1,e,!f),Ve.releasePrimitive(e)}}return A}const Ce=new Z,Fe=new h.Box3;class Ge{static serialize(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};e={cloneBuffers:!0,...e};const n=t.geometry,r=t._roots,o=t._indirectBuffer,i=n.getIndex();let s;return s=e.cloneBuffers?{roots:r.map((t=>t.slice())),index:i.array.slice(),indirectBuffer:o?o.slice():null}:{roots:r,index:i.array,indirectBuffer:o},s}static deserialize(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};n={setIndex:!0,indirect:Boolean(t.indirectBuffer),...n};const{index:r,roots:o,indirectBuffer:i}=t,s=new Ge(e,{...n,[A]:!0});if(s._roots=o,s._indirectBuffer=i||null,n.setIndex){const n=e.getIndex();if(null===n){const n=new h.BufferAttribute(t.index,1,!1);e.setIndex(n)}else n.array!==r&&(n.array.set(r),n.needsUpdate=!0)}return s}get indirect(){return!!this._indirectBuffer}constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!t.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");if(e=Object.assign({strategy:p,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,[A]:!1},e),e.useSharedArrayBuffer&&"undefined"===typeof SharedArrayBuffer)throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[A]||(q(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new h.Box3)));const{_indirectBuffer:n}=this;this.resolveTriangleIndex=e.indirect?t=>n[t]:t=>t}refit(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;return(this.indirect?ee:Pt)(this,t)}traverse(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=this._roots[e],r=new Uint32Array(n),o=new Uint16Array(n);!function e(i){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const a=2*i,c=o[a+15]===b;if(c){const e=r[i+6],l=o[a+14];t(s,c,new Float32Array(n,4*i,6),e,l)}else{const o=i+8,a=r[i+6],l=r[i+7];t(s,c,new Float32Array(n,4*i,6),l)||(e(o,s+1),e(a,s+1))}}(0)}raycast(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:h.FrontSide;const n=this._roots,r=this.geometry,o=[],i=e.isMaterial,s=Array.isArray(e),a=r.groups,c=i?e.side:e,l=this.indirect?re:Ut;for(let u=0,d=n.length;u<d;u++){const n=s?e[a[u].materialIndex].side:c,r=o.length;if(l(this,u,n,t,o),s){const t=a[u].materialIndex;for(let e=r,n=o.length;e<n;e++)o[e].face.materialIndex=t}}return o}raycastFirst(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:h.FrontSide;const n=this._roots,r=this.geometry,o=e.isMaterial,i=Array.isArray(e);let s=null;const a=r.groups,c=o?e.side:e,l=this.indirect?ae:Gt;for(let u=0,d=n.length;u<d;u++){const n=l(this,u,i?e[a[u].materialIndex].side:c,t);null!=n&&(null==s||n.distance<s.distance)&&(s=n,i&&(n.face.materialIndex=a[u].materialIndex))}return s}intersectsGeometry(t,e){let n=!1;const r=this._roots,o=this.indirect?ge:Ot;for(let i=0,s=r.length;i<s&&(n=o(this,i,t,e),!n);i++);return n}shapecast(t){const e=Q.getPrimitive(),n=this.indirect?te:Vt;let{boundsTraverseOrder:r,intersectsBounds:o,intersectsRange:i,intersectsTriangle:s}=t;if(i&&s){const t=i;i=(r,o,i,a,c)=>!!t(r,o,i,a,c)||n(r,o,this,s,i,a,e)}else i||(i=s?(t,r,o,i)=>n(t,r,this,s,o,i,e):(t,e,n)=>n);let a=!1,c=0;const l=this._roots;for(let u=0,d=l.length;u<d;u++){const t=l[u];if(a=ut(this,u,o,i,r,c),a)break;c+=t.byteLength}return Q.releasePrimitive(e),a}bvhcast(t,e,n){let{intersectsRanges:r,intersectsTriangles:o}=n;const i=Q.getPrimitive(),s=this.geometry.index,a=this.geometry.attributes.position,c=this.indirect?t=>{const e=this.resolveTriangleIndex(t);St(i,3*e,s,a)}:t=>{St(i,3*t,s,a)},l=Q.getPrimitive(),u=t.geometry.index,d=t.geometry.attributes.position,f=t.indirect?e=>{const n=t.resolveTriangleIndex(e);St(l,3*n,u,d)}:t=>{St(l,3*t,u,d)};if(o){const t=(t,n,r,s,a,u,d,h)=>{for(let p=r,g=r+s;p<g;p++){f(p),l.a.applyMatrix4(e),l.b.applyMatrix4(e),l.c.applyMatrix4(e),l.needsUpdate=!0;for(let e=t,r=t+n;e<r;e++)if(c(e),i.needsUpdate=!0,o(i,l,e,p,a,u,d,h))return!0}return!1};if(r){const e=r;r=function(n,r,o,i,s,a,c,l){return!!e(n,r,o,i,s,a,c,l)||t(n,r,o,i,s,a,c,l)}}else r=t}return function(t,e,n,r){if(Ue)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Ue=!0;const o=t._roots,i=e._roots;let s,a=0,c=0;const l=(new h.Matrix4).copy(n).invert();for(let u=0,d=o.length;u<d;u++){Me.setBuffer(o[u]),c=0;const t=Ve.getPrimitive();V(0,Me.float32Array,t),t.applyMatrix4(l);for(let e=0,o=i.length;e<o&&(Se.setBuffer(i[u]),s=_e(0,0,n,l,r,a,c,0,0,t),Se.clearBuffer(),c+=i[e].length,!s);e++);if(Ve.releasePrimitive(t),Me.clearBuffer(),a+=o[u].length,s)break}return Ue=!1,s}(this,t,e,r)}intersectsBox(t,e){return Ce.set(t.min,t.max,e),Ce.needsUpdate=!0,this.shapecast({intersectsBounds:t=>Ce.intersectsBox(t),intersectsTriangle:t=>Ce.intersectsTriangle(t)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1/0;return(this.indirect?Te:$t)(this,t,e,n,r,o,i)}closestPointToPoint(t){return function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1/0;const i=r*r,s=o*o;let a=1/0,c=null;if(t.shapecast({boundsTraverseOrder:t=>(ft.copy(e).clamp(t.min,t.max),ft.distanceToSquared(e)),intersectsBounds:(t,e,n)=>n<a&&n<s,intersectsTriangle:(t,n)=>{t.closestPointToPoint(e,ft);const r=e.distanceToSquared(ft);return r<a&&(ht.copy(ft),a=r,c=n),r<i}}),a===1/0)return null;const l=Math.sqrt(a);return n.point?n.point.copy(ht):n.point=ht.clone(),n.distance=l,n.faceIndex=c,n}(this,t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0)}getBoundingBox(t){t.makeEmpty();return this._roots.forEach((e=>{V(0,new Float32Array(e),Fe),t.union(Fe)})),t}}const Re=1e-6,Xe=Math.pow(10,-Math.log10(Re)),ke=5e-7*Xe;function De(t){return~~(t*Xe+ke)}function Ne(t){return"".concat(De(t.x),",").concat(De(t.y),",").concat(De(t.z))}function qe(t){return"".concat(De(t.x),",").concat(De(t.y),",").concat(De(t.z),",").concat(De(t.w))}function Le(t,e,n){n.direction.subVectors(e,t).normalize();const r=t.dot(n.direction);return n.origin.copy(t).addScaledVector(n.direction,-r),n}function Oe(){return"undefined"!==typeof SharedArrayBuffer}function je(t){if(t.buffer instanceof SharedArrayBuffer)return t;const e=t.constructor,n=t.buffer,r=new SharedArrayBuffer(n.byteLength),o=new Uint8Array(n);return new Uint8Array(r).set(o,0),new e(r)}function We(t,e){if(!t.index){const n=t.attributes.position.count,r=function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ArrayBuffer;return t>65535?new Uint32Array(new e(4*t)):new Uint16Array(new e(2*t))}(n,e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer);t.setIndex(new h.BufferAttribute(r,1));for(let t=0;t<n;t++)r[t]=t}}function He(t){return function(t){return t.index?t.index.count:t.attributes.position.count}(t)/3}const Ye=1e-8,Ze=new h.Vector3;function Ke(t){return t%3}function Je(t,e){return t.start-e.start}function Qe(t,e){return Ze.subVectors(e,t.origin).dot(t.direction)}const $e=1e-5,tn=1e-4;class en{constructor(){this._rays=[]}addRay(t){this._rays.push(t)}findClosestRay(t){const e=this._rays,n=t.clone();n.direction.multiplyScalar(-1);let r=1/0,o=null;for(let a=0,c=e.length;a<c;a++){const c=e[a];if(i(c,t)&&i(c,n))continue;const l=s(c,t),u=s(c,n),d=Math.min(l,u);d<r&&(r=d,o=c)}return o;function i(t,e){const n=t.origin.distanceTo(e.origin)>$e;return t.direction.angleTo(e.direction)>tn||n}function s(t,e){const n=t.origin.distanceTo(e.origin),r=t.direction.angleTo(e.direction);return n/$e+r/tn}}}const nn=new h.Vector3,rn=new h.Vector3,on=new h.Ray;function sn(t,e,n){const r=t.attributes,o=t.index,i=r.position,s=new Map,a=new Map,c=Array.from(e),l=new en;for(let u=0,d=c.length;u<d;u++){const t=c[u],e=~~(t/3),n=Ke(t);let r,s=3*e+n,d=3*e+(n+1)%3;o&&(s=o.getX(s),d=o.getX(d)),nn.fromBufferAttribute(i,s),rn.fromBufferAttribute(i,d),Le(nn,rn,on);let f=l.findClosestRay(on);null===f&&(f=on.clone(),l.addRay(f)),a.has(f)||a.set(f,{forward:[],reverse:[],ray:f}),r=a.get(f);let h=Qe(f,nn),p=Qe(f,rn);h>p&&([h,p]=[p,h]),on.direction.dot(f.direction)<0?r.reverse.push({start:h,end:p,index:t}):r.forward.push({start:h,end:p,index:t})}return a.forEach(((t,e)=>{let{forward:r,reverse:o}=t;!function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Ye;t.sort(Je),e.sort(Je);for(let a=0;a<t.length;a++){const r=t[a];for(let o=0;o<e.length;o++){const c=e[o];if(c.start>r.end);else{if(r.end<c.start||c.end<r.start)continue;if(r.start<=c.start&&r.end>=c.end)i(c.end,r.end)||t.splice(a+1,0,{start:c.end,end:r.end,index:r.index}),r.end=c.start,c.start=0,c.end=0;else if(r.start>=c.start&&r.end<=c.end)i(r.end,c.end)||e.splice(o+1,0,{start:r.end,end:c.end,index:c.index}),c.end=r.start,r.start=0,r.end=0;else if(r.start<=c.start&&r.end<=c.end){const t=r.end;r.end=c.start,c.start=t}else{if(!(r.start>=c.start&&r.end>=c.end))throw new Error;{const t=c.end;c.end=r.start,r.start=t}}}if(n.has(r.index)||n.set(r.index,[]),n.has(c.index)||n.set(c.index,[]),n.get(r.index).push(c.index),n.get(c.index).push(r.index),s(c)&&(e.splice(o,1),o--),s(r)){t.splice(a,1),a--;break}}}function o(t){for(let e=0;e<t.length;e++)s(t[e])&&(t.splice(e,1),e--)}function i(t,e){return Math.abs(e-t)<r}function s(t){return Math.abs(t.end-t.start)<r}o(t),o(e)}(r,o,s,n),0===r.length&&0===o.length&&a.delete(e)})),{disjointConnectivityMap:s,fragmentMap:a}}const an=new h.Vector2,cn=new h.Vector3,ln=new h.Vector4,un=["","",""];class dn{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;this.data=null,this.disjointConnections=null,this.unmatchedDisjointEdges=null,this.unmatchedEdges=-1,this.matchedEdges=-1,this.useDrawRange=!0,this.useAllAttributes=!1,this.matchDisjointEdges=!1,this.degenerateEpsilon=1e-8,t&&this.updateFrom(t)}getSiblingTriangleIndex(t,e){const n=this.data[3*t+e];return-1===n?-1:~~(n/3)}getSiblingEdgeIndex(t,e){const n=this.data[3*t+e];return-1===n?-1:n%3}getDisjointSiblingTriangleIndices(t,e){const n=3*t+e,r=this.disjointConnections.get(n);return r?r.map((t=>~~(t/3))):[]}getDisjointSiblingEdgeIndices(t,e){const n=3*t+e,r=this.disjointConnections.get(n);return r?r.map((t=>t%3)):[]}isFullyConnected(){return 0===this.unmatchedEdges}updateFrom(t){const{useAllAttributes:e,useDrawRange:n,matchDisjointEdges:r,degenerateEpsilon:o}=this,i=e?function(t){let e="";for(let r=0,o=c.length;r<o;r++){const o=a[c[r]];let i;switch(o.itemSize){case 1:i=De(o.getX(t));break;case 2:n=an.fromBufferAttribute(o,t),i="".concat(De(n.x),",").concat(De(n.y));break;case 3:i=Ne(cn.fromBufferAttribute(o,t));break;case 4:i=qe(ln.fromBufferAttribute(o,t))}""!==e&&(e+="|"),e+=i}var n;return e}:function(t){return cn.fromBufferAttribute(u,t),Ne(cn)},s=new Map,{attributes:a}=t,c=e?Object.keys(a):null,l=t.index,u=a.position;let d=He(t);const f=d;let h=0;n&&(h=t.drawRange.start,t.drawRange.count!==1/0&&(d=~~(t.drawRange.count/3)));let p=this.data;(!p||p.length<3*f)&&(p=new Int32Array(3*f)),p.fill(-1);let g=0,y=new Set;for(let m=h,x=3*d+h;m<x;m+=3){const t=m;for(let e=0;e<3;e++){let n=t+e;l&&(n=l.getX(n)),un[e]=i(n)}for(let e=0;e<3;e++){const n=(e+1)%3,r=un[e],o=un[n],i="".concat(o,"_").concat(r);if(s.has(i)){const n=t+e,r=s.get(i);p[n]=r,p[r]=n,s.delete(i),g+=2,y.delete(r)}else{const n="".concat(r,"_").concat(o),i=t+e;s.set(n,i),y.add(i)}}}if(r){const{fragmentMap:e,disjointConnectivityMap:n}=sn(t,y,o);y.clear(),e.forEach((t=>{let{forward:e,reverse:n}=t;e.forEach((t=>{let{index:e}=t;return y.add(e)})),n.forEach((t=>{let{index:e}=t;return y.add(e)}))})),this.unmatchedDisjointEdges=e,this.disjointConnections=n,g=3*d-y.size}this.matchedEdges=g,this.unmatchedEdges=y.size,this.data=p}}class fn extends h.Mesh{constructor(){super(...arguments),this.isBrush=!0,this._previousMatrix=new h.Matrix4,this._previousMatrix.elements.fill(0)}markUpdated(){this._previousMatrix.copy(this.matrix)}isDirty(){const{matrix:t,_previousMatrix:e}=this,n=t.elements,r=e.elements;for(let o=0;o<16;o++)if(n[o]!==r[o])return!0;return!1}prepareGeometry(){const t=this.geometry,e=t.attributes,n=Oe();if(n)for(const r in e){const t=e[r];if(t.isInterleavedBufferAttribute)throw new Error("Brush: InterleavedBufferAttributes are not supported.");t.array=je(t.array)}if(t.boundsTree||(We(t,{useSharedArrayBuffer:n}),t.boundsTree=new Ge(t,{maxLeafTris:3,indirect:!0,useSharedArrayBuffer:n})),t.halfEdges||(t.halfEdges=new dn(t)),!t.groupIndices){const e=He(t),n=new Uint16Array(e),r=t.groups;for(let t=0,o=r.length;t<o;t++){const{start:e,count:o}=r[t];for(let r=e/3,i=(e+o)/3;r<i;r++)n[r]=t}t.groupIndices=n}}disposeCacheData(){const{geometry:t}=this;t.halfEdges=null,t.boundsTree=null,t.groupIndices=null}}const hn=1e-14,pn=new h.Vector3,gn=new h.Vector3,yn=new h.Vector3;function mn(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:hn;pn.subVectors(t.b,t.a),gn.subVectors(t.c,t.a),yn.subVectors(t.b,t.c);const n=pn.angleTo(gn),r=pn.angleTo(yn),o=Math.PI-n-r;return Math.abs(n)<e||Math.abs(r)<e||Math.abs(o)<e||t.a.distanceToSquared(t.b)<e||t.a.distanceToSquared(t.c)<e||t.b.distanceToSquared(t.c)<e}const xn=1e-10,wn=1e-10,bn=new h.Line3,Bn=new h.Line3,An=new h.Vector3,vn=new h.Vector3,Tn=new h.Vector3,Mn=new h.Plane,Sn=new Y;class Vn{constructor(){this._pool=[],this._index=0}getTriangle(){return this._index>=this._pool.length&&this._pool.push(new h.Triangle),this._pool[this._index++]}clear(){this._index=0}reset(){this._pool.length=0,this._index=0}}class Pn{constructor(){this.trianglePool=new Vn,this.triangles=[],this.normal=new h.Vector3,this.coplanarTriangleUsed=!1}initialize(t){this.reset();const{triangles:e,trianglePool:n,normal:r}=this;if(Array.isArray(t))for(let o=0,i=t.length;o<i;o++){const i=t[o];if(0===o)i.getNormal(r);else if(Math.abs(1-i.getNormal(An).dot(r))>xn)throw new Error("Triangle Splitter: Cannot initialize with triangles that have different normals.");const s=n.getTriangle();s.copy(i),e.push(s)}else{t.getNormal(r);const o=n.getTriangle();o.copy(t),e.push(o)}}splitByTriangle(t){const{normal:e,triangles:n}=this;if(t.getNormal(vn).normalize(),Math.abs(1-Math.abs(vn.dot(e)))<1e-10){this.coplanarTriangleUsed=!0;for(let t=0,r=n.length;t<r;t++){n[t].coplanarCount=0}const e=[t.a,t.b,t.c];for(let n=0;n<3;n++){const r=(n+1)%3,o=e[n],i=e[r];An.subVectors(i,o).normalize(),Tn.crossVectors(vn,An),Mn.setFromNormalAndCoplanarPoint(Tn,o),this.splitByPlane(Mn,t)}}else t.getPlane(Mn),this.splitByPlane(Mn,t)}splitByPlane(t,e){const{triangles:n,trianglePool:r}=this;Sn.copy(e),Sn.needsUpdate=!0;for(let o=0,i=n.length;o<i;o++){const e=n[o];if(!Sn.intersectsTriangle(e,bn,!0))continue;const{a:s,b:a,c:c}=e;let l=0,u=-1,d=!1,f=[],h=[];const p=[s,a,c];for(let n=0;n<3;n++){const e=(n+1)%3;bn.start.copy(p[n]),bn.end.copy(p[e]);const r=t.distanceToPoint(bn.start),o=t.distanceToPoint(bn.end);if(Math.abs(r)<wn&&Math.abs(o)<wn){d=!0;break}if(r>0?f.push(n):h.push(n),Math.abs(r)<wn)continue;let i=!!t.intersectLine(bn,An);!i&&Math.abs(o)<wn&&(An.copy(bn.end),i=!0),!i||An.distanceTo(bn.start)<xn||(An.distanceTo(bn.end)<xn&&(u=n),0===l?Bn.start.copy(An):Bn.end.copy(An),l++)}if(!d&&2===l&&Bn.distance()>wn)if(-1!==u){u=(u+1)%3;let t=0;t===u&&(t=(t+1)%3);let s=t+1;s===u&&(s=(s+1)%3);const a=r.getTriangle();a.a.copy(p[s]),a.b.copy(Bn.end),a.c.copy(Bn.start),mn(a)||n.push(a),e.a.copy(p[t]),e.b.copy(Bn.start),e.c.copy(Bn.end),mn(e)&&(n.splice(o,1),o--,i--)}else{const t=f.length>=2?h[0]:f[0];if(0===t){let t=Bn.start;Bn.start=Bn.end,Bn.end=t}const s=(t+1)%3,a=(t+2)%3,c=r.getTriangle(),l=r.getTriangle();p[s].distanceToSquared(Bn.start)<p[a].distanceToSquared(Bn.end)?(c.a.copy(p[s]),c.b.copy(Bn.start),c.c.copy(Bn.end),l.a.copy(p[s]),l.b.copy(p[a]),l.c.copy(Bn.start)):(c.a.copy(p[a]),c.b.copy(Bn.start),c.c.copy(Bn.end),l.a.copy(p[s]),l.b.copy(p[a]),l.c.copy(Bn.end)),e.a.copy(p[t]),e.b.copy(Bn.end),e.c.copy(Bn.start),mn(c)||n.push(c),mn(l)||n.push(l),mn(e)&&(n.splice(o,1),o--,i--)}else 3===l&&console.warn("TriangleClipper: Coplanar clip not handled")}}reset(){this.triangles.length=0,this.trianglePool.clear(),this.coplanarTriangleUsed=!1}}class In{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:500;this.expansionFactor=1.5,this.type=t,this.length=0,this.array=null,this.setSize(e)}setType(t){if(0!==this.length)throw new Error("TypeBackedArray: Cannot change the type while there is used data in the buffer.");const e=this.array.buffer;this.array=new t(e),this.type=t}setSize(t){if(this.array&&t===this.array.length)return;const e=this.type,n=new e(new(Oe()?SharedArrayBuffer:ArrayBuffer)(4+(r=~~(r=t*e.BYTES_PER_ELEMENT))-r%4));var r;this.array&&n.set(this.array,0),this.array=n}expand(){const{array:t,expansionFactor:e}=this;this.setSize(t.length*e)}push(){let{array:t,length:e}=this;e+arguments.length>t.length&&(this.expand(),t=this.array);for(let n=0,r=arguments.length;n<r;n++)t[e+n]=n<0||arguments.length<=n?void 0:arguments[n];this.length+=arguments.length}clear(){this.length=0}}class zn{constructor(){this.groupAttributes=[{}],this.groupCount=0}getType(t){return this.groupAttributes[0][t].type}getItemSize(t){return this.groupAttributes[0][t].itemSize}getNormalized(t){return this.groupAttributes[0][t].normalized}getCount(t){if(this.groupCount<=t)return 0;const e=this.getGroupAttrArray("position",t);return e.length/e.itemSize}getTotalLength(t){const{groupCount:e,groupAttributes:n}=this;let r=0;for(let o=0;o<e;o++){r+=n[o][t].length}return r}getGroupAttrSet(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const{groupAttributes:e}=this;if(e[t])return this.groupCount=Math.max(this.groupCount,t+1),e[t];const n=e[0];for(this.groupCount=Math.max(this.groupCount,t+1);t>=e.length;){const t={};e.push(t);for(const e in n){const r=n[e],o=new In(r.type);o.itemSize=r.itemSize,o.normalized=r.normalized,t[e]=o}}return e[t]}getGroupAttrArray(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const{groupAttributes:n}=this;if(!n[0][t])throw new Error('TypedAttributeData: Attribute with "'.concat(t,'" has not been initialized'));return this.getGroupAttrSet(e)[t]}initializeArray(t,e,n,r){const{groupAttributes:o}=this,i=o[0][t];if(i){if(i.type!==e)for(let s=0,a=o.length;s<a;s++){const i=o[s][t];i.setType(e),i.itemSize=n,i.normalized=r}}else for(let s=0,a=o.length;s<a;s++){const i=new In(e);i.itemSize=n,i.normalized=r,o[s][t]=i}}clear(){this.groupCount=0;const{groupAttributes:t}=this;t.forEach((t=>{for(const e in t)t[e].clear()}))}delete(t){this.groupAttributes.forEach((e=>{delete e[t]}))}reset(){this.groupAttributes=[],this.groupCount=0}}class En{constructor(){this.intersectionSet={},this.ids=[]}add(t,e){const{intersectionSet:n,ids:r}=this;n[t]||(n[t]=[],r.push(t)),n[t].push(e)}}const Un=new h.Ray,_n=new h.Matrix4,Cn=new h.Triangle,Fn=new h.Vector3,Gn=new h.Vector4,Rn=new h.Vector4,Xn=new h.Vector4,kn=new h.Vector4,Dn=new h.Vector4,Nn=new h.Vector4,qn=new h.Line3,Ln=new h.Vector3,On=1e-8,jn=1e-15,Wn=-1,Hn=1,Yn=-2,Zn=2,Kn=0,Jn=1,Qn=2,$n=1e-14;let tr=null;function er(t){tr=t}function nr(t,e){t.getMidpoint(Un.origin),t.getNormal(Un.direction);const n=e.raycastFirst(Un,h.DoubleSide);return Boolean(n&&Un.direction.dot(n.face.normal)>0)?Wn:Hn}function rr(t,e){function n(){return Math.random()-.5}t.getNormal(Ln),Un.direction.copy(Ln),t.getMidpoint(Un.origin);let r=0,o=1/0;for(let i=0;i<3;i++){Un.direction.x+=n()*On,Un.direction.y+=n()*On,Un.direction.z+=n()*On,Un.direction.multiplyScalar(-1);const t=e.raycastFirst(Un,h.DoubleSide);if(Boolean(t&&Un.direction.dot(t.face.normal)>0)&&r++,null!==t&&(o=Math.min(o,t.distance)),o<=jn)return t.face.normal.dot(Ln)>0?Zn:Yn;if(r/3>.5||(i-r+1)/3>.5)break}return r/3>.5?Wn:Hn}function or(t,e,n,r,o,i){let s=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const a=n.attributes,c=n.index,l=3*t,u=c.getX(l+0),d=c.getX(l+1),f=c.getX(l+2);for(const h in i){const t=a[h],n=i[h];if(!(h in a))throw new Error("CSG Operations: Attribute ".concat(h," not available on geometry."));const c=t.itemSize;"position"===h?(Cn.a.fromBufferAttribute(t,u).applyMatrix4(r),Cn.b.fromBufferAttribute(t,d).applyMatrix4(r),Cn.c.fromBufferAttribute(t,f).applyMatrix4(r),ar(Cn.a,Cn.b,Cn.c,e,3,n,s)):"normal"===h?(Cn.a.fromBufferAttribute(t,u).applyNormalMatrix(o),Cn.b.fromBufferAttribute(t,d).applyNormalMatrix(o),Cn.c.fromBufferAttribute(t,f).applyNormalMatrix(o),s&&(Cn.a.multiplyScalar(-1),Cn.b.multiplyScalar(-1),Cn.c.multiplyScalar(-1)),ar(Cn.a,Cn.b,Cn.c,e,3,n,s,!0)):(Gn.fromBufferAttribute(t,u),Rn.fromBufferAttribute(t,d),Xn.fromBufferAttribute(t,f),ar(Gn,Rn,Xn,e,c,n,s))}}function ir(t,e,n,r,o,i,s){let a=arguments.length>7&&void 0!==arguments[7]&&arguments[7];cr(t,r,o,i,s,a),cr(a?n:e,r,o,i,s,a),cr(a?e:n,r,o,i,s,a)}function sr(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];switch(t){case s:if(e===Hn||e===Zn&&!n)return Jn;break;case a:if(n){if(e===Wn)return Kn}else if(e===Hn||e===Yn)return Jn;break;case c:if(n){if(e===Hn||e===Yn)return Jn}else if(e===Wn)return Kn;break;case u:if(e===Wn)return Kn;if(e===Hn)return Jn;break;case l:if(e===Wn||e===Zn&&!n)return Jn;break;case d:if(!n&&(e===Hn||e===Yn))return Jn;break;case f:if(!n&&(e===Wn||e===Zn))return Jn;break;default:throw new Error('Unrecognized CSG operation enum "'.concat(t,'".'))}return Qn}function ar(t,e,n,r,o,i){let s=arguments.length>6&&void 0!==arguments[6]&&arguments[6],a=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const c=t=>{i.push(t.x),o>1&&i.push(t.y),o>2&&i.push(t.z),o>3&&i.push(t.w)};kn.set(0,0,0,0).addScaledVector(t,r.a.x).addScaledVector(e,r.a.y).addScaledVector(n,r.a.z),Dn.set(0,0,0,0).addScaledVector(t,r.b.x).addScaledVector(e,r.b.y).addScaledVector(n,r.b.z),Nn.set(0,0,0,0).addScaledVector(t,r.c.x).addScaledVector(e,r.c.y).addScaledVector(n,r.c.z),a&&(kn.normalize(),Dn.normalize(),Nn.normalize()),c(kn),s?(c(Nn),c(Dn)):(c(Dn),c(Nn))}function cr(t,e,n,r,o){let i=arguments.length>5&&void 0!==arguments[5]&&arguments[5];for(const s in o){const a=e[s],c=o[s];if(!(s in e))throw new Error("CSG Operations: Attribute ".concat(s," no available on geometry."));const l=a.itemSize;"position"===s?(Fn.fromBufferAttribute(a,t).applyMatrix4(n),c.push(Fn.x,Fn.y,Fn.z)):"normal"===s?(Fn.fromBufferAttribute(a,t).applyNormalMatrix(r),i&&Fn.multiplyScalar(-1),c.push(Fn.x,Fn.y,Fn.z)):(c.push(a.getX(t)),l>1&&c.push(a.getY(t)),l>2&&c.push(a.getZ(t)),l>3&&c.push(a.getW(t)))}}class lr{constructor(t){this.triangle=(new h.Triangle).copy(t),this.intersects={}}addTriangle(t,e){this.intersects[t]=(new h.Triangle).copy(e)}getIntersectArray(){const t=[],{intersects:e}=this;for(const n in e)t.push(e[n]);return t}}class ur{constructor(){this.data={}}addTriangleIntersection(t,e,n,r){const{data:o}=this;o[t]||(o[t]=new lr(e)),o[t].addTriangle(n,r)}getTrianglesAsArray(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const{data:e}=this,n=[];if(null!==t)t in e&&n.push(e[t].triangle);else for(const r in e)n.push(e[r].triangle);return n}getTriangleIndices(){return Object.keys(this.data).map((t=>parseInt(t)))}getIntersectionIndices(t){const{data:e}=this;return e[t]?Object.keys(e[t].intersects).map((t=>parseInt(t))):[]}getIntersectionsAsArray(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const{data:n}=this,r=new Set,o=[],i=t=>{if(n[t])if(null!==e)n[t].intersects[e]&&o.push(n[t].intersects[e]);else{const e=n[t].intersects;for(const t in e)r.has(t)||(r.add(t),o.push(e[t]))}};if(null!==t)i(t);else for(const s in n)i(s);return o}reset(){this.data={}}}class dr{constructor(){this.enabled=!1,this.triangleIntersectsA=new ur,this.triangleIntersectsB=new ur,this.intersectionEdges=[]}addIntersectingTriangles(t,e,n,r){const{triangleIntersectsA:o,triangleIntersectsB:i}=this;o.addTriangleIntersection(t,e,n,r),i.addTriangleIntersection(n,r,t,e)}addEdge(t){this.intersectionEdges.push(t.clone())}reset(){this.triangleIntersectsA.reset(),this.triangleIntersectsB.reset(),this.intersectionEdges=[]}init(){this.enabled&&(this.reset(),er(this))}complete(){this.enabled&&er(null)}}const fr=new h.Matrix4,hr=new h.Matrix3,pr=new h.Triangle,gr=new h.Triangle,yr=new h.Triangle,mr=new h.Triangle,xr=[],wr=[];function br(t){for(const e of t)return e}function Br(t,e,n,r,o){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{};const{useGroups:s=!0}=i,{aIntersections:a,bIntersections:c}=function(t,e){const n=new En,r=new En;return _n.copy(t.matrixWorld).invert().multiply(e.matrixWorld),t.geometry.boundsTree.bvhcast(e.geometry.boundsTree,_n,{intersectsTriangles(o,i,s,a){if(!mn(o)&&!mn(i)){let c=o.intersectsTriangle(i,qn,!0);if(!c){const t=o.plane,e=i.plane,n=t.normal,r=e.normal;1===n.dot(r)&&Math.abs(t.constant-e.constant)<$n&&(c=!0)}if(c){let c=t.geometry.boundsTree.resolveTriangleIndex(s),l=e.geometry.boundsTree.resolveTriangleIndex(a);n.add(c,l),r.add(l,c),tr&&(tr.addEdge(qn),tr.addIntersectingTriangles(s,o,a,i))}}return!1}}),{aIntersections:n,bIntersections:r}}(t,e);let l;l=s?0:-1,Ar(t,e,a,n,!1,r,o,l),vr(t,e,a,n,!1,o,l);return-1!==n.findIndex((t=>t!==f&&t!==d))&&(l=s?t.geometry.groups.length||1:-1,Ar(e,t,c,n,!0,r,o,l),vr(e,t,c,n,!0,o,l)),xr.length=0,wr.length=0,{groups:[],materials:null}}function Ar(t,e,n,r,o,i,s){let a=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const c=t.matrixWorld.determinant()<0;fr.copy(e.matrixWorld).invert().multiply(t.matrixWorld),hr.getNormalMatrix(t.matrixWorld).multiplyScalar(c?-1:1);const l=t.geometry.groupIndices,u=t.geometry.index,d=t.geometry.attributes.position,f=e.geometry.boundsTree,h=e.geometry.index,p=e.geometry.attributes.position,g=n.ids,y=n.intersectionSet;for(let m=0,x=g.length;m<x;m++){const e=g[m],n=-1===a?0:l[e]+a,x=3*e,w=u.getX(x+0),b=u.getX(x+1),B=u.getX(x+2);pr.a.fromBufferAttribute(d,w).applyMatrix4(fr),pr.b.fromBufferAttribute(d,b).applyMatrix4(fr),pr.c.fromBufferAttribute(d,B).applyMatrix4(fr),i.reset(),i.initialize(pr);const A=y[e];for(let t=0,r=A.length;t<r;t++){const e=3*A[t],n=h.getX(e+0),r=h.getX(e+1),o=h.getX(e+2);gr.a.fromBufferAttribute(p,n),gr.b.fromBufferAttribute(p,r),gr.c.fromBufferAttribute(p,o),i.splitByTriangle(gr)}const v=i.triangles;for(let a=0,l=v.length;a<l;a++){const l=v[a],u=i.coplanarTriangleUsed?rr(l,f):nr(l,f);xr.length=0,wr.length=0;for(let t=0,e=r.length;t<e;t++){const e=sr(r[t],u,o);e!==Qn&&(wr.push(e),xr.push(s[t].getGroupAttrSet(n)))}if(0!==xr.length){pr.getBarycoord(l.a,mr.a),pr.getBarycoord(l.b,mr.b),pr.getBarycoord(l.c,mr.c);for(let n=0,r=xr.length;n<r;n++){const r=xr[n],o=wr[n]===Kn;or(e,mr,t.geometry,t.matrixWorld,hr,r,c!==o)}}}}return g.length}function vr(t,e,n,r,o,i){let s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const a=t.matrixWorld.determinant()<0;fr.copy(e.matrixWorld).invert().multiply(t.matrixWorld),hr.getNormalMatrix(t.matrixWorld).multiplyScalar(a?-1:1);const c=e.geometry.boundsTree,l=t.geometry.groupIndices,u=t.geometry.index,d=t.geometry.attributes,f=d.position,h=[],p=t.geometry.halfEdges,g=new Set;for(let y=0,m=He(t.geometry);y<m;y++)y in n.intersectionSet||g.add(y);for(;g.size>0;){const e=br(g);g.delete(e),h.push(e);const n=3*e,y=u.getX(n+0),m=u.getX(n+1),x=u.getX(n+2);yr.a.fromBufferAttribute(f,y).applyMatrix4(fr),yr.b.fromBufferAttribute(f,m).applyMatrix4(fr),yr.c.fromBufferAttribute(f,x).applyMatrix4(fr);const w=nr(yr,c);wr.length=0,xr.length=0;for(let t=0,s=r.length;t<s;t++){const e=sr(r[t],w,o);e!==Qn&&(wr.push(e),xr.push(i[t]))}for(;h.length>0;){const e=h.pop();for(let t=0;t<3;t++){const n=p.getSiblingTriangleIndex(e,t);-1!==n&&g.has(n)&&(h.push(n),g.delete(n))}if(0!==xr.length){const n=3*e,r=u.getX(n+0),o=u.getX(n+1),i=u.getX(n+2),c=-1===s?0:l[e]+s;if(yr.a.fromBufferAttribute(f,r),yr.b.fromBufferAttribute(f,o),yr.c.fromBufferAttribute(f,i),!mn(yr))for(let e=0,s=xr.length;e<s;e++){const n=wr[e],s=xr[e].getGroupAttrSet(c),l=n===Kn;ir(r,o,i,d,t.matrixWorld,hr,s,l!==a)}}}}}function Tr(t,e){let n=e;return Array.isArray(e)||(n=[],t.forEach((t=>{n[t.materialIndex]=e}))),n}class Mr{constructor(){this.triangleSplitter=new Pn,this.attributeData=[],this.attributes=["position","uv","normal"],this.useGroups=!0,this.consolidateGroups=!0,this.debug=new dr}getGroupRanges(t){return this.useGroups&&0!==t.groups.length?t.groups.map((t=>({...t}))):[{start:0,count:1/0,materialIndex:0}]}evaluate(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new fn,o=!0;if(Array.isArray(n)||(n=[n]),Array.isArray(r)||(r=[r],o=!1),r.length!==n.length)throw new Error("Evaluator: operations and target array passed as different sizes.");t.prepareGeometry(),e.prepareGeometry();const{triangleSplitter:i,attributeData:s,attributes:a,useGroups:c,consolidateGroups:l,debug:u}=this;for(;s.length<r.length;)s.push(new zn);r.forEach(((e,n)=>{!function(t,e,n,r){n.clear();const o=t.attributes;for(let i=0,s=r.length;i<s;i++){const t=r[i],e=o[t];n.initializeArray(t,e.array.constructor,e.itemSize,e.normalized)}for(const i in n.attributes)r.includes(i)||n.delete(i);for(const i in e.attributes)r.includes(i)||(e.deleteAttribute(i),e.dispose())}(t.geometry,e.geometry,s[n],a)})),u.init(),Br(t,e,n,i,s,{useGroups:c}),u.complete();const d=this.getGroupRanges(t.geometry),f=Tr(d,t.material),p=this.getGroupRanges(e.geometry),g=Tr(p,e.material);p.forEach((t=>t.materialIndex+=f.length));let y=[...d,...p].map(((t,e)=>({...t,index:e})));if(c){const t=[...f,...g];l&&(y=y.map((e=>{const n=t[e.materialIndex];return e.materialIndex=t.indexOf(n),e})).sort(((t,e)=>t.materialIndex-e.materialIndex)));const e=[];for(let n=0,r=t.length;n<r;n++){let r=!1;for(let t=0,o=y.length;t<o;t++){const o=y[t];o.materialIndex===n&&(r=!0,o.materialIndex=e.length)}r&&e.push(t[n])}r.forEach((t=>{t.material=e}))}else y=[{start:0,count:1/0,index:0,materialIndex:0}],r.forEach((t=>{t.material=f[0]}));return r.forEach(((t,e)=>{const n=t.geometry;!function(t,e,n){let r=!1,o=-1;const i=t.attributes,s=e.groupAttributes[0];for(const c in s){const s=e.getTotalLength(c),a=e.getType(c),l=e.getItemSize(c),u=e.getNormalized(c);let d=i[c];(!d||d.array.length<s)&&(d=new h.BufferAttribute(new a(s),l,u),t.setAttribute(c,d),r=!0);let f=0;for(let t=0,r=Math.min(n.length,e.groupCount);t<r;t++){const r=n[t].index,{array:o,type:i,length:s}=e.groupAttributes[r][c],a=new i(o.buffer,0,s);d.array.set(a,f),f+=a.length}d.needsUpdate=!0,o=s/d.itemSize}if(t.index){const e=t.index.array;if(e.length<o)t.index=null,r=!0;else for(let t=0,n=e.length;t<n;t++)e[t]=t}let a=0;t.clearGroups();for(let c=0,l=Math.min(n.length,e.groupCount);c<l;c++){const{index:r,materialIndex:o}=n[c],i=e.getCount(r);0!==i&&(t.addGroup(a,i,o),a+=i)}t.setDrawRange(0,o),t.boundsTree=null,r&&t.dispose()}(n,s[e],y),l&&function(t){for(let e=0;e<t.length-1;e++){const n=t[e],r=t[e+1];if(n.materialIndex===r.materialIndex){const o=n.start,i=r.start+r.count;r.start=o,r.count=i-o,t.splice(e,1),e--}}}(n.groups)})),o?r:r[0]}evaluateHierarchy(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new fn;t.updateMatrixWorld(!0);const n=(t,e)=>{const r=t.children;for(let o=0,i=r.length;o<i;o++){const t=r[o];t.isOperationGroup?n(t,e):e(t)}},r=t=>{const e=t.children;let o=!1;for(let n=0,s=e.length;n<s;n++){const t=e[n];o=r(t)||o}const i=t.isDirty();if(i&&t.markUpdated(),o&&!t.isOperationGroup){let e;return n(t,(n=>{e=e?this.evaluate(e,n,n.operation):this.evaluate(t,n,n.operation)})),t._cachedGeometry=e.geometry,t._cachedMaterials=e.material,!0}return o||i};return r(t),e.geometry=t._cachedGeometry,e.material=t._cachedMaterials,e}reset(){this.triangleSplitter.reset()}}const Sr={subtraction:a,reverseSubtraction:c,addition:s,difference:u,intersection:l};function Vr(t){let e=null;return t instanceof fn?(t.updateMatrixWorld(),e=t):t.traverse((t=>{t.updateMatrixWorld(),!e&&t instanceof fn&&(e=t)})),e}const Pr=o.createContext(null),Ir=o.forwardRef(((t,e)=>{let{children:n,computeVertexNormals:r=!1,useGroups:i=!1,showOperations:a=!1}=t;const c=o.useRef(null),l=o.useRef(null),u=o.useMemo((()=>Object.assign(new Mr,{useGroups:i})),[i]),d=o.useCallback((()=>{try{const i=l.current.children.slice();if(i.length>0){(o=c.current).dispose(),o.attributes={},o.groups=[],o.boundsTree=o.index=o.boundingBox=o.boundingSphere=null,o.drawRange={start:0,count:1/0},l.current.matrixWorld.identity();let a=Vr(i.shift());if(a){for(var t,e,n;i.length;){const t=Vr(i.shift());t&&(a=u.evaluate(a,t,Sr[t.operator]||s))}c.current.boundsTree=a.geometry.boundsTree,c.current.index=a.geometry.index,c.current.attributes=a.geometry.attributes,c.current.groups=a.geometry.groups,c.current.drawRange=a.geometry.drawRange,u.useGroups&&null!=(t=c.current)&&null!=(e=t.__r3f)&&null!=(n=e.parent)&&n.material&&(c.current.__r3f.parent.material=a.material),r&&c.current.computeVertexNormals()}}}catch(i){console.log(i)}var o}),[r,u]),f=o.useMemo((()=>({computeVertexNormals:r,showOperations:a,useGroups:i,update:d})),[r,a,i]);return o.useLayoutEffect((()=>{d()})),o.useImperativeHandle(e,(()=>({geometry:c.current,operations:l.current,...f})),[f]),o.createElement(o.Fragment,null,o.createElement("group",{matrixAutoUpdate:!1,ref:l},o.createElement(Pr.Provider,{value:f},n)),o.createElement("bufferGeometry",{ref:c}))})),zr=o.forwardRef(((t,e)=>{let{showOperation:n=!1,operator:s="addition",...a}=t;(0,i.e)({Brush:fn});const{showOperations:c}=o.useContext(Pr);return o.createElement("brush",(0,r.A)({operator:s,raycast:()=>null,visible:n||c,ref:e},a))})),Er=o.forwardRef(((t,e)=>o.createElement(zr,(0,r.A)({ref:e,operator:"subtraction"},t))))}}]);
//# sourceMappingURL=569.e19a2dfd.chunk.js.map