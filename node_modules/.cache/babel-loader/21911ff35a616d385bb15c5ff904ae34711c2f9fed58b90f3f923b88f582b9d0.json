{"ast":null,"code":"import { Ray, Matrix4, DoubleSide, Vector3, Vector4, Triangle, Line3 } from 'three';\nimport { IntersectionMap } from '../IntersectionMap.js';\nimport { ADDITION, SUBTRACTION, REVERSE_SUBTRACTION, INTERSECTION, DIFFERENCE, HOLLOW_SUBTRACTION, HOLLOW_INTERSECTION } from '../constants.js';\nimport { isTriDegenerate } from '../utils/triangleUtils.js';\nconst _ray = new Ray();\nconst _matrix = new Matrix4();\nconst _tri = new Triangle();\nconst _vec3 = new Vector3();\nconst _vec4a = new Vector4();\nconst _vec4b = new Vector4();\nconst _vec4c = new Vector4();\nconst _vec4_0 = new Vector4();\nconst _vec4_1 = new Vector4();\nconst _vec4_2 = new Vector4();\nconst _edge = new Line3();\nconst _normal = new Vector3();\nconst JITTER_EPSILON = 1e-8;\nconst OFFSET_EPSILON = 1e-15;\nexport const BACK_SIDE = -1;\nexport const FRONT_SIDE = 1;\nexport const COPLANAR_OPPOSITE = -2;\nexport const COPLANAR_ALIGNED = 2;\nexport const INVERT_TRI = 0;\nexport const ADD_TRI = 1;\nexport const SKIP_TRI = 2;\nconst FLOATING_COPLANAR_EPSILON = 1e-14;\nlet _debugContext = null;\nexport function setDebugContext(debugData) {\n  _debugContext = debugData;\n}\nexport function getHitSide(tri, bvh) {\n  tri.getMidpoint(_ray.origin);\n  tri.getNormal(_ray.direction);\n  const hit = bvh.raycastFirst(_ray, DoubleSide);\n  const hitBackSide = Boolean(hit && _ray.direction.dot(hit.face.normal) > 0);\n  return hitBackSide ? BACK_SIDE : FRONT_SIDE;\n}\nexport function getHitSideWithCoplanarCheck(tri, bvh) {\n  // random function that returns [ - 0.5, 0.5 ];\n  function rand() {\n    return Math.random() - 0.5;\n  }\n\n  // get the ray the check the triangle for\n  tri.getNormal(_normal);\n  _ray.direction.copy(_normal);\n  tri.getMidpoint(_ray.origin);\n  const total = 3;\n  let count = 0;\n  let minDistance = Infinity;\n  for (let i = 0; i < total; i++) {\n    // jitter the ray slightly\n    _ray.direction.x += rand() * JITTER_EPSILON;\n    _ray.direction.y += rand() * JITTER_EPSILON;\n    _ray.direction.z += rand() * JITTER_EPSILON;\n\n    // and invert it so we can account for floating point error by checking both directions\n    // to catch coplanar distances\n    _ray.direction.multiplyScalar(-1);\n\n    // check if the ray hit the backside\n    const hit = bvh.raycastFirst(_ray, DoubleSide);\n    let hitBackSide = Boolean(hit && _ray.direction.dot(hit.face.normal) > 0);\n    if (hitBackSide) {\n      count++;\n    }\n    if (hit !== null) {\n      minDistance = Math.min(minDistance, hit.distance);\n    }\n\n    // if we're right up against another face then we're coplanar\n    if (minDistance <= OFFSET_EPSILON) {\n      return hit.face.normal.dot(_normal) > 0 ? COPLANAR_ALIGNED : COPLANAR_OPPOSITE;\n    }\n\n    // if our current casts meet our requirements then early out\n    if (count / total > 0.5 || (i - count + 1) / total > 0.5) {\n      break;\n    }\n  }\n  return count / total > 0.5 ? BACK_SIDE : FRONT_SIDE;\n}\n\n// returns the intersected triangles and returns objects mapping triangle indices to\n// the other triangles intersected\nexport function collectIntersectingTriangles(a, b) {\n  const aIntersections = new IntersectionMap();\n  const bIntersections = new IntersectionMap();\n  _matrix.copy(a.matrixWorld).invert().multiply(b.matrixWorld);\n  a.geometry.boundsTree.bvhcast(b.geometry.boundsTree, _matrix, {\n    intersectsTriangles(triangleA, triangleB, ia, ib) {\n      if (!isTriDegenerate(triangleA) && !isTriDegenerate(triangleB)) {\n        // due to floating point error it's possible that we can have two overlapping, coplanar triangles\n        // that are a _tiny_ fraction of a value away from each other. If we find that case then check the\n        // distance between triangles and if it's small enough consider them intersecting.\n        let intersected = triangleA.intersectsTriangle(triangleB, _edge, true);\n        if (!intersected) {\n          const pa = triangleA.plane;\n          const pb = triangleB.plane;\n          const na = pa.normal;\n          const nb = pb.normal;\n          if (na.dot(nb) === 1 && Math.abs(pa.constant - pb.constant) < FLOATING_COPLANAR_EPSILON) {\n            intersected = true;\n          }\n        }\n        if (intersected) {\n          let va = a.geometry.boundsTree.resolveTriangleIndex(ia);\n          let vb = b.geometry.boundsTree.resolveTriangleIndex(ib);\n          aIntersections.add(va, vb);\n          bIntersections.add(vb, va);\n          if (_debugContext) {\n            _debugContext.addEdge(_edge);\n            _debugContext.addIntersectingTriangles(ia, triangleA, ib, triangleB);\n          }\n        }\n      }\n      return false;\n    }\n  });\n  return {\n    aIntersections,\n    bIntersections\n  };\n}\n\n// Add the barycentric interpolated values fro the triangle into the new attribute data\nexport function appendAttributeFromTriangle(triIndex, baryCoordTri, geometry, matrixWorld, normalMatrix, attributeData, invert = false) {\n  const attributes = geometry.attributes;\n  const indexAttr = geometry.index;\n  const i3 = triIndex * 3;\n  const i0 = indexAttr.getX(i3 + 0);\n  const i1 = indexAttr.getX(i3 + 1);\n  const i2 = indexAttr.getX(i3 + 2);\n  for (const key in attributeData) {\n    // check if the key we're asking for is in the geometry at all\n    const attr = attributes[key];\n    const arr = attributeData[key];\n    if (!(key in attributes)) {\n      throw new Error(`CSG Operations: Attribute ${key} not available on geometry.`);\n    }\n\n    // handle normals and positions specially because they require transforming\n    // TODO: handle tangents\n    const itemSize = attr.itemSize;\n    if (key === 'position') {\n      _tri.a.fromBufferAttribute(attr, i0).applyMatrix4(matrixWorld);\n      _tri.b.fromBufferAttribute(attr, i1).applyMatrix4(matrixWorld);\n      _tri.c.fromBufferAttribute(attr, i2).applyMatrix4(matrixWorld);\n      pushBarycoordInterpolatedValues(_tri.a, _tri.b, _tri.c, baryCoordTri, 3, arr, invert);\n    } else if (key === 'normal') {\n      _tri.a.fromBufferAttribute(attr, i0).applyNormalMatrix(normalMatrix);\n      _tri.b.fromBufferAttribute(attr, i1).applyNormalMatrix(normalMatrix);\n      _tri.c.fromBufferAttribute(attr, i2).applyNormalMatrix(normalMatrix);\n      if (invert) {\n        _tri.a.multiplyScalar(-1);\n        _tri.b.multiplyScalar(-1);\n        _tri.c.multiplyScalar(-1);\n      }\n      pushBarycoordInterpolatedValues(_tri.a, _tri.b, _tri.c, baryCoordTri, 3, arr, invert, true);\n    } else {\n      _vec4a.fromBufferAttribute(attr, i0);\n      _vec4b.fromBufferAttribute(attr, i1);\n      _vec4c.fromBufferAttribute(attr, i2);\n      pushBarycoordInterpolatedValues(_vec4a, _vec4b, _vec4c, baryCoordTri, itemSize, arr, invert);\n    }\n  }\n}\n\n// Append all the values of the attributes for the triangle onto the new attribute arrays\nexport function appendAttributesFromIndices(i0, i1, i2, attributes, matrixWorld, normalMatrix, attributeData, invert = false) {\n  appendAttributeFromIndex(i0, attributes, matrixWorld, normalMatrix, attributeData, invert);\n  appendAttributeFromIndex(invert ? i2 : i1, attributes, matrixWorld, normalMatrix, attributeData, invert);\n  appendAttributeFromIndex(invert ? i1 : i2, attributes, matrixWorld, normalMatrix, attributeData, invert);\n}\n\n// Returns the triangle to add when performing an operation\nexport function getOperationAction(operation, hitSide, invert = false) {\n  switch (operation) {\n    case ADDITION:\n      if (hitSide === FRONT_SIDE || hitSide === COPLANAR_ALIGNED && !invert) {\n        return ADD_TRI;\n      }\n      break;\n    case SUBTRACTION:\n      if (invert) {\n        if (hitSide === BACK_SIDE) {\n          return INVERT_TRI;\n        }\n      } else {\n        if (hitSide === FRONT_SIDE || hitSide === COPLANAR_OPPOSITE) {\n          return ADD_TRI;\n        }\n      }\n      break;\n    case REVERSE_SUBTRACTION:\n      if (invert) {\n        if (hitSide === FRONT_SIDE || hitSide === COPLANAR_OPPOSITE) {\n          return ADD_TRI;\n        }\n      } else {\n        if (hitSide === BACK_SIDE) {\n          return INVERT_TRI;\n        }\n      }\n      break;\n    case DIFFERENCE:\n      if (hitSide === BACK_SIDE) {\n        return INVERT_TRI;\n      } else if (hitSide === FRONT_SIDE) {\n        return ADD_TRI;\n      }\n      break;\n    case INTERSECTION:\n      if (hitSide === BACK_SIDE || hitSide === COPLANAR_ALIGNED && !invert) {\n        return ADD_TRI;\n      }\n      break;\n    case HOLLOW_SUBTRACTION:\n      if (!invert && (hitSide === FRONT_SIDE || hitSide === COPLANAR_OPPOSITE)) {\n        return ADD_TRI;\n      }\n      break;\n    case HOLLOW_INTERSECTION:\n      if (!invert && (hitSide === BACK_SIDE || hitSide === COPLANAR_ALIGNED)) {\n        return ADD_TRI;\n      }\n      break;\n    default:\n      throw new Error(`Unrecognized CSG operation enum \"${operation}\".`);\n  }\n  return SKIP_TRI;\n}\n\n// takes a set of barycentric values in the form of a triangle, a set of vectors, number of components,\n// and whether to invert the result and pushes the new values onto the provided attribute array\nfunction pushBarycoordInterpolatedValues(v0, v1, v2, baryCoordTri, itemSize, attrArr, invert = false, normalize = false) {\n  // adds the appropriate number of values for the vector onto the array\n  const addValues = v => {\n    attrArr.push(v.x);\n    if (itemSize > 1) attrArr.push(v.y);\n    if (itemSize > 2) attrArr.push(v.z);\n    if (itemSize > 3) attrArr.push(v.w);\n  };\n\n  // barycentric interpolate the first component\n  _vec4_0.set(0, 0, 0, 0).addScaledVector(v0, baryCoordTri.a.x).addScaledVector(v1, baryCoordTri.a.y).addScaledVector(v2, baryCoordTri.a.z);\n  _vec4_1.set(0, 0, 0, 0).addScaledVector(v0, baryCoordTri.b.x).addScaledVector(v1, baryCoordTri.b.y).addScaledVector(v2, baryCoordTri.b.z);\n  _vec4_2.set(0, 0, 0, 0).addScaledVector(v0, baryCoordTri.c.x).addScaledVector(v1, baryCoordTri.c.y).addScaledVector(v2, baryCoordTri.c.z);\n  if (normalize) {\n    _vec4_0.normalize();\n    _vec4_1.normalize();\n    _vec4_2.normalize();\n  }\n\n  // if the face is inverted then add the values in an inverted order\n  addValues(_vec4_0);\n  if (invert) {\n    addValues(_vec4_2);\n    addValues(_vec4_1);\n  } else {\n    addValues(_vec4_1);\n    addValues(_vec4_2);\n  }\n}\n\n// Adds the values for the given vertex index onto the new attribute arrays\nfunction appendAttributeFromIndex(index, attributes, matrixWorld, normalMatrix, attributeData, invert = false) {\n  for (const key in attributeData) {\n    // check if the key we're asking for is in the geometry at all\n    const attr = attributes[key];\n    const arr = attributeData[key];\n    if (!(key in attributes)) {\n      throw new Error(`CSG Operations: Attribute ${key} no available on geometry.`);\n    }\n\n    // specially handle the position and normal attributes because they require transforms\n    // TODO: handle tangents\n    const itemSize = attr.itemSize;\n    if (key === 'position') {\n      _vec3.fromBufferAttribute(attr, index).applyMatrix4(matrixWorld);\n      arr.push(_vec3.x, _vec3.y, _vec3.z);\n    } else if (key === 'normal') {\n      _vec3.fromBufferAttribute(attr, index).applyNormalMatrix(normalMatrix);\n      if (invert) {\n        _vec3.multiplyScalar(-1);\n      }\n      arr.push(_vec3.x, _vec3.y, _vec3.z);\n    } else {\n      arr.push(attr.getX(index));\n      if (itemSize > 1) arr.push(attr.getY(index));\n      if (itemSize > 2) arr.push(attr.getZ(index));\n      if (itemSize > 3) arr.push(attr.getW(index));\n    }\n  }\n}","map":{"version":3,"names":["Ray","Matrix4","DoubleSide","Vector3","Vector4","Triangle","Line3","IntersectionMap","ADDITION","SUBTRACTION","REVERSE_SUBTRACTION","INTERSECTION","DIFFERENCE","HOLLOW_SUBTRACTION","HOLLOW_INTERSECTION","isTriDegenerate","_ray","_matrix","_tri","_vec3","_vec4a","_vec4b","_vec4c","_vec4_0","_vec4_1","_vec4_2","_edge","_normal","JITTER_EPSILON","OFFSET_EPSILON","BACK_SIDE","FRONT_SIDE","COPLANAR_OPPOSITE","COPLANAR_ALIGNED","INVERT_TRI","ADD_TRI","SKIP_TRI","FLOATING_COPLANAR_EPSILON","_debugContext","setDebugContext","debugData","getHitSide","tri","bvh","getMidpoint","origin","getNormal","direction","hit","raycastFirst","hitBackSide","Boolean","dot","face","normal","getHitSideWithCoplanarCheck","rand","Math","random","copy","total","count","minDistance","Infinity","i","x","y","z","multiplyScalar","min","distance","collectIntersectingTriangles","a","b","aIntersections","bIntersections","matrixWorld","invert","multiply","geometry","boundsTree","bvhcast","intersectsTriangles","triangleA","triangleB","ia","ib","intersected","intersectsTriangle","pa","plane","pb","na","nb","abs","constant","va","resolveTriangleIndex","vb","add","addEdge","addIntersectingTriangles","appendAttributeFromTriangle","triIndex","baryCoordTri","normalMatrix","attributeData","attributes","indexAttr","index","i3","i0","getX","i1","i2","key","attr","arr","Error","itemSize","fromBufferAttribute","applyMatrix4","c","pushBarycoordInterpolatedValues","applyNormalMatrix","appendAttributesFromIndices","appendAttributeFromIndex","getOperationAction","operation","hitSide","v0","v1","v2","attrArr","normalize","addValues","v","push","w","set","addScaledVector","getY","getZ","getW"],"sources":["/Users/ratseevtimur/Documents/Test-Projects/door-3d/node_modules/three-bvh-csg/src/core/operations/operationsUtils.js"],"sourcesContent":["import { Ray, Matrix4, DoubleSide, Vector3, Vector4, Triangle, Line3 } from 'three';\nimport { IntersectionMap } from '../IntersectionMap.js';\nimport {\n\tADDITION,\n\tSUBTRACTION,\n\tREVERSE_SUBTRACTION,\n\tINTERSECTION,\n\tDIFFERENCE,\n\tHOLLOW_SUBTRACTION,\n\tHOLLOW_INTERSECTION,\n} from '../constants.js';\nimport { isTriDegenerate } from '../utils/triangleUtils.js';\n\nconst _ray = new Ray();\nconst _matrix = new Matrix4();\nconst _tri = new Triangle();\nconst _vec3 = new Vector3();\nconst _vec4a = new Vector4();\nconst _vec4b = new Vector4();\nconst _vec4c = new Vector4();\nconst _vec4_0 = new Vector4();\nconst _vec4_1 = new Vector4();\nconst _vec4_2 = new Vector4();\nconst _edge = new Line3();\nconst _normal = new Vector3();\nconst JITTER_EPSILON = 1e-8;\nconst OFFSET_EPSILON = 1e-15;\n\nexport const BACK_SIDE = - 1;\nexport const FRONT_SIDE = 1;\nexport const COPLANAR_OPPOSITE = - 2;\nexport const COPLANAR_ALIGNED = 2;\n\nexport const INVERT_TRI = 0;\nexport const ADD_TRI = 1;\nexport const SKIP_TRI = 2;\n\nconst FLOATING_COPLANAR_EPSILON = 1e-14;\n\nlet _debugContext = null;\nexport function setDebugContext( debugData ) {\n\n\t_debugContext = debugData;\n\n}\n\nexport function getHitSide( tri, bvh ) {\n\n\ttri.getMidpoint( _ray.origin );\n\ttri.getNormal( _ray.direction );\n\n\tconst hit = bvh.raycastFirst( _ray, DoubleSide );\n\tconst hitBackSide = Boolean( hit && _ray.direction.dot( hit.face.normal ) > 0 );\n\treturn hitBackSide ? BACK_SIDE : FRONT_SIDE;\n\n}\n\nexport function getHitSideWithCoplanarCheck( tri, bvh ) {\n\n\t// random function that returns [ - 0.5, 0.5 ];\n\tfunction rand() {\n\n\t\treturn Math.random() - 0.5;\n\n\t}\n\n\t// get the ray the check the triangle for\n\ttri.getNormal( _normal );\n\t_ray.direction.copy( _normal );\n\ttri.getMidpoint( _ray.origin );\n\n\tconst total = 3;\n\tlet count = 0;\n\tlet minDistance = Infinity;\n\tfor ( let i = 0; i < total; i ++ ) {\n\n\t\t// jitter the ray slightly\n\t\t_ray.direction.x += rand() * JITTER_EPSILON;\n\t\t_ray.direction.y += rand() * JITTER_EPSILON;\n\t\t_ray.direction.z += rand() * JITTER_EPSILON;\n\n\t\t// and invert it so we can account for floating point error by checking both directions\n\t\t// to catch coplanar distances\n\t\t_ray.direction.multiplyScalar( - 1 );\n\n\t\t// check if the ray hit the backside\n\t\tconst hit = bvh.raycastFirst( _ray, DoubleSide );\n\t\tlet hitBackSide = Boolean( hit && _ray.direction.dot( hit.face.normal ) > 0 );\n\t\tif ( hitBackSide ) {\n\n\t\t\tcount ++;\n\n\t\t}\n\n\t\tif ( hit !== null ) {\n\n\t\t\tminDistance = Math.min( minDistance, hit.distance );\n\n\t\t}\n\n\t\t// if we're right up against another face then we're coplanar\n\t\tif ( minDistance <= OFFSET_EPSILON ) {\n\n\t\t\treturn hit.face.normal.dot( _normal ) > 0 ? COPLANAR_ALIGNED : COPLANAR_OPPOSITE;\n\n\t\t}\n\n\t\t// if our current casts meet our requirements then early out\n\t\tif ( count / total > 0.5 || ( i - count + 1 ) / total > 0.5 ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\treturn count / total > 0.5 ? BACK_SIDE : FRONT_SIDE;\n\n}\n\n// returns the intersected triangles and returns objects mapping triangle indices to\n// the other triangles intersected\nexport function collectIntersectingTriangles( a, b ) {\n\n\tconst aIntersections = new IntersectionMap();\n\tconst bIntersections = new IntersectionMap();\n\n\t_matrix\n\t\t.copy( a.matrixWorld )\n\t\t.invert()\n\t\t.multiply( b.matrixWorld );\n\n\ta.geometry.boundsTree.bvhcast( b.geometry.boundsTree, _matrix, {\n\n\t\tintersectsTriangles( triangleA, triangleB, ia, ib ) {\n\n\t\t\tif ( ! isTriDegenerate( triangleA ) && ! isTriDegenerate( triangleB ) ) {\n\n\t\t\t\t// due to floating point error it's possible that we can have two overlapping, coplanar triangles\n\t\t\t\t// that are a _tiny_ fraction of a value away from each other. If we find that case then check the\n\t\t\t\t// distance between triangles and if it's small enough consider them intersecting.\n\t\t\t\tlet intersected = triangleA.intersectsTriangle( triangleB, _edge, true );\n\t\t\t\tif ( ! intersected ) {\n\n\t\t\t\t\tconst pa = triangleA.plane;\n\t\t\t\t\tconst pb = triangleB.plane;\n\t\t\t\t\tconst na = pa.normal;\n\t\t\t\t\tconst nb = pb.normal;\n\n\t\t\t\t\tif ( na.dot( nb ) === 1 && Math.abs( pa.constant - pb.constant ) < FLOATING_COPLANAR_EPSILON ) {\n\n\t\t\t\t\t\tintersected = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( intersected ) {\n\n\t\t\t\t\tlet va = a.geometry.boundsTree.resolveTriangleIndex( ia );\n\t\t\t\t\tlet vb = b.geometry.boundsTree.resolveTriangleIndex( ib );\n\t\t\t\t\taIntersections.add( va, vb );\n\t\t\t\t\tbIntersections.add( vb, va );\n\n\t\t\t\t\tif ( _debugContext ) {\n\n\t\t\t\t\t\t_debugContext.addEdge( _edge );\n\t\t\t\t\t\t_debugContext.addIntersectingTriangles( ia, triangleA, ib, triangleB );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\t} );\n\n\treturn { aIntersections, bIntersections };\n\n}\n\n// Add the barycentric interpolated values fro the triangle into the new attribute data\nexport function appendAttributeFromTriangle(\n\ttriIndex,\n\tbaryCoordTri,\n\tgeometry,\n\tmatrixWorld,\n\tnormalMatrix,\n\tattributeData,\n\tinvert = false,\n) {\n\n\tconst attributes = geometry.attributes;\n\tconst indexAttr = geometry.index;\n\tconst i3 = triIndex * 3;\n\tconst i0 = indexAttr.getX( i3 + 0 );\n\tconst i1 = indexAttr.getX( i3 + 1 );\n\tconst i2 = indexAttr.getX( i3 + 2 );\n\n\tfor ( const key in attributeData ) {\n\n\t\t// check if the key we're asking for is in the geometry at all\n\t\tconst attr = attributes[ key ];\n\t\tconst arr = attributeData[ key ];\n\t\tif ( ! ( key in attributes ) ) {\n\n\t\t\tthrow new Error( `CSG Operations: Attribute ${ key } not available on geometry.` );\n\n\t\t}\n\n\t\t// handle normals and positions specially because they require transforming\n\t\t// TODO: handle tangents\n\t\tconst itemSize = attr.itemSize;\n\t\tif ( key === 'position' ) {\n\n\t\t\t_tri.a.fromBufferAttribute( attr, i0 ).applyMatrix4( matrixWorld );\n\t\t\t_tri.b.fromBufferAttribute( attr, i1 ).applyMatrix4( matrixWorld );\n\t\t\t_tri.c.fromBufferAttribute( attr, i2 ).applyMatrix4( matrixWorld );\n\n\t\t\tpushBarycoordInterpolatedValues( _tri.a, _tri.b, _tri.c, baryCoordTri, 3, arr, invert );\n\n\t\t} else if ( key === 'normal' ) {\n\n\t\t\t_tri.a.fromBufferAttribute( attr, i0 ).applyNormalMatrix( normalMatrix );\n\t\t\t_tri.b.fromBufferAttribute( attr, i1 ).applyNormalMatrix( normalMatrix );\n\t\t\t_tri.c.fromBufferAttribute( attr, i2 ).applyNormalMatrix( normalMatrix );\n\n\t\t\tif ( invert ) {\n\n\t\t\t\t_tri.a.multiplyScalar( - 1 );\n\t\t\t\t_tri.b.multiplyScalar( - 1 );\n\t\t\t\t_tri.c.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t\tpushBarycoordInterpolatedValues( _tri.a, _tri.b, _tri.c, baryCoordTri, 3, arr, invert, true );\n\n\t\t} else {\n\n\t\t\t_vec4a.fromBufferAttribute( attr, i0 );\n\t\t\t_vec4b.fromBufferAttribute( attr, i1 );\n\t\t\t_vec4c.fromBufferAttribute( attr, i2 );\n\n\t\t\tpushBarycoordInterpolatedValues( _vec4a, _vec4b, _vec4c, baryCoordTri, itemSize, arr, invert );\n\n\t\t}\n\n\t}\n\n}\n\n// Append all the values of the attributes for the triangle onto the new attribute arrays\nexport function appendAttributesFromIndices(\n\ti0,\n\ti1,\n\ti2,\n\tattributes,\n\tmatrixWorld,\n\tnormalMatrix,\n\tattributeData,\n\tinvert = false,\n) {\n\n\tappendAttributeFromIndex( i0, attributes, matrixWorld, normalMatrix, attributeData, invert );\n\tappendAttributeFromIndex( invert ? i2 : i1, attributes, matrixWorld, normalMatrix, attributeData, invert );\n\tappendAttributeFromIndex( invert ? i1 : i2, attributes, matrixWorld, normalMatrix, attributeData, invert );\n\n}\n\n// Returns the triangle to add when performing an operation\nexport function getOperationAction( operation, hitSide, invert = false ) {\n\n\tswitch ( operation ) {\n\n\t\tcase ADDITION:\n\n\t\t\tif ( hitSide === FRONT_SIDE || ( hitSide === COPLANAR_ALIGNED && ! invert ) ) {\n\n\t\t\t\treturn ADD_TRI;\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase SUBTRACTION:\n\n\t\t\tif ( invert ) {\n\n\t\t\t\tif ( hitSide === BACK_SIDE ) {\n\n\t\t\t\t\treturn INVERT_TRI;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( hitSide === FRONT_SIDE || hitSide === COPLANAR_OPPOSITE ) {\n\n\t\t\t\t\treturn ADD_TRI;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase REVERSE_SUBTRACTION:\n\n\t\t\tif ( invert ) {\n\n\t\t\t\tif ( hitSide === FRONT_SIDE || hitSide === COPLANAR_OPPOSITE ) {\n\n\t\t\t\t\treturn ADD_TRI;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( hitSide === BACK_SIDE ) {\n\n\t\t\t\t\treturn INVERT_TRI;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase DIFFERENCE:\n\n\t\t\tif ( hitSide === BACK_SIDE ) {\n\n\t\t\t\treturn INVERT_TRI;\n\n\t\t\t} else if ( hitSide === FRONT_SIDE ) {\n\n\t\t\t\treturn ADD_TRI;\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase INTERSECTION:\n\t\t\tif ( hitSide === BACK_SIDE || ( hitSide === COPLANAR_ALIGNED && ! invert ) ) {\n\n\t\t\t\treturn ADD_TRI;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase HOLLOW_SUBTRACTION:\n\t\t\tif ( ! invert && ( hitSide === FRONT_SIDE || hitSide === COPLANAR_OPPOSITE ) ) {\n\n\t\t\t\treturn ADD_TRI;\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase HOLLOW_INTERSECTION:\n\t\t\tif ( ! invert && ( hitSide === BACK_SIDE || hitSide === COPLANAR_ALIGNED ) ) {\n\n\t\t\t\treturn ADD_TRI;\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new Error( `Unrecognized CSG operation enum \"${ operation }\".` );\n\n\t}\n\n\treturn SKIP_TRI;\n\n}\n\n// takes a set of barycentric values in the form of a triangle, a set of vectors, number of components,\n// and whether to invert the result and pushes the new values onto the provided attribute array\nfunction pushBarycoordInterpolatedValues( v0, v1, v2, baryCoordTri, itemSize, attrArr, invert = false, normalize = false ) {\n\n\t// adds the appropriate number of values for the vector onto the array\n\tconst addValues = v => {\n\n\t\tattrArr.push( v.x );\n\t\tif ( itemSize > 1 ) attrArr.push( v.y );\n\t\tif ( itemSize > 2 ) attrArr.push( v.z );\n\t\tif ( itemSize > 3 ) attrArr.push( v.w );\n\n\t};\n\n\t// barycentric interpolate the first component\n\t_vec4_0.set( 0, 0, 0, 0 )\n\t\t.addScaledVector( v0, baryCoordTri.a.x )\n\t\t.addScaledVector( v1, baryCoordTri.a.y )\n\t\t.addScaledVector( v2, baryCoordTri.a.z );\n\n\t_vec4_1.set( 0, 0, 0, 0 )\n\t\t.addScaledVector( v0, baryCoordTri.b.x )\n\t\t.addScaledVector( v1, baryCoordTri.b.y )\n\t\t.addScaledVector( v2, baryCoordTri.b.z );\n\n\t_vec4_2.set( 0, 0, 0, 0 )\n\t\t.addScaledVector( v0, baryCoordTri.c.x )\n\t\t.addScaledVector( v1, baryCoordTri.c.y )\n\t\t.addScaledVector( v2, baryCoordTri.c.z );\n\n\tif ( normalize ) {\n\n\t\t_vec4_0.normalize();\n\t\t_vec4_1.normalize();\n\t\t_vec4_2.normalize();\n\n\t}\n\n\t// if the face is inverted then add the values in an inverted order\n\taddValues( _vec4_0 );\n\n\tif ( invert ) {\n\n\t\taddValues( _vec4_2 );\n\t\taddValues( _vec4_1 );\n\n\t} else {\n\n\t\taddValues( _vec4_1 );\n\t\taddValues( _vec4_2 );\n\n\t}\n\n}\n\n// Adds the values for the given vertex index onto the new attribute arrays\nfunction appendAttributeFromIndex(\n\tindex,\n\tattributes,\n\tmatrixWorld,\n\tnormalMatrix,\n\tattributeData,\n\tinvert = false,\n) {\n\n\tfor ( const key in attributeData ) {\n\n\t\t// check if the key we're asking for is in the geometry at all\n\t\tconst attr = attributes[ key ];\n\t\tconst arr = attributeData[ key ];\n\t\tif ( ! ( key in attributes ) ) {\n\n\t\t\tthrow new Error( `CSG Operations: Attribute ${ key } no available on geometry.` );\n\n\t\t}\n\n\t\t// specially handle the position and normal attributes because they require transforms\n\t\t// TODO: handle tangents\n\t\tconst itemSize = attr.itemSize;\n\t\tif ( key === 'position' ) {\n\n\t\t\t_vec3.fromBufferAttribute( attr, index ).applyMatrix4( matrixWorld );\n\t\t\tarr.push( _vec3.x, _vec3.y, _vec3.z );\n\n\t\t} else if ( key === 'normal' ) {\n\n\t\t\t_vec3.fromBufferAttribute( attr, index ).applyNormalMatrix( normalMatrix );\n\t\t\tif ( invert ) {\n\n\t\t\t\t_vec3.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t\tarr.push( _vec3.x, _vec3.y, _vec3.z );\n\n\t\t} else {\n\n\t\t\tarr.push( attr.getX( index ) );\n\t\t\tif ( itemSize > 1 ) arr.push( attr.getY( index ) );\n\t\t\tif ( itemSize > 2 ) arr.push( attr.getZ( index ) );\n\t\t\tif ( itemSize > 3 ) arr.push( attr.getW( index ) );\n\n\t\t}\n\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}