{"ast":null,"code":"import { Vector3 } from 'three';\nconst DEGENERATE_EPSILON = 1e-8;\nconst _tempVec = new Vector3();\nexport function toTriIndex(v) {\n  return ~~(v / 3);\n}\nexport function toEdgeIndex(v) {\n  return v % 3;\n}\nexport function sortEdgeFunc(a, b) {\n  return a.start - b.start;\n}\nexport function getProjectedDistance(ray, vec) {\n  return _tempVec.subVectors(vec, ray.origin).dot(ray.direction);\n}\nexport function hasOverlaps(arr) {\n  arr = [...arr].sort(sortEdgeFunc);\n  for (let i = 0, l = arr.length; i < l - 1; i++) {\n    const info0 = arr[i];\n    const info1 = arr[i + 1];\n    if (info1.start < info0.end && Math.abs(info1.start - info0.end) > 1e-5) {\n      return true;\n    }\n  }\n  return false;\n}\nexport function getEdgeSetLength(arr) {\n  let tot = 0;\n  arr.forEach(_ref => {\n    let {\n      start,\n      end\n    } = _ref;\n    return tot += end - start;\n  });\n  return tot;\n}\nexport function matchEdges(forward, reverse, disjointConnectivityMap) {\n  let eps = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEGENERATE_EPSILON;\n  forward.sort(sortEdgeFunc);\n  reverse.sort(sortEdgeFunc);\n  for (let i = 0; i < forward.length; i++) {\n    const e0 = forward[i];\n    for (let o = 0; o < reverse.length; o++) {\n      const e1 = reverse[o];\n      if (e1.start > e0.end) {\n\n        // e2 is completely after e1\n        // break;\n\n        // NOTE: there are cases where there are overlaps due to precision issues or\n        // thin / degenerate triangles. Assuming the sibling side has the same issues\n        // we let the matching work here. Long term we should remove the degenerate\n        // triangles before this.\n      } else if (e0.end < e1.start || e1.end < e0.start) {\n        // e1 is completely before e2\n        continue;\n      } else if (e0.start <= e1.start && e0.end >= e1.end) {\n        // e1 is larger than and e2 is completely within e1\n        if (!areDistancesDegenerate(e1.end, e0.end)) {\n          forward.splice(i + 1, 0, {\n            start: e1.end,\n            end: e0.end,\n            index: e0.index\n          });\n        }\n        e0.end = e1.start;\n        e1.start = 0;\n        e1.end = 0;\n      } else if (e0.start >= e1.start && e0.end <= e1.end) {\n        // e2 is larger than and e1 is completely within e2\n        if (!areDistancesDegenerate(e0.end, e1.end)) {\n          reverse.splice(o + 1, 0, {\n            start: e0.end,\n            end: e1.end,\n            index: e1.index\n          });\n        }\n        e1.end = e0.start;\n        e0.start = 0;\n        e0.end = 0;\n      } else if (e0.start <= e1.start && e0.end <= e1.end) {\n        // e1 overlaps e2 at the beginning\n        const tmp = e0.end;\n        e0.end = e1.start;\n        e1.start = tmp;\n      } else if (e0.start >= e1.start && e0.end >= e1.end) {\n        // e1 overlaps e2 at the end\n        const tmp = e1.end;\n        e1.end = e0.start;\n        e0.start = tmp;\n      } else {\n        throw new Error();\n      }\n\n      // Add the connectivity information\n      if (!disjointConnectivityMap.has(e0.index)) {\n        disjointConnectivityMap.set(e0.index, []);\n      }\n      if (!disjointConnectivityMap.has(e1.index)) {\n        disjointConnectivityMap.set(e1.index, []);\n      }\n      disjointConnectivityMap.get(e0.index).push(e1.index);\n      disjointConnectivityMap.get(e1.index).push(e0.index);\n      if (isEdgeDegenerate(e1)) {\n        reverse.splice(o, 1);\n        o--;\n      }\n      if (isEdgeDegenerate(e0)) {\n        // and if we have to remove the current original edge then exit this loop\n        // so we can work on the next one\n        forward.splice(i, 1);\n        i--;\n        break;\n      }\n    }\n  }\n  cleanUpEdgeSet(forward);\n  cleanUpEdgeSet(reverse);\n  function cleanUpEdgeSet(arr) {\n    for (let i = 0; i < arr.length; i++) {\n      if (isEdgeDegenerate(arr[i])) {\n        arr.splice(i, 1);\n        i--;\n      }\n    }\n  }\n  function areDistancesDegenerate(start, end) {\n    return Math.abs(end - start) < eps;\n  }\n  function isEdgeDegenerate(e) {\n    return Math.abs(e.end - e.start) < eps;\n  }\n}","map":{"version":3,"names":["Vector3","DEGENERATE_EPSILON","_tempVec","toTriIndex","v","toEdgeIndex","sortEdgeFunc","a","b","start","getProjectedDistance","ray","vec","subVectors","origin","dot","direction","hasOverlaps","arr","sort","i","l","length","info0","info1","end","Math","abs","getEdgeSetLength","tot","forEach","_ref","matchEdges","forward","reverse","disjointConnectivityMap","eps","arguments","undefined","e0","o","e1","areDistancesDegenerate","splice","index","tmp","Error","has","set","get","push","isEdgeDegenerate","cleanUpEdgeSet","e"],"sources":["/Users/ratseevtimur/Documents/Test-Projects/door-3d/node_modules/three-bvh-csg/src/core/utils/halfEdgeUtils.js"],"sourcesContent":["import { Vector3 } from 'three';\n\nconst DEGENERATE_EPSILON = 1e-8;\nconst _tempVec = new Vector3();\n\nexport function toTriIndex( v ) {\n\n\treturn ~ ~ ( v / 3 );\n\n}\n\nexport function toEdgeIndex( v ) {\n\n\treturn v % 3;\n\n}\n\nexport function sortEdgeFunc( a, b ) {\n\n\treturn a.start - b.start;\n\n}\n\nexport function getProjectedDistance( ray, vec ) {\n\n\treturn _tempVec.subVectors( vec, ray.origin ).dot( ray.direction );\n\n}\n\nexport function hasOverlaps( arr ) {\n\n\tarr = [ ...arr ].sort( sortEdgeFunc );\n\tfor ( let i = 0, l = arr.length; i < l - 1; i ++ ) {\n\n\t\tconst info0 = arr[ i ];\n\t\tconst info1 = arr[ i + 1 ];\n\n\t\tif ( info1.start < info0.end && Math.abs( info1.start - info0.end ) > 1e-5 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport function getEdgeSetLength( arr ) {\n\n\tlet tot = 0;\n\tarr.forEach( ( { start, end } ) => tot += end - start );\n\treturn tot;\n\n}\n\nexport function matchEdges( forward, reverse, disjointConnectivityMap, eps = DEGENERATE_EPSILON ) {\n\n\tforward.sort( sortEdgeFunc );\n\treverse.sort( sortEdgeFunc );\n\n\tfor ( let i = 0; i < forward.length; i ++ ) {\n\n\t\tconst e0 = forward[ i ];\n\t\tfor ( let o = 0; o < reverse.length; o ++ ) {\n\n\t\t\tconst e1 = reverse[ o ];\n\t\t\tif ( e1.start > e0.end ) {\n\n\t\t\t\t// e2 is completely after e1\n\t\t\t\t// break;\n\n\t\t\t\t// NOTE: there are cases where there are overlaps due to precision issues or\n\t\t\t\t// thin / degenerate triangles. Assuming the sibling side has the same issues\n\t\t\t\t// we let the matching work here. Long term we should remove the degenerate\n\t\t\t\t// triangles before this.\n\n\t\t\t} else if ( e0.end < e1.start || e1.end < e0.start ) {\n\n\t\t\t\t// e1 is completely before e2\n\t\t\t\tcontinue;\n\n\t\t\t} else if ( e0.start <= e1.start && e0.end >= e1.end ) {\n\n\t\t\t\t// e1 is larger than and e2 is completely within e1\n\t\t\t\tif ( ! areDistancesDegenerate( e1.end, e0.end ) ) {\n\n\t\t\t\t\tforward.splice( i + 1, 0, {\n\t\t\t\t\t\tstart: e1.end,\n\t\t\t\t\t\tend: e0.end,\n\t\t\t\t\t\tindex: e0.index,\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\te0.end = e1.start;\n\n\t\t\t\te1.start = 0;\n\t\t\t\te1.end = 0;\n\n\t\t\t} else if ( e0.start >= e1.start && e0.end <= e1.end ) {\n\n\t\t\t\t// e2 is larger than and e1 is completely within e2\n\t\t\t\tif ( ! areDistancesDegenerate( e0.end, e1.end ) ) {\n\n\t\t\t\t\treverse.splice( o + 1, 0, {\n\t\t\t\t\t\tstart: e0.end,\n\t\t\t\t\t\tend: e1.end,\n\t\t\t\t\t\tindex: e1.index,\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\te1.end = e0.start;\n\n\t\t\t\te0.start = 0;\n\t\t\t\te0.end = 0;\n\n\t\t\t} else if ( e0.start <= e1.start && e0.end <= e1.end ) {\n\n\t\t\t\t// e1 overlaps e2 at the beginning\n\t\t\t\tconst tmp = e0.end;\n\t\t\t\te0.end = e1.start;\n\t\t\t\te1.start = tmp;\n\n\t\t\t} else if ( e0.start >= e1.start && e0.end >= e1.end ) {\n\n\t\t\t\t// e1 overlaps e2 at the end\n\t\t\t\tconst tmp = e1.end;\n\t\t\t\te1.end = e0.start;\n\t\t\t\te0.start = tmp;\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error();\n\n\t\t\t}\n\n\t\t\t// Add the connectivity information\n\t\t\tif ( ! disjointConnectivityMap.has( e0.index ) ) {\n\n\t\t\t\tdisjointConnectivityMap.set( e0.index, [] );\n\n\t\t\t}\n\n\t\t\tif ( ! disjointConnectivityMap.has( e1.index ) ) {\n\n\t\t\t\tdisjointConnectivityMap.set( e1.index, [] );\n\n\t\t\t}\n\n\t\t\tdisjointConnectivityMap\n\t\t\t\t.get( e0.index )\n\t\t\t\t.push( e1.index );\n\n\t\t\tdisjointConnectivityMap\n\t\t\t\t.get( e1.index )\n\t\t\t\t.push( e0.index );\n\n\t\t\tif ( isEdgeDegenerate( e1 ) ) {\n\n\t\t\t\treverse.splice( o, 1 );\n\t\t\t\to --;\n\n\t\t\t}\n\n\t\t\tif ( isEdgeDegenerate( e0 ) ) {\n\n\t\t\t\t// and if we have to remove the current original edge then exit this loop\n\t\t\t\t// so we can work on the next one\n\t\t\t\tforward.splice( i, 1 );\n\t\t\t\ti --;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcleanUpEdgeSet( forward );\n\tcleanUpEdgeSet( reverse );\n\n\tfunction cleanUpEdgeSet( arr ) {\n\n\t\tfor ( let i = 0; i < arr.length; i ++ ) {\n\n\t\t\tif ( isEdgeDegenerate( arr[ i ] ) ) {\n\n\t\t\t\tarr.splice( i, 1 );\n\t\t\t\ti --;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction areDistancesDegenerate( start, end ) {\n\n\t\treturn Math.abs( end - start ) < eps;\n\n\t}\n\n\tfunction isEdgeDegenerate( e ) {\n\n\t\treturn Math.abs( e.end - e.start ) < eps;\n\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}