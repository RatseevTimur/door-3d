{"ast":null,"code":"import { Triangle, Line3, Vector3, Plane } from 'three';\nimport { ExtendedTriangle } from 'three-mesh-bvh';\nimport { isTriDegenerate } from './utils/triangleUtils.js';\n\n// NOTE: these epsilons likely should all be the same since they're used to measure the\n// distance from a point to a plane which needs to be done consistently\nconst EPSILON = 1e-10;\nconst COPLANAR_EPSILON = 1e-10;\nconst PARALLEL_EPSILON = 1e-10;\nconst _edge = new Line3();\nconst _foundEdge = new Line3();\nconst _vec = new Vector3();\nconst _triangleNormal = new Vector3();\nconst _planeNormal = new Vector3();\nconst _plane = new Plane();\nconst _splittingTriangle = new ExtendedTriangle();\n\n// A pool of triangles to avoid unnecessary triangle creation\nclass TrianglePool {\n  constructor() {\n    this._pool = [];\n    this._index = 0;\n  }\n  getTriangle() {\n    if (this._index >= this._pool.length) {\n      this._pool.push(new Triangle());\n    }\n    return this._pool[this._index++];\n  }\n  clear() {\n    this._index = 0;\n  }\n  reset() {\n    this._pool.length = 0;\n    this._index = 0;\n  }\n}\n\n// Utility class for splitting triangles\nexport class TriangleSplitter {\n  constructor() {\n    this.trianglePool = new TrianglePool();\n    this.triangles = [];\n    this.normal = new Vector3();\n    this.coplanarTriangleUsed = false;\n  }\n\n  // initialize the class with a triangle\n  initialize(tri) {\n    this.reset();\n    const {\n      triangles,\n      trianglePool,\n      normal\n    } = this;\n    if (Array.isArray(tri)) {\n      for (let i = 0, l = tri.length; i < l; i++) {\n        const t = tri[i];\n        if (i === 0) {\n          t.getNormal(normal);\n        } else if (Math.abs(1.0 - t.getNormal(_vec).dot(normal)) > EPSILON) {\n          throw new Error('Triangle Splitter: Cannot initialize with triangles that have different normals.');\n        }\n        const poolTri = trianglePool.getTriangle();\n        poolTri.copy(t);\n        triangles.push(poolTri);\n      }\n    } else {\n      tri.getNormal(normal);\n      const poolTri = trianglePool.getTriangle();\n      poolTri.copy(tri);\n      triangles.push(poolTri);\n    }\n  }\n\n  // Split the current set of triangles by passing a single triangle in. If the triangle is\n  // coplanar it will attempt to split by the triangle edge planes\n  splitByTriangle(triangle) {\n    const {\n      normal,\n      triangles\n    } = this;\n    triangle.getNormal(_triangleNormal).normalize();\n    if (Math.abs(1.0 - Math.abs(_triangleNormal.dot(normal))) < PARALLEL_EPSILON) {\n      this.coplanarTriangleUsed = true;\n      for (let i = 0, l = triangles.length; i < l; i++) {\n        const t = triangles[i];\n        t.coplanarCount = 0;\n      }\n\n      // if the triangle is coplanar then split by the edge planes\n      const arr = [triangle.a, triangle.b, triangle.c];\n      for (let i = 0; i < 3; i++) {\n        const nexti = (i + 1) % 3;\n        const v0 = arr[i];\n        const v1 = arr[nexti];\n\n        // plane positive direction is toward triangle center\n        _vec.subVectors(v1, v0).normalize();\n        _planeNormal.crossVectors(_triangleNormal, _vec);\n        _plane.setFromNormalAndCoplanarPoint(_planeNormal, v0);\n        this.splitByPlane(_plane, triangle);\n      }\n    } else {\n      // otherwise split by the triangle plane\n      triangle.getPlane(_plane);\n      this.splitByPlane(_plane, triangle);\n    }\n  }\n\n  // Split the triangles by the given plan. If a triangle is provided then we ensure we\n  // intersect the triangle before splitting the plane\n  splitByPlane(plane, clippingTriangle) {\n    const {\n      triangles,\n      trianglePool\n    } = this;\n\n    // init our triangle to check for intersection\n    _splittingTriangle.copy(clippingTriangle);\n    _splittingTriangle.needsUpdate = true;\n\n    // try to split every triangle in the class\n    for (let i = 0, l = triangles.length; i < l; i++) {\n      const tri = triangles[i];\n\n      // skip the triangle if we don't intersect with it\n      if (!_splittingTriangle.intersectsTriangle(tri, _edge, true)) {\n        continue;\n      }\n      const {\n        a,\n        b,\n        c\n      } = tri;\n      let intersects = 0;\n      let vertexSplitEnd = -1;\n      let coplanarEdge = false;\n      let posSideVerts = [];\n      let negSideVerts = [];\n      const arr = [a, b, c];\n      for (let t = 0; t < 3; t++) {\n        // get the triangle edge\n        const tNext = (t + 1) % 3;\n        _edge.start.copy(arr[t]);\n        _edge.end.copy(arr[tNext]);\n\n        // track if the start point sits on the plane or if it's on the positive side of it\n        // so we can use that information to determine whether to split later.\n        const startDist = plane.distanceToPoint(_edge.start);\n        const endDist = plane.distanceToPoint(_edge.end);\n        if (Math.abs(startDist) < COPLANAR_EPSILON && Math.abs(endDist) < COPLANAR_EPSILON) {\n          coplanarEdge = true;\n          break;\n        }\n        if (startDist > 0) {\n          posSideVerts.push(t);\n        } else {\n          negSideVerts.push(t);\n        }\n\n        // we only don't consider this an intersection if the start points hits the plane\n        if (Math.abs(startDist) < COPLANAR_EPSILON) {\n          continue;\n        }\n\n        // double check the end point since the \"intersectLine\" function sometimes does not\n        // return it as an intersection (see issue #28)\n        // Because we ignore the start point intersection above we have to make sure we check the end\n        // point intersection here.\n        let didIntersect = !!plane.intersectLine(_edge, _vec);\n        if (!didIntersect && Math.abs(endDist) < COPLANAR_EPSILON) {\n          _vec.copy(_edge.end);\n          didIntersect = true;\n        }\n\n        // check if we intersect the plane (ignoring the start point so we don't double count)\n        if (didIntersect && !(_vec.distanceTo(_edge.start) < EPSILON)) {\n          // if we intersect at the end point then we track that point as one that we\n          // have to split down the middle\n          if (_vec.distanceTo(_edge.end) < EPSILON) {\n            vertexSplitEnd = t;\n          }\n\n          // track the split edge\n          if (intersects === 0) {\n            _foundEdge.start.copy(_vec);\n          } else {\n            _foundEdge.end.copy(_vec);\n          }\n          intersects++;\n        }\n      }\n\n      // skip splitting if:\n      // - we have two points on the plane then the plane intersects the triangle exactly on an edge\n      // - the plane does not intersect on 2 points\n      // - the intersection edge is too small\n      // - we're not along a coplanar edge\n      if (!coplanarEdge && intersects === 2 && _foundEdge.distance() > COPLANAR_EPSILON) {\n        if (vertexSplitEnd !== -1) {\n          vertexSplitEnd = (vertexSplitEnd + 1) % 3;\n\n          // we're splitting along a vertex\n          let otherVert1 = 0;\n          if (otherVert1 === vertexSplitEnd) {\n            otherVert1 = (otherVert1 + 1) % 3;\n          }\n          let otherVert2 = otherVert1 + 1;\n          if (otherVert2 === vertexSplitEnd) {\n            otherVert2 = (otherVert2 + 1) % 3;\n          }\n          const nextTri = trianglePool.getTriangle();\n          nextTri.a.copy(arr[otherVert2]);\n          nextTri.b.copy(_foundEdge.end);\n          nextTri.c.copy(_foundEdge.start);\n          if (!isTriDegenerate(nextTri)) {\n            triangles.push(nextTri);\n          }\n          tri.a.copy(arr[otherVert1]);\n          tri.b.copy(_foundEdge.start);\n          tri.c.copy(_foundEdge.end);\n\n          // finish off the adjusted triangle\n          if (isTriDegenerate(tri)) {\n            triangles.splice(i, 1);\n            i--;\n            l--;\n          }\n        } else {\n          // we're splitting with a quad and a triangle\n          // TODO: what happens when we find that about the pos and negative\n          // sides have only a single vertex?\n          const singleVert = posSideVerts.length >= 2 ? negSideVerts[0] : posSideVerts[0];\n\n          // swap the direction of the intersection edge depending on which\n          // side of the plane the single vertex is on to align with the\n          // correct winding order.\n          if (singleVert === 0) {\n            let tmp = _foundEdge.start;\n            _foundEdge.start = _foundEdge.end;\n            _foundEdge.end = tmp;\n          }\n          const nextVert1 = (singleVert + 1) % 3;\n          const nextVert2 = (singleVert + 2) % 3;\n          const nextTri1 = trianglePool.getTriangle();\n          const nextTri2 = trianglePool.getTriangle();\n\n          // choose the triangle that has the larger areas (shortest split distance)\n          if (arr[nextVert1].distanceToSquared(_foundEdge.start) < arr[nextVert2].distanceToSquared(_foundEdge.end)) {\n            nextTri1.a.copy(arr[nextVert1]);\n            nextTri1.b.copy(_foundEdge.start);\n            nextTri1.c.copy(_foundEdge.end);\n            nextTri2.a.copy(arr[nextVert1]);\n            nextTri2.b.copy(arr[nextVert2]);\n            nextTri2.c.copy(_foundEdge.start);\n          } else {\n            nextTri1.a.copy(arr[nextVert2]);\n            nextTri1.b.copy(_foundEdge.start);\n            nextTri1.c.copy(_foundEdge.end);\n            nextTri2.a.copy(arr[nextVert1]);\n            nextTri2.b.copy(arr[nextVert2]);\n            nextTri2.c.copy(_foundEdge.end);\n          }\n          tri.a.copy(arr[singleVert]);\n          tri.b.copy(_foundEdge.end);\n          tri.c.copy(_foundEdge.start);\n\n          // don't add degenerate triangles to the list\n          if (!isTriDegenerate(nextTri1)) {\n            triangles.push(nextTri1);\n          }\n          if (!isTriDegenerate(nextTri2)) {\n            triangles.push(nextTri2);\n          }\n\n          // finish off the adjusted triangle\n          if (isTriDegenerate(tri)) {\n            triangles.splice(i, 1);\n            i--;\n            l--;\n          }\n        }\n      } else if (intersects === 3) {\n        console.warn('TriangleClipper: Coplanar clip not handled');\n      }\n    }\n  }\n  reset() {\n    this.triangles.length = 0;\n    this.trianglePool.clear();\n    this.coplanarTriangleUsed = false;\n  }\n}","map":{"version":3,"names":["Triangle","Line3","Vector3","Plane","ExtendedTriangle","isTriDegenerate","EPSILON","COPLANAR_EPSILON","PARALLEL_EPSILON","_edge","_foundEdge","_vec","_triangleNormal","_planeNormal","_plane","_splittingTriangle","TrianglePool","constructor","_pool","_index","getTriangle","length","push","clear","reset","TriangleSplitter","trianglePool","triangles","normal","coplanarTriangleUsed","initialize","tri","Array","isArray","i","l","t","getNormal","Math","abs","dot","Error","poolTri","copy","splitByTriangle","triangle","normalize","coplanarCount","arr","a","b","c","nexti","v0","v1","subVectors","crossVectors","setFromNormalAndCoplanarPoint","splitByPlane","getPlane","plane","clippingTriangle","needsUpdate","intersectsTriangle","intersects","vertexSplitEnd","coplanarEdge","posSideVerts","negSideVerts","tNext","start","end","startDist","distanceToPoint","endDist","didIntersect","intersectLine","distanceTo","distance","otherVert1","otherVert2","nextTri","splice","singleVert","tmp","nextVert1","nextVert2","nextTri1","nextTri2","distanceToSquared","console","warn"],"sources":["/Users/ratseevtimur/Documents/Test-Projects/door-3d/node_modules/three-bvh-csg/src/core/TriangleSplitter.js"],"sourcesContent":["import { Triangle, Line3, Vector3, Plane } from 'three';\nimport { ExtendedTriangle } from 'three-mesh-bvh';\nimport { isTriDegenerate } from './utils/triangleUtils.js';\n\n// NOTE: these epsilons likely should all be the same since they're used to measure the\n// distance from a point to a plane which needs to be done consistently\nconst EPSILON = 1e-10;\nconst COPLANAR_EPSILON = 1e-10;\nconst PARALLEL_EPSILON = 1e-10;\nconst _edge = new Line3();\nconst _foundEdge = new Line3();\nconst _vec = new Vector3();\nconst _triangleNormal = new Vector3();\nconst _planeNormal = new Vector3();\nconst _plane = new Plane();\nconst _splittingTriangle = new ExtendedTriangle();\n\n// A pool of triangles to avoid unnecessary triangle creation\nclass TrianglePool {\n\n\tconstructor() {\n\n\t\tthis._pool = [];\n\t\tthis._index = 0;\n\n\t}\n\n\tgetTriangle() {\n\n\t\tif ( this._index >= this._pool.length ) {\n\n\t\t\tthis._pool.push( new Triangle() );\n\n\t\t}\n\n\t\treturn this._pool[ this._index ++ ];\n\n\t}\n\n\tclear() {\n\n\t\tthis._index = 0;\n\n\t}\n\n\treset() {\n\n\t\tthis._pool.length = 0;\n\t\tthis._index = 0;\n\n\t}\n\n}\n\n// Utility class for splitting triangles\nexport class TriangleSplitter {\n\n\tconstructor() {\n\n\t\tthis.trianglePool = new TrianglePool();\n\t\tthis.triangles = [];\n\t\tthis.normal = new Vector3();\n\t\tthis.coplanarTriangleUsed = false;\n\n\t}\n\n\t// initialize the class with a triangle\n\tinitialize( tri ) {\n\n\t\tthis.reset();\n\n\t\tconst { triangles, trianglePool, normal } = this;\n\t\tif ( Array.isArray( tri ) ) {\n\n\t\t\tfor ( let i = 0, l = tri.length; i < l; i ++ ) {\n\n\t\t\t\tconst t = tri[ i ];\n\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\tt.getNormal( normal );\n\n\t\t\t\t} else if ( Math.abs( 1.0 - t.getNormal( _vec ).dot( normal ) ) > EPSILON ) {\n\n\t\t\t\t\tthrow new Error( 'Triangle Splitter: Cannot initialize with triangles that have different normals.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst poolTri = trianglePool.getTriangle();\n\t\t\t\tpoolTri.copy( t );\n\t\t\t\ttriangles.push( poolTri );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\ttri.getNormal( normal );\n\n\t\t\tconst poolTri = trianglePool.getTriangle();\n\t\t\tpoolTri.copy( tri );\n\t\t\ttriangles.push( poolTri );\n\n\t\t}\n\n\t}\n\n\t// Split the current set of triangles by passing a single triangle in. If the triangle is\n\t// coplanar it will attempt to split by the triangle edge planes\n\tsplitByTriangle( triangle ) {\n\n\t\tconst { normal, triangles } = this;\n\t\ttriangle.getNormal( _triangleNormal ).normalize();\n\n\t\tif ( Math.abs( 1.0 - Math.abs( _triangleNormal.dot( normal ) ) ) < PARALLEL_EPSILON ) {\n\n\t\t\tthis.coplanarTriangleUsed = true;\n\n\t\t\tfor ( let i = 0, l = triangles.length; i < l; i ++ ) {\n\n\t\t\t\tconst t = triangles[ i ];\n\t\t\t\tt.coplanarCount = 0;\n\n\t\t\t}\n\n\t\t\t// if the triangle is coplanar then split by the edge planes\n\t\t\tconst arr = [ triangle.a, triangle.b, triangle.c ];\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst nexti = ( i + 1 ) % 3;\n\n\t\t\t\tconst v0 = arr[ i ];\n\t\t\t\tconst v1 = arr[ nexti ];\n\n\t\t\t\t// plane positive direction is toward triangle center\n\t\t\t\t_vec.subVectors( v1, v0 ).normalize();\n\t\t\t\t_planeNormal.crossVectors( _triangleNormal, _vec );\n\t\t\t\t_plane.setFromNormalAndCoplanarPoint( _planeNormal, v0 );\n\n\t\t\t\tthis.splitByPlane( _plane, triangle );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// otherwise split by the triangle plane\n\t\t\ttriangle.getPlane( _plane );\n\t\t\tthis.splitByPlane( _plane, triangle );\n\n\t\t}\n\n\t}\n\n\t// Split the triangles by the given plan. If a triangle is provided then we ensure we\n\t// intersect the triangle before splitting the plane\n\tsplitByPlane( plane, clippingTriangle ) {\n\n\t\tconst { triangles, trianglePool } = this;\n\n\t\t// init our triangle to check for intersection\n\t\t_splittingTriangle.copy( clippingTriangle );\n\t\t_splittingTriangle.needsUpdate = true;\n\n\t\t// try to split every triangle in the class\n\t\tfor ( let i = 0, l = triangles.length; i < l; i ++ ) {\n\n\t\t\tconst tri = triangles[ i ];\n\n\t\t\t// skip the triangle if we don't intersect with it\n\t\t\tif ( ! _splittingTriangle.intersectsTriangle( tri, _edge, true ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst { a, b, c } = tri;\n\t\t\tlet intersects = 0;\n\t\t\tlet vertexSplitEnd = - 1;\n\t\t\tlet coplanarEdge = false;\n\t\t\tlet posSideVerts = [];\n\t\t\tlet negSideVerts = [];\n\t\t\tconst arr = [ a, b, c ];\n\t\t\tfor ( let t = 0; t < 3; t ++ ) {\n\n\t\t\t\t// get the triangle edge\n\t\t\t\tconst tNext = ( t + 1 ) % 3;\n\t\t\t\t_edge.start.copy( arr[ t ] );\n\t\t\t\t_edge.end.copy( arr[ tNext ] );\n\n\t\t\t\t// track if the start point sits on the plane or if it's on the positive side of it\n\t\t\t\t// so we can use that information to determine whether to split later.\n\t\t\t\tconst startDist = plane.distanceToPoint( _edge.start );\n\t\t\t\tconst endDist = plane.distanceToPoint( _edge.end );\n\t\t\t\tif ( Math.abs( startDist ) < COPLANAR_EPSILON && Math.abs( endDist ) < COPLANAR_EPSILON ) {\n\n\t\t\t\t\tcoplanarEdge = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( startDist > 0 ) {\n\n\t\t\t\t\tposSideVerts.push( t );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnegSideVerts.push( t );\n\n\t\t\t\t}\n\n\t\t\t\t// we only don't consider this an intersection if the start points hits the plane\n\t\t\t\tif ( Math.abs( startDist ) < COPLANAR_EPSILON ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// double check the end point since the \"intersectLine\" function sometimes does not\n\t\t\t\t// return it as an intersection (see issue #28)\n\t\t\t\t// Because we ignore the start point intersection above we have to make sure we check the end\n\t\t\t\t// point intersection here.\n\t\t\t\tlet didIntersect = ! ! plane.intersectLine( _edge, _vec );\n\t\t\t\tif ( ! didIntersect && Math.abs( endDist ) < COPLANAR_EPSILON ) {\n\n\t\t\t\t\t_vec.copy( _edge.end );\n\t\t\t\t\tdidIntersect = true;\n\n\t\t\t\t}\n\n\t\t\t\t// check if we intersect the plane (ignoring the start point so we don't double count)\n\t\t\t\tif ( didIntersect && ! ( _vec.distanceTo( _edge.start ) < EPSILON ) ) {\n\n\t\t\t\t\t// if we intersect at the end point then we track that point as one that we\n\t\t\t\t\t// have to split down the middle\n\t\t\t\t\tif ( _vec.distanceTo( _edge.end ) < EPSILON ) {\n\n\t\t\t\t\t\tvertexSplitEnd = t;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// track the split edge\n\t\t\t\t\tif ( intersects === 0 ) {\n\n\t\t\t\t\t\t_foundEdge.start.copy( _vec );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_foundEdge.end.copy( _vec );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tintersects ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// skip splitting if:\n\t\t\t// - we have two points on the plane then the plane intersects the triangle exactly on an edge\n\t\t\t// - the plane does not intersect on 2 points\n\t\t\t// - the intersection edge is too small\n\t\t\t// - we're not along a coplanar edge\n\t\t\tif ( ! coplanarEdge && intersects === 2 && _foundEdge.distance() > COPLANAR_EPSILON ) {\n\n\t\t\t\tif ( vertexSplitEnd !== - 1 ) {\n\n\t\t\t\t\tvertexSplitEnd = ( vertexSplitEnd + 1 ) % 3;\n\n\t\t\t\t\t// we're splitting along a vertex\n\t\t\t\t\tlet otherVert1 = 0;\n\t\t\t\t\tif ( otherVert1 === vertexSplitEnd ) {\n\n\t\t\t\t\t\totherVert1 = ( otherVert1 + 1 ) % 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet otherVert2 = otherVert1 + 1;\n\t\t\t\t\tif ( otherVert2 === vertexSplitEnd ) {\n\n\t\t\t\t\t\totherVert2 = ( otherVert2 + 1 ) % 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst nextTri = trianglePool.getTriangle();\n\t\t\t\t\tnextTri.a.copy( arr[ otherVert2 ] );\n\t\t\t\t\tnextTri.b.copy( _foundEdge.end );\n\t\t\t\t\tnextTri.c.copy( _foundEdge.start );\n\n\t\t\t\t\tif ( ! isTriDegenerate( nextTri ) ) {\n\n\t\t\t\t\t\ttriangles.push( nextTri );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttri.a.copy( arr[ otherVert1 ] );\n\t\t\t\t\ttri.b.copy( _foundEdge.start );\n\t\t\t\t\ttri.c.copy( _foundEdge.end );\n\n\t\t\t\t\t// finish off the adjusted triangle\n\t\t\t\t\tif ( isTriDegenerate( tri ) ) {\n\n\t\t\t\t\t\ttriangles.splice( i, 1 );\n\t\t\t\t\t\ti --;\n\t\t\t\t\t\tl --;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// we're splitting with a quad and a triangle\n\t\t\t\t\t// TODO: what happens when we find that about the pos and negative\n\t\t\t\t\t// sides have only a single vertex?\n\t\t\t\t\tconst singleVert =\n\t\t\t\t\t\tposSideVerts.length >= 2 ?\n\t\t\t\t\t\t\tnegSideVerts[ 0 ] :\n\t\t\t\t\t\t\tposSideVerts[ 0 ];\n\n\t\t\t\t\t// swap the direction of the intersection edge depending on which\n\t\t\t\t\t// side of the plane the single vertex is on to align with the\n\t\t\t\t\t// correct winding order.\n\t\t\t\t\tif ( singleVert === 0 ) {\n\n\t\t\t\t\t\tlet tmp = _foundEdge.start;\n\t\t\t\t\t\t_foundEdge.start = _foundEdge.end;\n\t\t\t\t\t\t_foundEdge.end = tmp;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst nextVert1 = ( singleVert + 1 ) % 3;\n\t\t\t\t\tconst nextVert2 = ( singleVert + 2 ) % 3;\n\n\t\t\t\t\tconst nextTri1 = trianglePool.getTriangle();\n\t\t\t\t\tconst nextTri2 = trianglePool.getTriangle();\n\n\t\t\t\t\t// choose the triangle that has the larger areas (shortest split distance)\n\t\t\t\t\tif ( arr[ nextVert1 ].distanceToSquared( _foundEdge.start ) < arr[ nextVert2 ].distanceToSquared( _foundEdge.end ) ) {\n\n\t\t\t\t\t\tnextTri1.a.copy( arr[ nextVert1 ] );\n\t\t\t\t\t\tnextTri1.b.copy( _foundEdge.start );\n\t\t\t\t\t\tnextTri1.c.copy( _foundEdge.end );\n\n\t\t\t\t\t\tnextTri2.a.copy( arr[ nextVert1 ] );\n\t\t\t\t\t\tnextTri2.b.copy( arr[ nextVert2 ] );\n\t\t\t\t\t\tnextTri2.c.copy( _foundEdge.start );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnextTri1.a.copy( arr[ nextVert2 ] );\n\t\t\t\t\t\tnextTri1.b.copy( _foundEdge.start );\n\t\t\t\t\t\tnextTri1.c.copy( _foundEdge.end );\n\n\t\t\t\t\t\tnextTri2.a.copy( arr[ nextVert1 ] );\n\t\t\t\t\t\tnextTri2.b.copy( arr[ nextVert2 ] );\n\t\t\t\t\t\tnextTri2.c.copy( _foundEdge.end );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttri.a.copy( arr[ singleVert ] );\n\t\t\t\t\ttri.b.copy( _foundEdge.end );\n\t\t\t\t\ttri.c.copy( _foundEdge.start );\n\n\t\t\t\t\t// don't add degenerate triangles to the list\n\t\t\t\t\tif ( ! isTriDegenerate( nextTri1 ) ) {\n\n\t\t\t\t\t\ttriangles.push( nextTri1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! isTriDegenerate( nextTri2 ) ) {\n\n\t\t\t\t\t\ttriangles.push( nextTri2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// finish off the adjusted triangle\n\t\t\t\t\tif ( isTriDegenerate( tri ) ) {\n\n\t\t\t\t\t\ttriangles.splice( i, 1 );\n\t\t\t\t\t\ti --;\n\t\t\t\t\t\tl --;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( intersects === 3 ) {\n\n\t\t\t\tconsole.warn( 'TriangleClipper: Coplanar clip not handled' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treset() {\n\n\t\tthis.triangles.length = 0;\n\t\tthis.trianglePool.clear();\n\t\tthis.coplanarTriangleUsed = false;\n\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}