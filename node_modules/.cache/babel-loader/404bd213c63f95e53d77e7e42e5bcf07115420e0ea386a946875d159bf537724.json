{"ast":null,"code":"import { areSharedArrayBuffersSupported } from './utils/geometryUtils.js';\nfunction ceilToFourByteStride(byteLength) {\n  byteLength = ~~byteLength;\n  return byteLength + 4 - byteLength % 4;\n}\n\n// Make a new array wrapper class that more easily affords expansion when reaching it's max capacity\nexport class TypeBackedArray {\n  constructor(type, initialSize = 500) {\n    this.expansionFactor = 1.5;\n    this.type = type;\n    this.length = 0;\n    this.array = null;\n    this.setSize(initialSize);\n  }\n  setType(type) {\n    if (this.length !== 0) {\n      throw new Error('TypeBackedArray: Cannot change the type while there is used data in the buffer.');\n    }\n    const buffer = this.array.buffer;\n    this.array = new type(buffer);\n    this.type = type;\n  }\n  setSize(size) {\n    if (this.array && size === this.array.length) {\n      return;\n    }\n\n    // ceil to the nearest 4 bytes so we can replace the array with any type using the same buffer\n    const type = this.type;\n    const bufferType = areSharedArrayBuffersSupported() ? SharedArrayBuffer : ArrayBuffer;\n    const newArray = new type(new bufferType(ceilToFourByteStride(size * type.BYTES_PER_ELEMENT)));\n    if (this.array) {\n      newArray.set(this.array, 0);\n    }\n    this.array = newArray;\n  }\n  expand() {\n    const {\n      array,\n      expansionFactor\n    } = this;\n    this.setSize(array.length * expansionFactor);\n  }\n  push(...args) {\n    let {\n      array,\n      length\n    } = this;\n    if (length + args.length > array.length) {\n      this.expand();\n      array = this.array;\n    }\n    for (let i = 0, l = args.length; i < l; i++) {\n      array[length + i] = args[i];\n    }\n    this.length += args.length;\n  }\n  clear() {\n    this.length = 0;\n  }\n}","map":{"version":3,"names":["areSharedArrayBuffersSupported","ceilToFourByteStride","byteLength","TypeBackedArray","constructor","type","initialSize","expansionFactor","length","array","setSize","setType","Error","buffer","size","bufferType","SharedArrayBuffer","ArrayBuffer","newArray","BYTES_PER_ELEMENT","set","expand","push","args","i","l","clear"],"sources":["/Users/ratseevtimur/Documents/Test-Projects/door-3d/node_modules/three-bvh-csg/src/core/TypeBackedArray.js"],"sourcesContent":["import { areSharedArrayBuffersSupported } from './utils/geometryUtils.js';\n\nfunction ceilToFourByteStride( byteLength ) {\n\n\tbyteLength = ~ ~ byteLength;\n\treturn byteLength + 4 - byteLength % 4;\n\n}\n\n// Make a new array wrapper class that more easily affords expansion when reaching it's max capacity\nexport class TypeBackedArray {\n\n\tconstructor( type, initialSize = 500 ) {\n\n\n\t\tthis.expansionFactor = 1.5;\n\t\tthis.type = type;\n\t\tthis.length = 0;\n\t\tthis.array = null;\n\n\t\tthis.setSize( initialSize );\n\n\t}\n\n\tsetType( type ) {\n\n\t\tif ( this.length !== 0 ) {\n\n\t\t\tthrow new Error( 'TypeBackedArray: Cannot change the type while there is used data in the buffer.' );\n\n\t\t}\n\n\t\tconst buffer = this.array.buffer;\n\t\tthis.array = new type( buffer );\n\t\tthis.type = type;\n\n\t}\n\n\tsetSize( size ) {\n\n\t\tif ( this.array && size === this.array.length ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// ceil to the nearest 4 bytes so we can replace the array with any type using the same buffer\n\t\tconst type = this.type;\n\t\tconst bufferType = areSharedArrayBuffersSupported() ? SharedArrayBuffer : ArrayBuffer;\n\t\tconst newArray = new type( new bufferType( ceilToFourByteStride( size * type.BYTES_PER_ELEMENT ) ) );\n\t\tif ( this.array ) {\n\n\t\t\tnewArray.set( this.array, 0 );\n\n\t\t}\n\n\t\tthis.array = newArray;\n\n\t}\n\n\texpand() {\n\n\t\tconst { array, expansionFactor } = this;\n\t\tthis.setSize( array.length * expansionFactor );\n\n\t}\n\n\tpush( ...args ) {\n\n\t\tlet { array, length } = this;\n\t\tif ( length + args.length > array.length ) {\n\n\t\t\tthis.expand();\n\t\t\tarray = this.array;\n\n\t\t}\n\n\t\tfor ( let i = 0, l = args.length; i < l; i ++ ) {\n\n\t\t\tarray[ length + i ] = args[ i ];\n\n\t\t}\n\n\t\tthis.length += args.length;\n\n\t}\n\n\tclear() {\n\n\t\tthis.length = 0;\n\n\t}\n\n}\n"],"mappings":"AAAA,SAASA,8BAA8B,QAAQ,0BAA0B;AAEzE,SAASC,oBAAoBA,CAAEC,UAAU,EAAG;EAE3CA,UAAU,GAAG,CAAE,CAAEA,UAAU;EAC3B,OAAOA,UAAU,GAAG,CAAC,GAAGA,UAAU,GAAG,CAAC;AAEvC;;AAEA;AACA,OAAO,MAAMC,eAAe,CAAC;EAE5BC,WAAWA,CAAEC,IAAI,EAAEC,WAAW,GAAG,GAAG,EAAG;IAGtC,IAAI,CAACC,eAAe,GAAG,GAAG;IAC1B,IAAI,CAACF,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACG,MAAM,GAAG,CAAC;IACf,IAAI,CAACC,KAAK,GAAG,IAAI;IAEjB,IAAI,CAACC,OAAO,CAAEJ,WAAY,CAAC;EAE5B;EAEAK,OAAOA,CAAEN,IAAI,EAAG;IAEf,IAAK,IAAI,CAACG,MAAM,KAAK,CAAC,EAAG;MAExB,MAAM,IAAII,KAAK,CAAE,iFAAkF,CAAC;IAErG;IAEA,MAAMC,MAAM,GAAG,IAAI,CAACJ,KAAK,CAACI,MAAM;IAChC,IAAI,CAACJ,KAAK,GAAG,IAAIJ,IAAI,CAAEQ,MAAO,CAAC;IAC/B,IAAI,CAACR,IAAI,GAAGA,IAAI;EAEjB;EAEAK,OAAOA,CAAEI,IAAI,EAAG;IAEf,IAAK,IAAI,CAACL,KAAK,IAAIK,IAAI,KAAK,IAAI,CAACL,KAAK,CAACD,MAAM,EAAG;MAE/C;IAED;;IAEA;IACA,MAAMH,IAAI,GAAG,IAAI,CAACA,IAAI;IACtB,MAAMU,UAAU,GAAGf,8BAA8B,CAAC,CAAC,GAAGgB,iBAAiB,GAAGC,WAAW;IACrF,MAAMC,QAAQ,GAAG,IAAIb,IAAI,CAAE,IAAIU,UAAU,CAAEd,oBAAoB,CAAEa,IAAI,GAAGT,IAAI,CAACc,iBAAkB,CAAE,CAAE,CAAC;IACpG,IAAK,IAAI,CAACV,KAAK,EAAG;MAEjBS,QAAQ,CAACE,GAAG,CAAE,IAAI,CAACX,KAAK,EAAE,CAAE,CAAC;IAE9B;IAEA,IAAI,CAACA,KAAK,GAAGS,QAAQ;EAEtB;EAEAG,MAAMA,CAAA,EAAG;IAER,MAAM;MAAEZ,KAAK;MAAEF;IAAgB,CAAC,GAAG,IAAI;IACvC,IAAI,CAACG,OAAO,CAAED,KAAK,CAACD,MAAM,GAAGD,eAAgB,CAAC;EAE/C;EAEAe,IAAIA,CAAE,GAAGC,IAAI,EAAG;IAEf,IAAI;MAAEd,KAAK;MAAED;IAAO,CAAC,GAAG,IAAI;IAC5B,IAAKA,MAAM,GAAGe,IAAI,CAACf,MAAM,GAAGC,KAAK,CAACD,MAAM,EAAG;MAE1C,IAAI,CAACa,MAAM,CAAC,CAAC;MACbZ,KAAK,GAAG,IAAI,CAACA,KAAK;IAEnB;IAEA,KAAM,IAAIe,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGF,IAAI,CAACf,MAAM,EAAEgB,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAG,EAAG;MAE/Cf,KAAK,CAAED,MAAM,GAAGgB,CAAC,CAAE,GAAGD,IAAI,CAAEC,CAAC,CAAE;IAEhC;IAEA,IAAI,CAAChB,MAAM,IAAIe,IAAI,CAACf,MAAM;EAE3B;EAEAkB,KAAKA,CAAA,EAAG;IAEP,IAAI,CAAClB,MAAM,GAAG,CAAC;EAEhB;AAED"},"metadata":{},"sourceType":"module","externalDependencies":[]}