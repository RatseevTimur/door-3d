{"ast":null,"code":"import { Vector2, Vector3, Vector4 } from 'three';\nimport { hashNumber, hashVertex2, hashVertex3, hashVertex4 } from './utils/hashUtils.js';\nimport { getTriCount } from './utils/geometryUtils.js';\nimport { computeDisjointEdges } from './utils/computeDisjointEdges.js';\nconst _vec2 = new Vector2();\nconst _vec3 = new Vector3();\nconst _vec4 = new Vector4();\nconst _hashes = ['', '', ''];\nexport class HalfEdgeMap {\n  constructor(geometry = null) {\n    // result data\n    this.data = null;\n    this.disjointConnections = null;\n    this.unmatchedDisjointEdges = null;\n    this.unmatchedEdges = -1;\n    this.matchedEdges = -1;\n\n    // options\n    this.useDrawRange = true;\n    this.useAllAttributes = false;\n    this.matchDisjointEdges = false;\n    this.degenerateEpsilon = 1e-8;\n    if (geometry) {\n      this.updateFrom(geometry);\n    }\n  }\n  getSiblingTriangleIndex(triIndex, edgeIndex) {\n    const otherIndex = this.data[triIndex * 3 + edgeIndex];\n    return otherIndex === -1 ? -1 : ~~(otherIndex / 3);\n  }\n  getSiblingEdgeIndex(triIndex, edgeIndex) {\n    const otherIndex = this.data[triIndex * 3 + edgeIndex];\n    return otherIndex === -1 ? -1 : otherIndex % 3;\n  }\n  getDisjointSiblingTriangleIndices(triIndex, edgeIndex) {\n    const index = triIndex * 3 + edgeIndex;\n    const arr = this.disjointConnections.get(index);\n    return arr ? arr.map(i => ~~(i / 3)) : [];\n  }\n  getDisjointSiblingEdgeIndices(triIndex, edgeIndex) {\n    const index = triIndex * 3 + edgeIndex;\n    const arr = this.disjointConnections.get(index);\n    return arr ? arr.map(i => i % 3) : [];\n  }\n  isFullyConnected() {\n    return this.unmatchedEdges === 0;\n  }\n  updateFrom(geometry) {\n    const {\n      useAllAttributes,\n      useDrawRange,\n      matchDisjointEdges,\n      degenerateEpsilon\n    } = this;\n    const hashFunction = useAllAttributes ? hashAllAttributes : hashPositionAttribute;\n\n    // runs on the assumption that there is a 1 : 1 match of edges\n    const map = new Map();\n\n    // attributes\n    const {\n      attributes\n    } = geometry;\n    const attrKeys = useAllAttributes ? Object.keys(attributes) : null;\n    const indexAttr = geometry.index;\n    const posAttr = attributes.position;\n\n    // get the potential number of triangles\n    let triCount = getTriCount(geometry);\n    const maxTriCount = triCount;\n\n    // get the real number of triangles from the based on the draw range\n    let offset = 0;\n    if (useDrawRange) {\n      offset = geometry.drawRange.start;\n      if (geometry.drawRange.count !== Infinity) {\n        triCount = ~~(geometry.drawRange.count / 3);\n      }\n    }\n\n    // initialize the connectivity buffer - 1 means no connectivity\n    let data = this.data;\n    if (!data || data.length < 3 * maxTriCount) {\n      data = new Int32Array(3 * maxTriCount);\n    }\n    data.fill(-1);\n\n    // iterate over all triangles\n    let matchedEdges = 0;\n    let unmatchedSet = new Set();\n    for (let i = offset, l = triCount * 3 + offset; i < l; i += 3) {\n      const i3 = i;\n      for (let e = 0; e < 3; e++) {\n        let i0 = i3 + e;\n        if (indexAttr) {\n          i0 = indexAttr.getX(i0);\n        }\n        _hashes[e] = hashFunction(i0);\n      }\n      for (let e = 0; e < 3; e++) {\n        const nextE = (e + 1) % 3;\n        const vh0 = _hashes[e];\n        const vh1 = _hashes[nextE];\n        const reverseHash = `${vh1}_${vh0}`;\n        if (map.has(reverseHash)) {\n          // create a reference between the two triangles and clear the hash\n          const index = i3 + e;\n          const otherIndex = map.get(reverseHash);\n          data[index] = otherIndex;\n          data[otherIndex] = index;\n          map.delete(reverseHash);\n          matchedEdges += 2;\n          unmatchedSet.delete(otherIndex);\n        } else {\n          // save the triangle and triangle edge index captured in one value\n          // triIndex = ~ ~ ( i0 / 3 );\n          // edgeIndex = i0 % 3;\n          const hash = `${vh0}_${vh1}`;\n          const index = i3 + e;\n          map.set(hash, index);\n          unmatchedSet.add(index);\n        }\n      }\n    }\n    if (matchDisjointEdges) {\n      const {\n        fragmentMap,\n        disjointConnectivityMap\n      } = computeDisjointEdges(geometry, unmatchedSet, degenerateEpsilon);\n      unmatchedSet.clear();\n      fragmentMap.forEach(({\n        forward,\n        reverse\n      }) => {\n        forward.forEach(({\n          index\n        }) => unmatchedSet.add(index));\n        reverse.forEach(({\n          index\n        }) => unmatchedSet.add(index));\n      });\n      this.unmatchedDisjointEdges = fragmentMap;\n      this.disjointConnections = disjointConnectivityMap;\n      matchedEdges = triCount * 3 - unmatchedSet.size;\n    }\n    this.matchedEdges = matchedEdges;\n    this.unmatchedEdges = unmatchedSet.size;\n    this.data = data;\n    function hashPositionAttribute(i) {\n      _vec3.fromBufferAttribute(posAttr, i);\n      return hashVertex3(_vec3);\n    }\n    function hashAllAttributes(i) {\n      let result = '';\n      for (let k = 0, l = attrKeys.length; k < l; k++) {\n        const attr = attributes[attrKeys[k]];\n        let str;\n        switch (attr.itemSize) {\n          case 1:\n            str = hashNumber(attr.getX(i));\n            break;\n          case 2:\n            str = hashVertex2(_vec2.fromBufferAttribute(attr, i));\n            break;\n          case 3:\n            str = hashVertex3(_vec3.fromBufferAttribute(attr, i));\n            break;\n          case 4:\n            str = hashVertex4(_vec4.fromBufferAttribute(attr, i));\n            break;\n        }\n        if (result !== '') {\n          result += '|';\n        }\n        result += str;\n      }\n      return result;\n    }\n  }\n}","map":{"version":3,"names":["Vector2","Vector3","Vector4","hashNumber","hashVertex2","hashVertex3","hashVertex4","getTriCount","computeDisjointEdges","_vec2","_vec3","_vec4","_hashes","HalfEdgeMap","constructor","geometry","data","disjointConnections","unmatchedDisjointEdges","unmatchedEdges","matchedEdges","useDrawRange","useAllAttributes","matchDisjointEdges","degenerateEpsilon","updateFrom","getSiblingTriangleIndex","triIndex","edgeIndex","otherIndex","getSiblingEdgeIndex","getDisjointSiblingTriangleIndices","index","arr","get","map","i","getDisjointSiblingEdgeIndices","isFullyConnected","hashFunction","hashAllAttributes","hashPositionAttribute","Map","attributes","attrKeys","Object","keys","indexAttr","posAttr","position","triCount","maxTriCount","offset","drawRange","start","count","Infinity","length","Int32Array","fill","unmatchedSet","Set","l","i3","e","i0","getX","nextE","vh0","vh1","reverseHash","has","delete","hash","set","add","fragmentMap","disjointConnectivityMap","clear","forEach","forward","reverse","size","fromBufferAttribute","result","k","attr","str","itemSize"],"sources":["/Users/ratseevtimur/Documents/Test-Projects/door-3d/node_modules/three-bvh-csg/src/core/HalfEdgeMap.js"],"sourcesContent":["import { Vector2, Vector3, Vector4 } from 'three';\nimport { hashNumber, hashVertex2, hashVertex3, hashVertex4 } from './utils/hashUtils.js';\nimport { getTriCount } from './utils/geometryUtils.js';\nimport { computeDisjointEdges } from './utils/computeDisjointEdges.js';\n\nconst _vec2 = new Vector2();\nconst _vec3 = new Vector3();\nconst _vec4 = new Vector4();\nconst _hashes = [ '', '', '' ];\n\nexport class HalfEdgeMap {\n\n\tconstructor( geometry = null ) {\n\n\t\t// result data\n\t\tthis.data = null;\n\t\tthis.disjointConnections = null;\n\t\tthis.unmatchedDisjointEdges = null;\n\t\tthis.unmatchedEdges = - 1;\n\t\tthis.matchedEdges = - 1;\n\n\t\t// options\n\t\tthis.useDrawRange = true;\n\t\tthis.useAllAttributes = false;\n\t\tthis.matchDisjointEdges = false;\n\t\tthis.degenerateEpsilon = 1e-8;\n\n\t\tif ( geometry ) {\n\n\t\t\tthis.updateFrom( geometry );\n\n\t\t}\n\n\t}\n\n\tgetSiblingTriangleIndex( triIndex, edgeIndex ) {\n\n\t\tconst otherIndex = this.data[ triIndex * 3 + edgeIndex ];\n\t\treturn otherIndex === - 1 ? - 1 : ~ ~ ( otherIndex / 3 );\n\n\t}\n\n\tgetSiblingEdgeIndex( triIndex, edgeIndex ) {\n\n\t\tconst otherIndex = this.data[ triIndex * 3 + edgeIndex ];\n\t\treturn otherIndex === - 1 ? - 1 : ( otherIndex % 3 );\n\n\t}\n\n\tgetDisjointSiblingTriangleIndices( triIndex, edgeIndex ) {\n\n\t\tconst index = triIndex * 3 + edgeIndex;\n\t\tconst arr = this.disjointConnections.get( index );\n\t\treturn arr ? arr.map( i => ~ ~ ( i / 3 ) ) : [];\n\n\t}\n\n\tgetDisjointSiblingEdgeIndices( triIndex, edgeIndex ) {\n\n\t\tconst index = triIndex * 3 + edgeIndex;\n\t\tconst arr = this.disjointConnections.get( index );\n\t\treturn arr ? arr.map( i => i % 3 ) : [];\n\n\t}\n\n\tisFullyConnected() {\n\n\t\treturn this.unmatchedEdges === 0;\n\n\t}\n\n\tupdateFrom( geometry ) {\n\n\t\tconst { useAllAttributes, useDrawRange, matchDisjointEdges, degenerateEpsilon } = this;\n\t\tconst hashFunction = useAllAttributes ? hashAllAttributes : hashPositionAttribute;\n\n\t\t// runs on the assumption that there is a 1 : 1 match of edges\n\t\tconst map = new Map();\n\n\t\t// attributes\n\t\tconst { attributes } = geometry;\n\t\tconst attrKeys = useAllAttributes ? Object.keys( attributes ) : null;\n\t\tconst indexAttr = geometry.index;\n\t\tconst posAttr = attributes.position;\n\n\t\t// get the potential number of triangles\n\t\tlet triCount = getTriCount( geometry );\n\t\tconst maxTriCount = triCount;\n\n\t\t// get the real number of triangles from the based on the draw range\n\t\tlet offset = 0;\n\t\tif ( useDrawRange ) {\n\n\t\t\toffset = geometry.drawRange.start;\n\t\t\tif ( geometry.drawRange.count !== Infinity ) {\n\n\t\t\t\ttriCount = ~ ~ ( geometry.drawRange.count / 3 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// initialize the connectivity buffer - 1 means no connectivity\n\t\tlet data = this.data;\n\t\tif ( ! data || data.length < 3 * maxTriCount ) {\n\n\t\t\tdata = new Int32Array( 3 * maxTriCount );\n\n\t\t}\n\n\t\tdata.fill( - 1 );\n\n\t\t// iterate over all triangles\n\t\tlet matchedEdges = 0;\n\t\tlet unmatchedSet = new Set();\n\t\tfor ( let i = offset, l = triCount * 3 + offset; i < l; i += 3 ) {\n\n\t\t\tconst i3 = i;\n\t\t\tfor ( let e = 0; e < 3; e ++ ) {\n\n\t\t\t\tlet i0 = i3 + e;\n\t\t\t\tif ( indexAttr ) {\n\n\t\t\t\t\ti0 = indexAttr.getX( i0 );\n\n\t\t\t\t}\n\n\t\t\t\t_hashes[ e ] = hashFunction( i0 );\n\n\t\t\t}\n\n\t\t\tfor ( let e = 0; e < 3; e ++ ) {\n\n\t\t\t\tconst nextE = ( e + 1 ) % 3;\n\t\t\t\tconst vh0 = _hashes[ e ];\n\t\t\t\tconst vh1 = _hashes[ nextE ];\n\n\t\t\t\tconst reverseHash = `${ vh1 }_${ vh0 }`;\n\t\t\t\tif ( map.has( reverseHash ) ) {\n\n\t\t\t\t\t// create a reference between the two triangles and clear the hash\n\t\t\t\t\tconst index = i3 + e;\n\t\t\t\t\tconst otherIndex = map.get( reverseHash );\n\t\t\t\t\tdata[ index ] = otherIndex;\n\t\t\t\t\tdata[ otherIndex ] = index;\n\t\t\t\t\tmap.delete( reverseHash );\n\t\t\t\t\tmatchedEdges += 2;\n\t\t\t\t\tunmatchedSet.delete( otherIndex );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// save the triangle and triangle edge index captured in one value\n\t\t\t\t\t// triIndex = ~ ~ ( i0 / 3 );\n\t\t\t\t\t// edgeIndex = i0 % 3;\n\t\t\t\t\tconst hash = `${ vh0 }_${ vh1 }`;\n\t\t\t\t\tconst index = i3 + e;\n\t\t\t\t\tmap.set( hash, index );\n\t\t\t\t\tunmatchedSet.add( index );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( matchDisjointEdges ) {\n\n\t\t\tconst {\n\t\t\t\tfragmentMap,\n\t\t\t\tdisjointConnectivityMap,\n\t\t\t} = computeDisjointEdges( geometry, unmatchedSet, degenerateEpsilon );\n\n\t\t\tunmatchedSet.clear();\n\t\t\tfragmentMap.forEach( ( { forward, reverse } ) => {\n\n\t\t\t\tforward.forEach( ( { index } ) => unmatchedSet.add( index ) );\n\t\t\t\treverse.forEach( ( { index } ) => unmatchedSet.add( index ) );\n\n\t\t\t} );\n\n\t\t\tthis.unmatchedDisjointEdges = fragmentMap;\n\t\t\tthis.disjointConnections = disjointConnectivityMap;\n\t\t\tmatchedEdges = triCount * 3 - unmatchedSet.size;\n\n\t\t}\n\n\t\tthis.matchedEdges = matchedEdges;\n\t\tthis.unmatchedEdges = unmatchedSet.size;\n\t\tthis.data = data;\n\n\t\tfunction hashPositionAttribute( i ) {\n\n\t\t\t_vec3.fromBufferAttribute( posAttr, i );\n\t\t\treturn hashVertex3( _vec3 );\n\n\t\t}\n\n\t\tfunction hashAllAttributes( i ) {\n\n\t\t\tlet result = '';\n\t\t\tfor ( let k = 0, l = attrKeys.length; k < l; k ++ ) {\n\n\t\t\t\tconst attr = attributes[ attrKeys[ k ] ];\n\t\t\t\tlet str;\n\t\t\t\tswitch ( attr.itemSize ) {\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tstr = hashNumber( attr.getX( i ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tstr = hashVertex2( _vec2.fromBufferAttribute( attr, i ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tstr = hashVertex3( _vec3.fromBufferAttribute( attr, i ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tstr = hashVertex4( _vec4.fromBufferAttribute( attr, i ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( result !== '' ) {\n\n\t\t\t\t\tresult += '|';\n\n\t\t\t\t}\n\n\t\t\t\tresult += str;\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}