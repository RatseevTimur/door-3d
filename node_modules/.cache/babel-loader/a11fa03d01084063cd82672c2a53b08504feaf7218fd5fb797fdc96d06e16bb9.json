{"ast":null,"code":"import { Matrix4, Matrix3, Triangle } from 'three';\nimport { getHitSideWithCoplanarCheck, getHitSide, collectIntersectingTriangles, appendAttributeFromTriangle, appendAttributesFromIndices, getOperationAction, SKIP_TRI, INVERT_TRI } from './operationsUtils.js';\nimport { getTriCount } from '../utils/geometryUtils.js';\nimport { HOLLOW_INTERSECTION, HOLLOW_SUBTRACTION } from '../constants.js';\nimport { isTriDegenerate } from '../utils/triangleUtils.js';\nconst _matrix = new Matrix4();\nconst _normalMatrix = new Matrix3();\nconst _triA = new Triangle();\nconst _triB = new Triangle();\nconst _tri = new Triangle();\nconst _barycoordTri = new Triangle();\nconst _attr = [];\nconst _actions = [];\nfunction getFirstIdFromSet(set) {\n  for (const id of set) return id;\n}\n\n// runs the given operation against a and b using the splitter and appending data to the\n// attributeData object.\nexport function performOperation(a, b, operations, splitter, attributeData, options = {}) {\n  const {\n    useGroups = true\n  } = options;\n  const {\n    aIntersections,\n    bIntersections\n  } = collectIntersectingTriangles(a, b);\n  const resultGroups = [];\n  let resultMaterials = null;\n  let groupOffset;\n  groupOffset = useGroups ? 0 : -1;\n  performSplitTriangleOperations(a, b, aIntersections, operations, false, splitter, attributeData, groupOffset);\n  performWholeTriangleOperations(a, b, aIntersections, operations, false, attributeData, groupOffset);\n\n  // find whether the set of operations contains a non-hollow operations. If it does then we need\n  // to perform the second set of triangle additions\n  const nonHollow = operations.findIndex(op => op !== HOLLOW_INTERSECTION && op !== HOLLOW_SUBTRACTION) !== -1;\n  if (nonHollow) {\n    groupOffset = useGroups ? a.geometry.groups.length || 1 : -1;\n    performSplitTriangleOperations(b, a, bIntersections, operations, true, splitter, attributeData, groupOffset);\n    performWholeTriangleOperations(b, a, bIntersections, operations, true, attributeData, groupOffset);\n  }\n  _attr.length = 0;\n  _actions.length = 0;\n  return {\n    groups: resultGroups,\n    materials: resultMaterials\n  };\n}\n\n// perform triangle splitting and CSG operations on the set of split triangles\nfunction performSplitTriangleOperations(a, b, intersectionMap, operations, invert, splitter, attributeData, groupOffset = 0) {\n  const invertedGeometry = a.matrixWorld.determinant() < 0;\n\n  // transforms into the local frame of matrix b\n  _matrix.copy(b.matrixWorld).invert().multiply(a.matrixWorld);\n  _normalMatrix.getNormalMatrix(a.matrixWorld).multiplyScalar(invertedGeometry ? -1 : 1);\n  const groupIndices = a.geometry.groupIndices;\n  const aIndex = a.geometry.index;\n  const aPosition = a.geometry.attributes.position;\n  const bBVH = b.geometry.boundsTree;\n  const bIndex = b.geometry.index;\n  const bPosition = b.geometry.attributes.position;\n  const splitIds = intersectionMap.ids;\n  const intersectionSet = intersectionMap.intersectionSet;\n\n  // iterate over all split triangle indices\n  for (let i = 0, l = splitIds.length; i < l; i++) {\n    const ia = splitIds[i];\n    const groupIndex = groupOffset === -1 ? 0 : groupIndices[ia] + groupOffset;\n\n    // get the triangle in the geometry B local frame\n    const ia3 = 3 * ia;\n    const ia0 = aIndex.getX(ia3 + 0);\n    const ia1 = aIndex.getX(ia3 + 1);\n    const ia2 = aIndex.getX(ia3 + 2);\n    _triA.a.fromBufferAttribute(aPosition, ia0).applyMatrix4(_matrix);\n    _triA.b.fromBufferAttribute(aPosition, ia1).applyMatrix4(_matrix);\n    _triA.c.fromBufferAttribute(aPosition, ia2).applyMatrix4(_matrix);\n\n    // initialize the splitter with the triangle from geometry A\n    splitter.reset();\n    splitter.initialize(_triA);\n\n    // split the triangle with the intersecting triangles from B\n    const intersectingIndices = intersectionSet[ia];\n    for (let ib = 0, l = intersectingIndices.length; ib < l; ib++) {\n      const ib3 = 3 * intersectingIndices[ib];\n      const ib0 = bIndex.getX(ib3 + 0);\n      const ib1 = bIndex.getX(ib3 + 1);\n      const ib2 = bIndex.getX(ib3 + 2);\n      _triB.a.fromBufferAttribute(bPosition, ib0);\n      _triB.b.fromBufferAttribute(bPosition, ib1);\n      _triB.c.fromBufferAttribute(bPosition, ib2);\n      splitter.splitByTriangle(_triB);\n    }\n\n    // for all triangles in the split result\n    const triangles = splitter.triangles;\n    for (let ib = 0, l = triangles.length; ib < l; ib++) {\n      // get the barycentric coordinates of the clipped triangle to add\n      const clippedTri = triangles[ib];\n\n      // try to use the side derived from the clipping but if it turns out to be\n      // uncertain then fall back to the raycasting approach\n      const hitSide = splitter.coplanarTriangleUsed ? getHitSideWithCoplanarCheck(clippedTri, bBVH) : getHitSide(clippedTri, bBVH);\n      _attr.length = 0;\n      _actions.length = 0;\n      for (let o = 0, lo = operations.length; o < lo; o++) {\n        const op = getOperationAction(operations[o], hitSide, invert);\n        if (op !== SKIP_TRI) {\n          _actions.push(op);\n          _attr.push(attributeData[o].getGroupAttrSet(groupIndex));\n        }\n      }\n      if (_attr.length !== 0) {\n        _triA.getBarycoord(clippedTri.a, _barycoordTri.a);\n        _triA.getBarycoord(clippedTri.b, _barycoordTri.b);\n        _triA.getBarycoord(clippedTri.c, _barycoordTri.c);\n        for (let k = 0, lk = _attr.length; k < lk; k++) {\n          const attrSet = _attr[k];\n          const action = _actions[k];\n          const invertTri = action === INVERT_TRI;\n          appendAttributeFromTriangle(ia, _barycoordTri, a.geometry, a.matrixWorld, _normalMatrix, attrSet, invertedGeometry !== invertTri);\n        }\n      }\n    }\n  }\n  return splitIds.length;\n}\n\n// perform CSG operations on the set of whole triangles using a half edge structure\n// at the moment this isn't always faster due to overhead of building the half edge structure\n// and degraded connectivity due to split triangles.\n\nfunction performWholeTriangleOperations(a, b, splitTriSet, operations, invert, attributeData, groupOffset = 0) {\n  const invertedGeometry = a.matrixWorld.determinant() < 0;\n\n  // matrix for transforming into the local frame of geometry b\n  _matrix.copy(b.matrixWorld).invert().multiply(a.matrixWorld);\n  _normalMatrix.getNormalMatrix(a.matrixWorld).multiplyScalar(invertedGeometry ? -1 : 1);\n  const bBVH = b.geometry.boundsTree;\n  const groupIndices = a.geometry.groupIndices;\n  const aIndex = a.geometry.index;\n  const aAttributes = a.geometry.attributes;\n  const aPosition = aAttributes.position;\n  const stack = [];\n  const halfEdges = a.geometry.halfEdges;\n  const traverseSet = new Set();\n  const triCount = getTriCount(a.geometry);\n  for (let i = 0, l = triCount; i < l; i++) {\n    if (!(i in splitTriSet.intersectionSet)) {\n      traverseSet.add(i);\n    }\n  }\n  while (traverseSet.size > 0) {\n    const id = getFirstIdFromSet(traverseSet);\n    traverseSet.delete(id);\n    stack.push(id);\n\n    // get the vertex indices\n    const i3 = 3 * id;\n    const i0 = aIndex.getX(i3 + 0);\n    const i1 = aIndex.getX(i3 + 1);\n    const i2 = aIndex.getX(i3 + 2);\n\n    // get the vertex position in the frame of geometry b so we can\n    // perform hit testing\n    _tri.a.fromBufferAttribute(aPosition, i0).applyMatrix4(_matrix);\n    _tri.b.fromBufferAttribute(aPosition, i1).applyMatrix4(_matrix);\n    _tri.c.fromBufferAttribute(aPosition, i2).applyMatrix4(_matrix);\n\n    // get the side and decide if we need to cull the triangle based on the operation\n    const hitSide = getHitSide(_tri, bBVH);\n    _actions.length = 0;\n    _attr.length = 0;\n    for (let o = 0, lo = operations.length; o < lo; o++) {\n      const op = getOperationAction(operations[o], hitSide, invert);\n      if (op !== SKIP_TRI) {\n        _actions.push(op);\n        _attr.push(attributeData[o]);\n      }\n    }\n    while (stack.length > 0) {\n      const currId = stack.pop();\n      for (let i = 0; i < 3; i++) {\n        const sid = halfEdges.getSiblingTriangleIndex(currId, i);\n        if (sid !== -1 && traverseSet.has(sid)) {\n          stack.push(sid);\n          traverseSet.delete(sid);\n        }\n      }\n      if (_attr.length !== 0) {\n        const i3 = 3 * currId;\n        const i0 = aIndex.getX(i3 + 0);\n        const i1 = aIndex.getX(i3 + 1);\n        const i2 = aIndex.getX(i3 + 2);\n        const groupIndex = groupOffset === -1 ? 0 : groupIndices[currId] + groupOffset;\n        _tri.a.fromBufferAttribute(aPosition, i0);\n        _tri.b.fromBufferAttribute(aPosition, i1);\n        _tri.c.fromBufferAttribute(aPosition, i2);\n        if (!isTriDegenerate(_tri)) {\n          for (let k = 0, lk = _attr.length; k < lk; k++) {\n            const action = _actions[k];\n            const attrSet = _attr[k].getGroupAttrSet(groupIndex);\n            const invertTri = action === INVERT_TRI;\n            appendAttributesFromIndices(i0, i1, i2, aAttributes, a.matrixWorld, _normalMatrix, attrSet, invertTri !== invertedGeometry);\n          }\n        }\n      }\n    }\n  }\n}","map":{"version":3,"names":["Matrix4","Matrix3","Triangle","getHitSideWithCoplanarCheck","getHitSide","collectIntersectingTriangles","appendAttributeFromTriangle","appendAttributesFromIndices","getOperationAction","SKIP_TRI","INVERT_TRI","getTriCount","HOLLOW_INTERSECTION","HOLLOW_SUBTRACTION","isTriDegenerate","_matrix","_normalMatrix","_triA","_triB","_tri","_barycoordTri","_attr","_actions","getFirstIdFromSet","set","id","performOperation","a","b","operations","splitter","attributeData","options","useGroups","aIntersections","bIntersections","resultGroups","resultMaterials","groupOffset","performSplitTriangleOperations","performWholeTriangleOperations","nonHollow","findIndex","op","geometry","groups","length","materials","intersectionMap","invert","invertedGeometry","matrixWorld","determinant","copy","multiply","getNormalMatrix","multiplyScalar","groupIndices","aIndex","index","aPosition","attributes","position","bBVH","boundsTree","bIndex","bPosition","splitIds","ids","intersectionSet","i","l","ia","groupIndex","ia3","ia0","getX","ia1","ia2","fromBufferAttribute","applyMatrix4","c","reset","initialize","intersectingIndices","ib","ib3","ib0","ib1","ib2","splitByTriangle","triangles","clippedTri","hitSide","coplanarTriangleUsed","o","lo","push","getGroupAttrSet","getBarycoord","k","lk","attrSet","action","invertTri","splitTriSet","aAttributes","stack","halfEdges","traverseSet","Set","triCount","add","size","delete","i3","i0","i1","i2","currId","pop","sid","getSiblingTriangleIndex","has"],"sources":["/Users/ratseevtimur/Documents/Test-Projects/door-3d/node_modules/three-bvh-csg/src/core/operations/operations.js"],"sourcesContent":["import { Matrix4, Matrix3, Triangle } from 'three';\nimport {\n\tgetHitSideWithCoplanarCheck,\n\tgetHitSide,\n\tcollectIntersectingTriangles,\n\tappendAttributeFromTriangle,\n\tappendAttributesFromIndices,\n\tgetOperationAction,\n\tSKIP_TRI, INVERT_TRI,\n} from './operationsUtils.js';\nimport { getTriCount } from '../utils/geometryUtils.js';\nimport { HOLLOW_INTERSECTION, HOLLOW_SUBTRACTION } from '../constants.js';\nimport { isTriDegenerate } from '../utils/triangleUtils.js';\n\nconst _matrix = new Matrix4();\nconst _normalMatrix = new Matrix3();\nconst _triA = new Triangle();\nconst _triB = new Triangle();\nconst _tri = new Triangle();\nconst _barycoordTri = new Triangle();\nconst _attr = [];\nconst _actions = [];\n\nfunction getFirstIdFromSet( set ) {\n\n\tfor ( const id of set ) return id;\n\n}\n\n// runs the given operation against a and b using the splitter and appending data to the\n// attributeData object.\nexport function performOperation(\n\ta,\n\tb,\n\toperations,\n\tsplitter,\n\tattributeData,\n\toptions = {},\n) {\n\n\tconst { useGroups = true } = options;\n\tconst { aIntersections, bIntersections } = collectIntersectingTriangles( a, b );\n\n\tconst resultGroups = [];\n\tlet resultMaterials = null;\n\n\tlet groupOffset;\n\tgroupOffset = useGroups ? 0 : - 1;\n\tperformSplitTriangleOperations( a, b, aIntersections, operations, false, splitter, attributeData, groupOffset );\n\tperformWholeTriangleOperations( a, b, aIntersections, operations, false, attributeData, groupOffset );\n\n\t// find whether the set of operations contains a non-hollow operations. If it does then we need\n\t// to perform the second set of triangle additions\n\tconst nonHollow = operations\n\t\t.findIndex( op => op !== HOLLOW_INTERSECTION && op !== HOLLOW_SUBTRACTION ) !== - 1;\n\n\tif ( nonHollow ) {\n\n\t\tgroupOffset = useGroups ? a.geometry.groups.length || 1 : - 1;\n\t\tperformSplitTriangleOperations( b, a, bIntersections, operations, true, splitter, attributeData, groupOffset );\n\t\tperformWholeTriangleOperations( b, a, bIntersections, operations, true, attributeData, groupOffset );\n\n\t}\n\n\t_attr.length = 0;\n\t_actions.length = 0;\n\n\treturn {\n\t\tgroups: resultGroups,\n\t\tmaterials: resultMaterials\n\t};\n\n}\n\n// perform triangle splitting and CSG operations on the set of split triangles\nfunction performSplitTriangleOperations(\n\ta,\n\tb,\n\tintersectionMap,\n\toperations,\n\tinvert,\n\tsplitter,\n\tattributeData,\n\tgroupOffset = 0,\n) {\n\n\tconst invertedGeometry = a.matrixWorld.determinant() < 0;\n\n\t// transforms into the local frame of matrix b\n\t_matrix\n\t\t.copy( b.matrixWorld )\n\t\t.invert()\n\t\t.multiply( a.matrixWorld );\n\n\t_normalMatrix\n\t\t.getNormalMatrix( a.matrixWorld )\n\t\t.multiplyScalar( invertedGeometry ? - 1 : 1 );\n\n\tconst groupIndices = a.geometry.groupIndices;\n\tconst aIndex = a.geometry.index;\n\tconst aPosition = a.geometry.attributes.position;\n\n\tconst bBVH = b.geometry.boundsTree;\n\tconst bIndex = b.geometry.index;\n\tconst bPosition = b.geometry.attributes.position;\n\tconst splitIds = intersectionMap.ids;\n\tconst intersectionSet = intersectionMap.intersectionSet;\n\n\t// iterate over all split triangle indices\n\tfor ( let i = 0, l = splitIds.length; i < l; i ++ ) {\n\n\t\tconst ia = splitIds[ i ];\n\t\tconst groupIndex = groupOffset === - 1 ? 0 : groupIndices[ ia ] + groupOffset;\n\n\t\t// get the triangle in the geometry B local frame\n\t\tconst ia3 = 3 * ia;\n\t\tconst ia0 = aIndex.getX( ia3 + 0 );\n\t\tconst ia1 = aIndex.getX( ia3 + 1 );\n\t\tconst ia2 = aIndex.getX( ia3 + 2 );\n\t\t_triA.a.fromBufferAttribute( aPosition, ia0 ).applyMatrix4( _matrix );\n\t\t_triA.b.fromBufferAttribute( aPosition, ia1 ).applyMatrix4( _matrix );\n\t\t_triA.c.fromBufferAttribute( aPosition, ia2 ).applyMatrix4( _matrix );\n\n\t\t// initialize the splitter with the triangle from geometry A\n\t\tsplitter.reset();\n\t\tsplitter.initialize( _triA );\n\n\t\t// split the triangle with the intersecting triangles from B\n\t\tconst intersectingIndices = intersectionSet[ ia ];\n\t\tfor ( let ib = 0, l = intersectingIndices.length; ib < l; ib ++ ) {\n\n\t\t\tconst ib3 = 3 * intersectingIndices[ ib ];\n\t\t\tconst ib0 = bIndex.getX( ib3 + 0 );\n\t\t\tconst ib1 = bIndex.getX( ib3 + 1 );\n\t\t\tconst ib2 = bIndex.getX( ib3 + 2 );\n\t\t\t_triB.a.fromBufferAttribute( bPosition, ib0 );\n\t\t\t_triB.b.fromBufferAttribute( bPosition, ib1 );\n\t\t\t_triB.c.fromBufferAttribute( bPosition, ib2 );\n\t\t\tsplitter.splitByTriangle( _triB );\n\n\t\t}\n\n\t\t// for all triangles in the split result\n\t\tconst triangles = splitter.triangles;\n\t\tfor ( let ib = 0, l = triangles.length; ib < l; ib ++ ) {\n\n\t\t\t// get the barycentric coordinates of the clipped triangle to add\n\t\t\tconst clippedTri = triangles[ ib ];\n\n\t\t\t// try to use the side derived from the clipping but if it turns out to be\n\t\t\t// uncertain then fall back to the raycasting approach\n\t\t\tconst hitSide = splitter.coplanarTriangleUsed ?\n\t\t\t\tgetHitSideWithCoplanarCheck( clippedTri, bBVH ) :\n\t\t\t\tgetHitSide( clippedTri, bBVH );\n\n\t\t\t_attr.length = 0;\n\t\t\t_actions.length = 0;\n\t\t\tfor ( let o = 0, lo = operations.length; o < lo; o ++ ) {\n\n\t\t\t\tconst op = getOperationAction( operations[ o ], hitSide, invert );\n\t\t\t\tif ( op !== SKIP_TRI ) {\n\n\t\t\t\t\t_actions.push( op );\n\t\t\t\t\t_attr.push( attributeData[ o ].getGroupAttrSet( groupIndex ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( _attr.length !== 0 ) {\n\n\t\t\t\t_triA.getBarycoord( clippedTri.a, _barycoordTri.a );\n\t\t\t\t_triA.getBarycoord( clippedTri.b, _barycoordTri.b );\n\t\t\t\t_triA.getBarycoord( clippedTri.c, _barycoordTri.c );\n\n\t\t\t\tfor ( let k = 0, lk = _attr.length; k < lk; k ++ ) {\n\n\t\t\t\t\tconst attrSet = _attr[ k ];\n\t\t\t\t\tconst action = _actions[ k ];\n\t\t\t\t\tconst invertTri = action === INVERT_TRI;\n\t\t\t\t\tappendAttributeFromTriangle( ia, _barycoordTri, a.geometry, a.matrixWorld, _normalMatrix, attrSet, invertedGeometry !== invertTri );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn splitIds.length;\n\n}\n\n// perform CSG operations on the set of whole triangles using a half edge structure\n// at the moment this isn't always faster due to overhead of building the half edge structure\n// and degraded connectivity due to split triangles.\n\nfunction performWholeTriangleOperations(\n\ta,\n\tb,\n\tsplitTriSet,\n\toperations,\n\tinvert,\n\tattributeData,\n\tgroupOffset = 0,\n) {\n\n\tconst invertedGeometry = a.matrixWorld.determinant() < 0;\n\n\t// matrix for transforming into the local frame of geometry b\n\t_matrix\n\t\t.copy( b.matrixWorld )\n\t\t.invert()\n\t\t.multiply( a.matrixWorld );\n\n\t_normalMatrix\n\t\t.getNormalMatrix( a.matrixWorld )\n\t\t.multiplyScalar( invertedGeometry ? - 1 : 1 );\n\n\tconst bBVH = b.geometry.boundsTree;\n\tconst groupIndices = a.geometry.groupIndices;\n\tconst aIndex = a.geometry.index;\n\tconst aAttributes = a.geometry.attributes;\n\tconst aPosition = aAttributes.position;\n\n\tconst stack = [];\n\tconst halfEdges = a.geometry.halfEdges;\n\tconst traverseSet = new Set();\n\tconst triCount = getTriCount( a.geometry );\n\tfor ( let i = 0, l = triCount; i < l; i ++ ) {\n\n\t\tif ( ! ( i in splitTriSet.intersectionSet ) ) {\n\n\t\t\ttraverseSet.add( i );\n\n\t\t}\n\n\t}\n\n\twhile ( traverseSet.size > 0 ) {\n\n\t\tconst id = getFirstIdFromSet( traverseSet );\n\t\ttraverseSet.delete( id );\n\n\t\tstack.push( id );\n\n\t\t// get the vertex indices\n\t\tconst i3 = 3 * id;\n\t\tconst i0 = aIndex.getX( i3 + 0 );\n\t\tconst i1 = aIndex.getX( i3 + 1 );\n\t\tconst i2 = aIndex.getX( i3 + 2 );\n\n\t\t// get the vertex position in the frame of geometry b so we can\n\t\t// perform hit testing\n\t\t_tri.a.fromBufferAttribute( aPosition, i0 ).applyMatrix4( _matrix );\n\t\t_tri.b.fromBufferAttribute( aPosition, i1 ).applyMatrix4( _matrix );\n\t\t_tri.c.fromBufferAttribute( aPosition, i2 ).applyMatrix4( _matrix );\n\n\t\t// get the side and decide if we need to cull the triangle based on the operation\n\t\tconst hitSide = getHitSide( _tri, bBVH );\n\n\t\t_actions.length = 0;\n\t\t_attr.length = 0;\n\t\tfor ( let o = 0, lo = operations.length; o < lo; o ++ ) {\n\n\t\t\tconst op = getOperationAction( operations[ o ], hitSide, invert );\n\t\t\tif ( op !== SKIP_TRI ) {\n\n\t\t\t\t_actions.push( op );\n\t\t\t\t_attr.push( attributeData[ o ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\twhile ( stack.length > 0 ) {\n\n\t\t\tconst currId = stack.pop();\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst sid = halfEdges.getSiblingTriangleIndex( currId, i );\n\t\t\t\tif ( sid !== - 1 && traverseSet.has( sid ) ) {\n\n\t\t\t\t\tstack.push( sid );\n\t\t\t\t\ttraverseSet.delete( sid );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( _attr.length !== 0 ) {\n\n\t\t\t\tconst i3 = 3 * currId;\n\t\t\t\tconst i0 = aIndex.getX( i3 + 0 );\n\t\t\t\tconst i1 = aIndex.getX( i3 + 1 );\n\t\t\t\tconst i2 = aIndex.getX( i3 + 2 );\n\t\t\t\tconst groupIndex = groupOffset === - 1 ? 0 : groupIndices[ currId ] + groupOffset;\n\n\t\t\t\t_tri.a.fromBufferAttribute( aPosition, i0 );\n\t\t\t\t_tri.b.fromBufferAttribute( aPosition, i1 );\n\t\t\t\t_tri.c.fromBufferAttribute( aPosition, i2 );\n\t\t\t\tif ( ! isTriDegenerate( _tri ) ) {\n\n\t\t\t\t\tfor ( let k = 0, lk = _attr.length; k < lk; k ++ ) {\n\n\t\t\t\t\t\tconst action = _actions[ k ];\n\t\t\t\t\t\tconst attrSet = _attr[ k ].getGroupAttrSet( groupIndex );\n\t\t\t\t\t\tconst invertTri = action === INVERT_TRI;\n\t\t\t\t\t\tappendAttributesFromIndices( i0, i1, i2, aAttributes, a.matrixWorld, _normalMatrix, attrSet, invertTri !== invertedGeometry );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}