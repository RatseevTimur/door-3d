{"ast":null,"code":"import { Line3, Triangle, Vector3, Plane, Ray } from 'three';\nimport { EdgesHelper } from './EdgesHelper.js';\nimport { getTriCount } from '../core/utils/geometryUtils.js';\nimport { toNormalizedRay } from '../core/utils/hashUtils.js';\nconst vertKeys = ['a', 'b', 'c'];\nconst _tri1 = new Triangle();\nconst _tri2 = new Triangle();\nconst _center = new Vector3();\nconst _center2 = new Vector3();\nconst _projected = new Vector3();\nconst _projected2 = new Vector3();\nconst _projectedDir = new Vector3();\nconst _projectedDir2 = new Vector3();\nconst _edgeDir = new Vector3();\nconst _edgeDir2 = new Vector3();\nconst _vec = new Vector3();\nconst _vec2 = new Vector3();\nconst _finalPoint = new Vector3();\nconst _finalPoint2 = new Vector3();\nconst _plane = new Plane();\nconst _plane2 = new Plane();\nconst _centerPoint = new Vector3();\nconst _ray = new Ray();\nconst _edge = new Line3();\nfunction getTriangle(geometry, triIndex, target) {\n  const i3 = 3 * triIndex;\n  let i0 = i3 + 0;\n  let i1 = i3 + 1;\n  let i2 = i3 + 2;\n  const indexAttr = geometry.index;\n  const posAttr = geometry.attributes.position;\n  if (indexAttr) {\n    i0 = indexAttr.getX(i0);\n    i1 = indexAttr.getX(i1);\n    i2 = indexAttr.getX(i2);\n  }\n  target.a.fromBufferAttribute(posAttr, i0);\n  target.b.fromBufferAttribute(posAttr, i1);\n  target.c.fromBufferAttribute(posAttr, i2);\n  return target;\n}\nfunction getOverlapEdge(tri1, e1, tri2, e2, target) {\n  // get the two edges\n  const nextE_0 = (e1 + 1) % 3;\n  const v0_1 = tri1[vertKeys[e1]];\n  const v1_1 = tri1[vertKeys[nextE_0]];\n  const nextE_1 = (e2 + 1) % 3;\n  const v0_2 = tri2[vertKeys[e2]];\n  const v1_2 = tri2[vertKeys[nextE_1]];\n\n  // get the ray defined by the edges\n  toNormalizedRay(v0_1, v1_1, _ray);\n\n  // get the min and max stride across the rays\n  let d0_1 = _vec.subVectors(v0_1, _ray.origin).dot(_ray.direction);\n  let d1_1 = _vec.subVectors(v1_1, _ray.origin).dot(_ray.direction);\n  if (d0_1 > d1_1) [d0_1, d1_1] = [d1_1, d0_1];\n  let d0_2 = _vec.subVectors(v0_2, _ray.origin).dot(_ray.direction);\n  let d1_2 = _vec.subVectors(v1_2, _ray.origin).dot(_ray.direction);\n  if (d0_2 > d1_2) [d0_2, d1_2] = [d1_2, d0_2];\n\n  // get the range of overlap\n  const final_0 = Math.max(d0_1, d0_2);\n  const final_1 = Math.min(d1_1, d1_2);\n  _ray.at(final_0, target.start);\n  _ray.at(final_1, target.end);\n}\nexport class HalfEdgeHelper extends EdgesHelper {\n  constructor(geometry = null, halfEdges = null) {\n    super();\n    this.straightEdges = false;\n    this.displayDisconnectedEdges = false;\n    if (geometry && halfEdges) {\n      this.setHalfEdges(geometry, halfEdges);\n    }\n  }\n  setHalfEdges(geometry, halfEdges) {\n    const {\n      straightEdges,\n      displayDisconnectedEdges\n    } = this;\n    const edges = [];\n    const offset = geometry.drawRange.start;\n    let triCount = getTriCount(geometry);\n    if (geometry.drawRange.count !== Infinity) {\n      triCount = ~~(geometry.drawRange.count / 3);\n    }\n    if (displayDisconnectedEdges) {\n      if (halfEdges.unmatchedDisjointEdges) {\n        halfEdges.unmatchedDisjointEdges.forEach(({\n          forward,\n          reverse,\n          ray\n        }) => {\n          [...forward, ...reverse].forEach(({\n            start,\n            end\n          }) => {\n            const edge = new Line3();\n            ray.at(start, edge.start);\n            ray.at(end, edge.end);\n            edges.push(edge);\n          });\n        });\n      } else {\n        for (let triIndex = offset; triIndex < triCount; triIndex++) {\n          getTriangle(geometry, triIndex, _tri1);\n          for (let e = 0; e < 3; e++) {\n            const otherTriIndex = halfEdges.getSiblingTriangleIndex(triIndex, e);\n            if (otherTriIndex === -1) {\n              const nextE = (e + 1) % 3;\n              const v0 = _tri1[vertKeys[e]];\n              const v1 = _tri1[vertKeys[nextE]];\n              const edge = new Line3();\n              edge.start.copy(v0);\n              edge.end.copy(v1);\n              edges.push(edge);\n            }\n          }\n        }\n      }\n    } else {\n      for (let triIndex = offset; triIndex < triCount; triIndex++) {\n        getTriangle(geometry, triIndex, _tri1);\n        for (let e = 0; e < 3; e++) {\n          const otherTriIndex = halfEdges.getSiblingTriangleIndex(triIndex, e);\n          if (otherTriIndex === -1) {\n            continue;\n          }\n\n          // get other triangle\n          getTriangle(geometry, otherTriIndex, _tri2);\n\n          // get edge centers\n          const nextE = (e + 1) % 3;\n          const v0 = _tri1[vertKeys[e]];\n          const v1 = _tri1[vertKeys[nextE]];\n          _centerPoint.lerpVectors(v0, v1, 0.5);\n          addConnectionEdge(_tri1, _tri2, _centerPoint);\n        }\n        if (halfEdges.disjointConnections) {\n          for (let e = 0; e < 3; e++) {\n            const disjointTriIndices = halfEdges.getDisjointSiblingTriangleIndices(triIndex, e);\n            const disjointEdgeIndices = halfEdges.getDisjointSiblingEdgeIndices(triIndex, e);\n            for (let i = 0; i < disjointTriIndices.length; i++) {\n              const ti = disjointTriIndices[i];\n              const ei = disjointEdgeIndices[i];\n\n              // get other triangle\n              getTriangle(geometry, ti, _tri2);\n              getOverlapEdge(_tri1, e, _tri2, ei, _edge);\n              _centerPoint.lerpVectors(_edge.start, _edge.end, 0.5);\n              addConnectionEdge(_tri1, _tri2, _centerPoint);\n            }\n          }\n        }\n      }\n    }\n    super.setEdges(edges);\n    function addConnectionEdge(tri1, tri2, centerPoint) {\n      tri1.getMidpoint(_center);\n      tri2.getMidpoint(_center2);\n      tri1.getPlane(_plane);\n      tri2.getPlane(_plane2);\n      const edge = new Line3();\n      edge.start.copy(_center);\n      if (straightEdges) {\n        // get the projected centers\n        _plane.projectPoint(_center2, _projected);\n        _plane2.projectPoint(_center, _projected2);\n\n        // get the directions so we can flip them if needed\n        _projectedDir.subVectors(_projected, _center);\n        _projectedDir2.subVectors(_projected2, _center2);\n\n        // get the directions so we can flip them if needed\n        _edgeDir.subVectors(centerPoint, _center);\n        _edgeDir2.subVectors(centerPoint, _center2);\n        if (_projectedDir.dot(_edgeDir) < 0) {\n          _projectedDir.multiplyScalar(-1);\n        }\n        if (_projectedDir2.dot(_edgeDir2) < 0) {\n          _projectedDir2.multiplyScalar(-1);\n        }\n\n        // find the new points after inversion\n        _vec.addVectors(_center, _projectedDir);\n        _vec2.addVectors(_center2, _projectedDir2);\n\n        // project the points onto the triangle edge. This would be better\n        // if we clipped instead of chose the closest point\n        tri1.closestPointToPoint(_vec, _finalPoint);\n        tri2.closestPointToPoint(_vec2, _finalPoint2);\n        edge.end.lerpVectors(_finalPoint, _finalPoint2, 0.5);\n      } else {\n        edge.end.copy(centerPoint);\n      }\n      edges.push(edge);\n    }\n  }\n}","map":{"version":3,"names":["Line3","Triangle","Vector3","Plane","Ray","EdgesHelper","getTriCount","toNormalizedRay","vertKeys","_tri1","_tri2","_center","_center2","_projected","_projected2","_projectedDir","_projectedDir2","_edgeDir","_edgeDir2","_vec","_vec2","_finalPoint","_finalPoint2","_plane","_plane2","_centerPoint","_ray","_edge","getTriangle","geometry","triIndex","target","i3","i0","i1","i2","indexAttr","index","posAttr","attributes","position","getX","a","fromBufferAttribute","b","c","getOverlapEdge","tri1","e1","tri2","e2","nextE_0","v0_1","v1_1","nextE_1","v0_2","v1_2","d0_1","subVectors","origin","dot","direction","d1_1","d0_2","d1_2","final_0","Math","max","final_1","min","at","start","end","HalfEdgeHelper","constructor","halfEdges","straightEdges","displayDisconnectedEdges","setHalfEdges","edges","offset","drawRange","triCount","count","Infinity","unmatchedDisjointEdges","forEach","forward","reverse","ray","edge","push","e","otherTriIndex","getSiblingTriangleIndex","nextE","v0","v1","copy","lerpVectors","addConnectionEdge","disjointConnections","disjointTriIndices","getDisjointSiblingTriangleIndices","disjointEdgeIndices","getDisjointSiblingEdgeIndices","i","length","ti","ei","setEdges","centerPoint","getMidpoint","getPlane","projectPoint","multiplyScalar","addVectors","closestPointToPoint"],"sources":["/Users/ratseevtimur/Documents/Test-Projects/door-3d/node_modules/three-bvh-csg/src/objects/HalfEdgeHelper.js"],"sourcesContent":["import { Line3, Triangle, Vector3, Plane, Ray } from 'three';\nimport { EdgesHelper } from './EdgesHelper.js';\nimport { getTriCount } from '../core/utils/geometryUtils.js';\nimport { toNormalizedRay } from '../core/utils/hashUtils.js';\n\nconst vertKeys = [ 'a', 'b', 'c' ];\nconst _tri1 = new Triangle();\nconst _tri2 = new Triangle();\nconst _center = new Vector3();\nconst _center2 = new Vector3();\nconst _projected = new Vector3();\nconst _projected2 = new Vector3();\nconst _projectedDir = new Vector3();\nconst _projectedDir2 = new Vector3();\nconst _edgeDir = new Vector3();\nconst _edgeDir2 = new Vector3();\nconst _vec = new Vector3();\nconst _vec2 = new Vector3();\nconst _finalPoint = new Vector3();\nconst _finalPoint2 = new Vector3();\nconst _plane = new Plane();\nconst _plane2 = new Plane();\nconst _centerPoint = new Vector3();\nconst _ray = new Ray();\nconst _edge = new Line3();\n\nfunction getTriangle( geometry, triIndex, target ) {\n\n\tconst i3 = 3 * triIndex;\n\tlet i0 = i3 + 0;\n\tlet i1 = i3 + 1;\n\tlet i2 = i3 + 2;\n\n\tconst indexAttr = geometry.index;\n\tconst posAttr = geometry.attributes.position;\n\tif ( indexAttr ) {\n\n\t\ti0 = indexAttr.getX( i0 );\n\t\ti1 = indexAttr.getX( i1 );\n\t\ti2 = indexAttr.getX( i2 );\n\n\t}\n\n\ttarget.a.fromBufferAttribute( posAttr, i0 );\n\ttarget.b.fromBufferAttribute( posAttr, i1 );\n\ttarget.c.fromBufferAttribute( posAttr, i2 );\n\n\treturn target;\n\n}\n\nfunction getOverlapEdge( tri1, e1, tri2, e2, target ) {\n\n\t// get the two edges\n\tconst nextE_0 = ( e1 + 1 ) % 3;\n\tconst v0_1 = tri1[ vertKeys[ e1 ] ];\n\tconst v1_1 = tri1[ vertKeys[ nextE_0 ] ];\n\n\tconst nextE_1 = ( e2 + 1 ) % 3;\n\tconst v0_2 = tri2[ vertKeys[ e2 ] ];\n\tconst v1_2 = tri2[ vertKeys[ nextE_1 ] ];\n\n\t// get the ray defined by the edges\n\ttoNormalizedRay( v0_1, v1_1, _ray );\n\n\t// get the min and max stride across the rays\n\tlet d0_1 = _vec.subVectors( v0_1, _ray.origin ).dot( _ray.direction );\n\tlet d1_1 = _vec.subVectors( v1_1, _ray.origin ).dot( _ray.direction );\n\tif ( d0_1 > d1_1 ) [ d0_1, d1_1 ] = [ d1_1, d0_1 ];\n\n\tlet d0_2 = _vec.subVectors( v0_2, _ray.origin ).dot( _ray.direction );\n\tlet d1_2 = _vec.subVectors( v1_2, _ray.origin ).dot( _ray.direction );\n\tif ( d0_2 > d1_2 ) [ d0_2, d1_2 ] = [ d1_2, d0_2 ];\n\n\t// get the range of overlap\n\tconst final_0 = Math.max( d0_1, d0_2 );\n\tconst final_1 = Math.min( d1_1, d1_2 );\n\t_ray.at( final_0, target.start );\n\t_ray.at( final_1, target.end );\n\n}\n\n\nexport class HalfEdgeHelper extends EdgesHelper {\n\n\tconstructor( geometry = null, halfEdges = null ) {\n\n\t\tsuper();\n\t\tthis.straightEdges = false;\n\t\tthis.displayDisconnectedEdges = false;\n\n\t\tif ( geometry && halfEdges ) {\n\n\t\t\tthis.setHalfEdges( geometry, halfEdges );\n\n\t\t}\n\n\t}\n\n\tsetHalfEdges( geometry, halfEdges ) {\n\n\t\tconst { straightEdges, displayDisconnectedEdges } = this;\n\t\tconst edges = [];\n\t\tconst offset = geometry.drawRange.start;\n\t\tlet triCount = getTriCount( geometry );\n\t\tif ( geometry.drawRange.count !== Infinity ) {\n\n\t\t\ttriCount = ~ ~ ( geometry.drawRange.count / 3 );\n\n\t\t}\n\n\t\tif ( displayDisconnectedEdges ) {\n\n\t\t\tif ( halfEdges.unmatchedDisjointEdges ) {\n\n\t\t\t\thalfEdges\n\t\t\t\t\t.unmatchedDisjointEdges\n\t\t\t\t\t.forEach( ( { forward, reverse, ray } ) => {\n\n\t\t\t\t\t\t[ ...forward, ...reverse ]\n\t\t\t\t\t\t\t.forEach( ( { start, end } ) => {\n\n\t\t\t\t\t\t\t\tconst edge = new Line3();\n\t\t\t\t\t\t\t\tray.at( start, edge.start );\n\t\t\t\t\t\t\t\tray.at( end, edge.end );\n\t\t\t\t\t\t\t\tedges.push( edge );\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let triIndex = offset; triIndex < triCount; triIndex ++ ) {\n\n\t\t\t\t\tgetTriangle( geometry, triIndex, _tri1 );\n\t\t\t\t\tfor ( let e = 0; e < 3; e ++ ) {\n\n\t\t\t\t\t\tconst otherTriIndex = halfEdges.getSiblingTriangleIndex( triIndex, e );\n\t\t\t\t\t\tif ( otherTriIndex === - 1 ) {\n\n\t\t\t\t\t\t\tconst nextE = ( e + 1 ) % 3;\n\t\t\t\t\t\t\tconst v0 = _tri1[ vertKeys[ e ] ];\n\t\t\t\t\t\t\tconst v1 = _tri1[ vertKeys[ nextE ] ];\n\t\t\t\t\t\t\tconst edge = new Line3();\n\t\t\t\t\t\t\tedge.start.copy( v0 );\n\t\t\t\t\t\t\tedge.end.copy( v1 );\n\t\t\t\t\t\t\tedges.push( edge );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( let triIndex = offset; triIndex < triCount; triIndex ++ ) {\n\n\t\t\t\tgetTriangle( geometry, triIndex, _tri1 );\n\t\t\t\tfor ( let e = 0; e < 3; e ++ ) {\n\n\t\t\t\t\tconst otherTriIndex = halfEdges.getSiblingTriangleIndex( triIndex, e );\n\t\t\t\t\tif ( otherTriIndex === - 1 ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// get other triangle\n\t\t\t\t\tgetTriangle( geometry, otherTriIndex, _tri2 );\n\n\t\t\t\t\t// get edge centers\n\t\t\t\t\tconst nextE = ( e + 1 ) % 3;\n\t\t\t\t\tconst v0 = _tri1[ vertKeys[ e ] ];\n\t\t\t\t\tconst v1 = _tri1[ vertKeys[ nextE ] ];\n\t\t\t\t\t_centerPoint.lerpVectors( v0, v1, 0.5 );\n\t\t\t\t\taddConnectionEdge( _tri1, _tri2, _centerPoint );\n\n\t\t\t\t}\n\n\t\t\t\tif ( halfEdges.disjointConnections ) {\n\n\t\t\t\t\tfor ( let e = 0; e < 3; e ++ ) {\n\n\t\t\t\t\t\tconst disjointTriIndices = halfEdges.getDisjointSiblingTriangleIndices( triIndex, e );\n\t\t\t\t\t\tconst disjointEdgeIndices = halfEdges.getDisjointSiblingEdgeIndices( triIndex, e );\n\n\t\t\t\t\t\tfor ( let i = 0; i < disjointTriIndices.length; i ++ ) {\n\n\t\t\t\t\t\t\tconst ti = disjointTriIndices[ i ];\n\t\t\t\t\t\t\tconst ei = disjointEdgeIndices[ i ];\n\n\t\t\t\t\t\t\t// get other triangle\n\t\t\t\t\t\t\tgetTriangle( geometry, ti, _tri2 );\n\n\t\t\t\t\t\t\tgetOverlapEdge( _tri1, e, _tri2, ei, _edge );\n\n\t\t\t\t\t\t\t_centerPoint.lerpVectors( _edge.start, _edge.end, 0.5 );\n\t\t\t\t\t\t\taddConnectionEdge( _tri1, _tri2, _centerPoint );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tsuper.setEdges( edges );\n\n\t\tfunction addConnectionEdge( tri1, tri2, centerPoint ) {\n\n\t\t\ttri1.getMidpoint( _center );\n\t\t\ttri2.getMidpoint( _center2 );\n\n\t\t\ttri1.getPlane( _plane );\n\t\t\ttri2.getPlane( _plane2 );\n\n\t\t\tconst edge = new Line3();\n\t\t\tedge.start.copy( _center );\n\n\t\t\tif ( straightEdges ) {\n\n\t\t\t\t// get the projected centers\n\t\t\t\t_plane.projectPoint( _center2, _projected );\n\t\t\t\t_plane2.projectPoint( _center, _projected2 );\n\n\t\t\t\t// get the directions so we can flip them if needed\n\t\t\t\t_projectedDir.subVectors( _projected, _center );\n\t\t\t\t_projectedDir2.subVectors( _projected2, _center2 );\n\n\t\t\t\t// get the directions so we can flip them if needed\n\t\t\t\t_edgeDir.subVectors( centerPoint, _center );\n\t\t\t\t_edgeDir2.subVectors( centerPoint, _center2 );\n\n\t\t\t\tif ( _projectedDir.dot( _edgeDir ) < 0 ) {\n\n\t\t\t\t\t_projectedDir.multiplyScalar( - 1 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( _projectedDir2.dot( _edgeDir2 ) < 0 ) {\n\n\t\t\t\t\t_projectedDir2.multiplyScalar( - 1 );\n\n\t\t\t\t}\n\n\t\t\t\t// find the new points after inversion\n\t\t\t\t_vec.addVectors( _center, _projectedDir );\n\t\t\t\t_vec2.addVectors( _center2, _projectedDir2 );\n\n\t\t\t\t// project the points onto the triangle edge. This would be better\n\t\t\t\t// if we clipped instead of chose the closest point\n\t\t\t\ttri1.closestPointToPoint( _vec, _finalPoint );\n\t\t\t\ttri2.closestPointToPoint( _vec2, _finalPoint2 );\n\n\t\t\t\tedge.end.lerpVectors( _finalPoint, _finalPoint2, 0.5 );\n\n\t\t\t} else {\n\n\t\t\t\tedge.end.copy( centerPoint );\n\n\t\t\t}\n\n\t\t\tedges.push( edge );\n\n\t\t}\n\n\t}\n\n}\n"],"mappings":"AAAA,SAASA,KAAK,EAAEC,QAAQ,EAAEC,OAAO,EAAEC,KAAK,EAAEC,GAAG,QAAQ,OAAO;AAC5D,SAASC,WAAW,QAAQ,kBAAkB;AAC9C,SAASC,WAAW,QAAQ,gCAAgC;AAC5D,SAASC,eAAe,QAAQ,4BAA4B;AAE5D,MAAMC,QAAQ,GAAG,CAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAE;AAClC,MAAMC,KAAK,GAAG,IAAIR,QAAQ,CAAC,CAAC;AAC5B,MAAMS,KAAK,GAAG,IAAIT,QAAQ,CAAC,CAAC;AAC5B,MAAMU,OAAO,GAAG,IAAIT,OAAO,CAAC,CAAC;AAC7B,MAAMU,QAAQ,GAAG,IAAIV,OAAO,CAAC,CAAC;AAC9B,MAAMW,UAAU,GAAG,IAAIX,OAAO,CAAC,CAAC;AAChC,MAAMY,WAAW,GAAG,IAAIZ,OAAO,CAAC,CAAC;AACjC,MAAMa,aAAa,GAAG,IAAIb,OAAO,CAAC,CAAC;AACnC,MAAMc,cAAc,GAAG,IAAId,OAAO,CAAC,CAAC;AACpC,MAAMe,QAAQ,GAAG,IAAIf,OAAO,CAAC,CAAC;AAC9B,MAAMgB,SAAS,GAAG,IAAIhB,OAAO,CAAC,CAAC;AAC/B,MAAMiB,IAAI,GAAG,IAAIjB,OAAO,CAAC,CAAC;AAC1B,MAAMkB,KAAK,GAAG,IAAIlB,OAAO,CAAC,CAAC;AAC3B,MAAMmB,WAAW,GAAG,IAAInB,OAAO,CAAC,CAAC;AACjC,MAAMoB,YAAY,GAAG,IAAIpB,OAAO,CAAC,CAAC;AAClC,MAAMqB,MAAM,GAAG,IAAIpB,KAAK,CAAC,CAAC;AAC1B,MAAMqB,OAAO,GAAG,IAAIrB,KAAK,CAAC,CAAC;AAC3B,MAAMsB,YAAY,GAAG,IAAIvB,OAAO,CAAC,CAAC;AAClC,MAAMwB,IAAI,GAAG,IAAItB,GAAG,CAAC,CAAC;AACtB,MAAMuB,KAAK,GAAG,IAAI3B,KAAK,CAAC,CAAC;AAEzB,SAAS4B,WAAWA,CAAEC,QAAQ,EAAEC,QAAQ,EAAEC,MAAM,EAAG;EAElD,MAAMC,EAAE,GAAG,CAAC,GAAGF,QAAQ;EACvB,IAAIG,EAAE,GAAGD,EAAE,GAAG,CAAC;EACf,IAAIE,EAAE,GAAGF,EAAE,GAAG,CAAC;EACf,IAAIG,EAAE,GAAGH,EAAE,GAAG,CAAC;EAEf,MAAMI,SAAS,GAAGP,QAAQ,CAACQ,KAAK;EAChC,MAAMC,OAAO,GAAGT,QAAQ,CAACU,UAAU,CAACC,QAAQ;EAC5C,IAAKJ,SAAS,EAAG;IAEhBH,EAAE,GAAGG,SAAS,CAACK,IAAI,CAAER,EAAG,CAAC;IACzBC,EAAE,GAAGE,SAAS,CAACK,IAAI,CAAEP,EAAG,CAAC;IACzBC,EAAE,GAAGC,SAAS,CAACK,IAAI,CAAEN,EAAG,CAAC;EAE1B;EAEAJ,MAAM,CAACW,CAAC,CAACC,mBAAmB,CAAEL,OAAO,EAAEL,EAAG,CAAC;EAC3CF,MAAM,CAACa,CAAC,CAACD,mBAAmB,CAAEL,OAAO,EAAEJ,EAAG,CAAC;EAC3CH,MAAM,CAACc,CAAC,CAACF,mBAAmB,CAAEL,OAAO,EAAEH,EAAG,CAAC;EAE3C,OAAOJ,MAAM;AAEd;AAEA,SAASe,cAAcA,CAAEC,IAAI,EAAEC,EAAE,EAAEC,IAAI,EAAEC,EAAE,EAAEnB,MAAM,EAAG;EAErD;EACA,MAAMoB,OAAO,GAAG,CAAEH,EAAE,GAAG,CAAC,IAAK,CAAC;EAC9B,MAAMI,IAAI,GAAGL,IAAI,CAAEvC,QAAQ,CAAEwC,EAAE,CAAE,CAAE;EACnC,MAAMK,IAAI,GAAGN,IAAI,CAAEvC,QAAQ,CAAE2C,OAAO,CAAE,CAAE;EAExC,MAAMG,OAAO,GAAG,CAAEJ,EAAE,GAAG,CAAC,IAAK,CAAC;EAC9B,MAAMK,IAAI,GAAGN,IAAI,CAAEzC,QAAQ,CAAE0C,EAAE,CAAE,CAAE;EACnC,MAAMM,IAAI,GAAGP,IAAI,CAAEzC,QAAQ,CAAE8C,OAAO,CAAE,CAAE;;EAExC;EACA/C,eAAe,CAAE6C,IAAI,EAAEC,IAAI,EAAE3B,IAAK,CAAC;;EAEnC;EACA,IAAI+B,IAAI,GAAGtC,IAAI,CAACuC,UAAU,CAAEN,IAAI,EAAE1B,IAAI,CAACiC,MAAO,CAAC,CAACC,GAAG,CAAElC,IAAI,CAACmC,SAAU,CAAC;EACrE,IAAIC,IAAI,GAAG3C,IAAI,CAACuC,UAAU,CAAEL,IAAI,EAAE3B,IAAI,CAACiC,MAAO,CAAC,CAACC,GAAG,CAAElC,IAAI,CAACmC,SAAU,CAAC;EACrE,IAAKJ,IAAI,GAAGK,IAAI,EAAG,CAAEL,IAAI,EAAEK,IAAI,CAAE,GAAG,CAAEA,IAAI,EAAEL,IAAI,CAAE;EAElD,IAAIM,IAAI,GAAG5C,IAAI,CAACuC,UAAU,CAAEH,IAAI,EAAE7B,IAAI,CAACiC,MAAO,CAAC,CAACC,GAAG,CAAElC,IAAI,CAACmC,SAAU,CAAC;EACrE,IAAIG,IAAI,GAAG7C,IAAI,CAACuC,UAAU,CAAEF,IAAI,EAAE9B,IAAI,CAACiC,MAAO,CAAC,CAACC,GAAG,CAAElC,IAAI,CAACmC,SAAU,CAAC;EACrE,IAAKE,IAAI,GAAGC,IAAI,EAAG,CAAED,IAAI,EAAEC,IAAI,CAAE,GAAG,CAAEA,IAAI,EAAED,IAAI,CAAE;;EAElD;EACA,MAAME,OAAO,GAAGC,IAAI,CAACC,GAAG,CAAEV,IAAI,EAAEM,IAAK,CAAC;EACtC,MAAMK,OAAO,GAAGF,IAAI,CAACG,GAAG,CAAEP,IAAI,EAAEE,IAAK,CAAC;EACtCtC,IAAI,CAAC4C,EAAE,CAAEL,OAAO,EAAElC,MAAM,CAACwC,KAAM,CAAC;EAChC7C,IAAI,CAAC4C,EAAE,CAAEF,OAAO,EAAErC,MAAM,CAACyC,GAAI,CAAC;AAE/B;AAGA,OAAO,MAAMC,cAAc,SAASpE,WAAW,CAAC;EAE/CqE,WAAWA,CAAE7C,QAAQ,GAAG,IAAI,EAAE8C,SAAS,GAAG,IAAI,EAAG;IAEhD,KAAK,CAAC,CAAC;IACP,IAAI,CAACC,aAAa,GAAG,KAAK;IAC1B,IAAI,CAACC,wBAAwB,GAAG,KAAK;IAErC,IAAKhD,QAAQ,IAAI8C,SAAS,EAAG;MAE5B,IAAI,CAACG,YAAY,CAAEjD,QAAQ,EAAE8C,SAAU,CAAC;IAEzC;EAED;EAEAG,YAAYA,CAAEjD,QAAQ,EAAE8C,SAAS,EAAG;IAEnC,MAAM;MAAEC,aAAa;MAAEC;IAAyB,CAAC,GAAG,IAAI;IACxD,MAAME,KAAK,GAAG,EAAE;IAChB,MAAMC,MAAM,GAAGnD,QAAQ,CAACoD,SAAS,CAACV,KAAK;IACvC,IAAIW,QAAQ,GAAG5E,WAAW,CAAEuB,QAAS,CAAC;IACtC,IAAKA,QAAQ,CAACoD,SAAS,CAACE,KAAK,KAAKC,QAAQ,EAAG;MAE5CF,QAAQ,GAAG,CAAE,EAAIrD,QAAQ,CAACoD,SAAS,CAACE,KAAK,GAAG,CAAC,CAAE;IAEhD;IAEA,IAAKN,wBAAwB,EAAG;MAE/B,IAAKF,SAAS,CAACU,sBAAsB,EAAG;QAEvCV,SAAS,CACPU,sBAAsB,CACtBC,OAAO,CAAE,CAAE;UAAEC,OAAO;UAAEC,OAAO;UAAEC;QAAI,CAAC,KAAM;UAE1C,CAAE,GAAGF,OAAO,EAAE,GAAGC,OAAO,CAAE,CACxBF,OAAO,CAAE,CAAE;YAAEf,KAAK;YAAEC;UAAI,CAAC,KAAM;YAE/B,MAAMkB,IAAI,GAAG,IAAI1F,KAAK,CAAC,CAAC;YACxByF,GAAG,CAACnB,EAAE,CAAEC,KAAK,EAAEmB,IAAI,CAACnB,KAAM,CAAC;YAC3BkB,GAAG,CAACnB,EAAE,CAAEE,GAAG,EAAEkB,IAAI,CAAClB,GAAI,CAAC;YACvBO,KAAK,CAACY,IAAI,CAAED,IAAK,CAAC;UAEnB,CAAE,CAAC;QAEL,CAAE,CAAC;MAEL,CAAC,MAAM;QAEN,KAAM,IAAI5D,QAAQ,GAAGkD,MAAM,EAAElD,QAAQ,GAAGoD,QAAQ,EAAEpD,QAAQ,EAAG,EAAG;UAE/DF,WAAW,CAAEC,QAAQ,EAAEC,QAAQ,EAAErB,KAAM,CAAC;UACxC,KAAM,IAAImF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAG,EAAG;YAE9B,MAAMC,aAAa,GAAGlB,SAAS,CAACmB,uBAAuB,CAAEhE,QAAQ,EAAE8D,CAAE,CAAC;YACtE,IAAKC,aAAa,KAAK,CAAE,CAAC,EAAG;cAE5B,MAAME,KAAK,GAAG,CAAEH,CAAC,GAAG,CAAC,IAAK,CAAC;cAC3B,MAAMI,EAAE,GAAGvF,KAAK,CAAED,QAAQ,CAAEoF,CAAC,CAAE,CAAE;cACjC,MAAMK,EAAE,GAAGxF,KAAK,CAAED,QAAQ,CAAEuF,KAAK,CAAE,CAAE;cACrC,MAAML,IAAI,GAAG,IAAI1F,KAAK,CAAC,CAAC;cACxB0F,IAAI,CAACnB,KAAK,CAAC2B,IAAI,CAAEF,EAAG,CAAC;cACrBN,IAAI,CAAClB,GAAG,CAAC0B,IAAI,CAAED,EAAG,CAAC;cACnBlB,KAAK,CAACY,IAAI,CAAED,IAAK,CAAC;YAEnB;UAED;QAED;MAED;IAED,CAAC,MAAM;MAEN,KAAM,IAAI5D,QAAQ,GAAGkD,MAAM,EAAElD,QAAQ,GAAGoD,QAAQ,EAAEpD,QAAQ,EAAG,EAAG;QAE/DF,WAAW,CAAEC,QAAQ,EAAEC,QAAQ,EAAErB,KAAM,CAAC;QACxC,KAAM,IAAImF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAG,EAAG;UAE9B,MAAMC,aAAa,GAAGlB,SAAS,CAACmB,uBAAuB,CAAEhE,QAAQ,EAAE8D,CAAE,CAAC;UACtE,IAAKC,aAAa,KAAK,CAAE,CAAC,EAAG;YAE5B;UAED;;UAEA;UACAjE,WAAW,CAAEC,QAAQ,EAAEgE,aAAa,EAAEnF,KAAM,CAAC;;UAE7C;UACA,MAAMqF,KAAK,GAAG,CAAEH,CAAC,GAAG,CAAC,IAAK,CAAC;UAC3B,MAAMI,EAAE,GAAGvF,KAAK,CAAED,QAAQ,CAAEoF,CAAC,CAAE,CAAE;UACjC,MAAMK,EAAE,GAAGxF,KAAK,CAAED,QAAQ,CAAEuF,KAAK,CAAE,CAAE;UACrCtE,YAAY,CAAC0E,WAAW,CAAEH,EAAE,EAAEC,EAAE,EAAE,GAAI,CAAC;UACvCG,iBAAiB,CAAE3F,KAAK,EAAEC,KAAK,EAAEe,YAAa,CAAC;QAEhD;QAEA,IAAKkD,SAAS,CAAC0B,mBAAmB,EAAG;UAEpC,KAAM,IAAIT,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAG,EAAG;YAE9B,MAAMU,kBAAkB,GAAG3B,SAAS,CAAC4B,iCAAiC,CAAEzE,QAAQ,EAAE8D,CAAE,CAAC;YACrF,MAAMY,mBAAmB,GAAG7B,SAAS,CAAC8B,6BAA6B,CAAE3E,QAAQ,EAAE8D,CAAE,CAAC;YAElF,KAAM,IAAIc,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,kBAAkB,CAACK,MAAM,EAAED,CAAC,EAAG,EAAG;cAEtD,MAAME,EAAE,GAAGN,kBAAkB,CAAEI,CAAC,CAAE;cAClC,MAAMG,EAAE,GAAGL,mBAAmB,CAAEE,CAAC,CAAE;;cAEnC;cACA9E,WAAW,CAAEC,QAAQ,EAAE+E,EAAE,EAAElG,KAAM,CAAC;cAElCoC,cAAc,CAAErC,KAAK,EAAEmF,CAAC,EAAElF,KAAK,EAAEmG,EAAE,EAAElF,KAAM,CAAC;cAE5CF,YAAY,CAAC0E,WAAW,CAAExE,KAAK,CAAC4C,KAAK,EAAE5C,KAAK,CAAC6C,GAAG,EAAE,GAAI,CAAC;cACvD4B,iBAAiB,CAAE3F,KAAK,EAAEC,KAAK,EAAEe,YAAa,CAAC;YAEhD;UAED;QAED;MAED;IAED;IAEA,KAAK,CAACqF,QAAQ,CAAE/B,KAAM,CAAC;IAEvB,SAASqB,iBAAiBA,CAAErD,IAAI,EAAEE,IAAI,EAAE8D,WAAW,EAAG;MAErDhE,IAAI,CAACiE,WAAW,CAAErG,OAAQ,CAAC;MAC3BsC,IAAI,CAAC+D,WAAW,CAAEpG,QAAS,CAAC;MAE5BmC,IAAI,CAACkE,QAAQ,CAAE1F,MAAO,CAAC;MACvB0B,IAAI,CAACgE,QAAQ,CAAEzF,OAAQ,CAAC;MAExB,MAAMkE,IAAI,GAAG,IAAI1F,KAAK,CAAC,CAAC;MACxB0F,IAAI,CAACnB,KAAK,CAAC2B,IAAI,CAAEvF,OAAQ,CAAC;MAE1B,IAAKiE,aAAa,EAAG;QAEpB;QACArD,MAAM,CAAC2F,YAAY,CAAEtG,QAAQ,EAAEC,UAAW,CAAC;QAC3CW,OAAO,CAAC0F,YAAY,CAAEvG,OAAO,EAAEG,WAAY,CAAC;;QAE5C;QACAC,aAAa,CAAC2C,UAAU,CAAE7C,UAAU,EAAEF,OAAQ,CAAC;QAC/CK,cAAc,CAAC0C,UAAU,CAAE5C,WAAW,EAAEF,QAAS,CAAC;;QAElD;QACAK,QAAQ,CAACyC,UAAU,CAAEqD,WAAW,EAAEpG,OAAQ,CAAC;QAC3CO,SAAS,CAACwC,UAAU,CAAEqD,WAAW,EAAEnG,QAAS,CAAC;QAE7C,IAAKG,aAAa,CAAC6C,GAAG,CAAE3C,QAAS,CAAC,GAAG,CAAC,EAAG;UAExCF,aAAa,CAACoG,cAAc,CAAE,CAAE,CAAE,CAAC;QAEpC;QAEA,IAAKnG,cAAc,CAAC4C,GAAG,CAAE1C,SAAU,CAAC,GAAG,CAAC,EAAG;UAE1CF,cAAc,CAACmG,cAAc,CAAE,CAAE,CAAE,CAAC;QAErC;;QAEA;QACAhG,IAAI,CAACiG,UAAU,CAAEzG,OAAO,EAAEI,aAAc,CAAC;QACzCK,KAAK,CAACgG,UAAU,CAAExG,QAAQ,EAAEI,cAAe,CAAC;;QAE5C;QACA;QACA+B,IAAI,CAACsE,mBAAmB,CAAElG,IAAI,EAAEE,WAAY,CAAC;QAC7C4B,IAAI,CAACoE,mBAAmB,CAAEjG,KAAK,EAAEE,YAAa,CAAC;QAE/CoE,IAAI,CAAClB,GAAG,CAAC2B,WAAW,CAAE9E,WAAW,EAAEC,YAAY,EAAE,GAAI,CAAC;MAEvD,CAAC,MAAM;QAENoE,IAAI,CAAClB,GAAG,CAAC0B,IAAI,CAAEa,WAAY,CAAC;MAE7B;MAEAhC,KAAK,CAACY,IAAI,CAAED,IAAK,CAAC;IAEnB;EAED;AAED"},"metadata":{},"sourceType":"module","externalDependencies":[]}