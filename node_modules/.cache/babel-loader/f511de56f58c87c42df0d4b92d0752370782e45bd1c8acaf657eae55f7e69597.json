{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree } from '@react-three/fiber';\nimport { useGesture } from '@use-gesture/react';\nconst initialModelPosition = new THREE.Vector3();\nconst mousePosition2D = new THREE.Vector2();\nconst mousePosition3D = new THREE.Vector3();\nconst dragOffset = new THREE.Vector3();\nconst dragPlaneNormal = new THREE.Vector3();\nconst dragPlane = new THREE.Plane();\nconst DragControls = /*#__PURE__*/React.forwardRef((_ref, fRef) => {\n  let {\n    autoTransform = true,\n    matrix,\n    axisLock,\n    dragLimits,\n    onHover,\n    onDragStart,\n    onDrag,\n    onDragEnd,\n    children,\n    ...props\n  } = _ref;\n  // @ts-expect-error new in @react-three/fiber@7.0.5\n  const defaultControls = useThree(state => state.controls);\n  const {\n    camera,\n    size,\n    raycaster,\n    invalidate\n  } = useThree();\n  const ref = React.useRef(null);\n  const bind = useGesture({\n    onHover: _ref2 => {\n      let {\n        hovering\n      } = _ref2;\n      return onHover && onHover(hovering !== null && hovering !== void 0 ? hovering : false);\n    },\n    onDragStart: _ref3 => {\n      let {\n        event\n      } = _ref3;\n      defaultControls.enabled = false;\n      const {\n        point\n      } = event;\n      ref.current.matrix.decompose(initialModelPosition, new THREE.Quaternion(), new THREE.Vector3());\n      mousePosition3D.copy(point);\n      dragOffset.copy(mousePosition3D).sub(initialModelPosition);\n      onDragStart && onDragStart(initialModelPosition);\n      invalidate();\n    },\n    onDrag: _ref4 => {\n      let {\n        xy: [dragX, dragY],\n        intentional\n      } = _ref4;\n      if (!intentional) return;\n      const normalizedMouseX = (dragX - size.left) / size.width * 2 - 1;\n      const normalizedMouseY = -((dragY - size.top) / size.height) * 2 + 1;\n      mousePosition2D.set(normalizedMouseX, normalizedMouseY);\n      raycaster.setFromCamera(mousePosition2D, camera);\n      if (!axisLock) {\n        camera.getWorldDirection(dragPlaneNormal).negate();\n      } else {\n        switch (axisLock) {\n          case 'x':\n            dragPlaneNormal.set(1, 0, 0);\n            break;\n          case 'y':\n            dragPlaneNormal.set(0, 1, 0);\n            break;\n          case 'z':\n            dragPlaneNormal.set(0, 0, 1);\n            break;\n        }\n      }\n      dragPlane.setFromNormalAndCoplanarPoint(dragPlaneNormal, mousePosition3D);\n      raycaster.ray.intersectPlane(dragPlane, mousePosition3D);\n      const previousLocalMatrix = ref.current.matrix.clone();\n      const previousWorldMatrix = ref.current.matrixWorld.clone();\n      const intendedNewPosition = new THREE.Vector3(mousePosition3D.x - dragOffset.x, mousePosition3D.y - dragOffset.y, mousePosition3D.z - dragOffset.z);\n      if (dragLimits) {\n        intendedNewPosition.x = dragLimits[0] ? Math.max(Math.min(intendedNewPosition.x, dragLimits[0][1]), dragLimits[0][0]) : intendedNewPosition.x;\n        intendedNewPosition.y = dragLimits[1] ? Math.max(Math.min(intendedNewPosition.y, dragLimits[1][1]), dragLimits[1][0]) : intendedNewPosition.y;\n        intendedNewPosition.z = dragLimits[2] ? Math.max(Math.min(intendedNewPosition.z, dragLimits[2][1]), dragLimits[2][0]) : intendedNewPosition.z;\n      }\n      if (autoTransform) {\n        ref.current.matrix.setPosition(intendedNewPosition);\n        const deltaLocalMatrix = ref.current.matrix.clone().multiply(previousLocalMatrix.invert());\n        const deltaWorldMatrix = ref.current.matrix.clone().multiply(previousWorldMatrix.invert());\n        onDrag && onDrag(ref.current.matrix, deltaLocalMatrix, ref.current.matrixWorld, deltaWorldMatrix);\n      } else {\n        const tempMatrix = new THREE.Matrix4().copy(ref.current.matrix);\n        tempMatrix.setPosition(intendedNewPosition);\n        const deltaLocalMatrix = tempMatrix.clone().multiply(previousLocalMatrix.invert());\n        const deltaWorldMatrix = tempMatrix.clone().multiply(previousWorldMatrix.invert());\n        onDrag && onDrag(tempMatrix, deltaLocalMatrix, ref.current.matrixWorld, deltaWorldMatrix);\n      }\n      invalidate();\n    },\n    onDragEnd: () => {\n      defaultControls.enabled = true;\n      onDragEnd && onDragEnd();\n      invalidate();\n    }\n  }, {\n    drag: {\n      filterTaps: true,\n      threshold: 1\n    }\n  });\n  React.useImperativeHandle(fRef, () => ref.current, []);\n  React.useLayoutEffect(() => {\n    if (!matrix) return;\n\n    // If the matrix is a real matrix4 it means that the user wants to control the gizmo\n    // In that case it should just be set, as a bare prop update would merely copy it\n    ref.current.matrix = matrix;\n  }, [matrix]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: ref\n  }, bind(), {\n    matrix: matrix,\n    matrixAutoUpdate: false\n  }, props), children);\n});\nexport { DragControls };","map":{"version":3,"names":["_extends","React","THREE","useThree","useGesture","initialModelPosition","Vector3","mousePosition2D","Vector2","mousePosition3D","dragOffset","dragPlaneNormal","dragPlane","Plane","DragControls","forwardRef","_ref","fRef","autoTransform","matrix","axisLock","dragLimits","onHover","onDragStart","onDrag","onDragEnd","children","props","defaultControls","state","controls","camera","size","raycaster","invalidate","ref","useRef","bind","_ref2","hovering","_ref3","event","enabled","point","current","decompose","Quaternion","copy","sub","_ref4","xy","dragX","dragY","intentional","normalizedMouseX","left","width","normalizedMouseY","top","height","set","setFromCamera","getWorldDirection","negate","setFromNormalAndCoplanarPoint","ray","intersectPlane","previousLocalMatrix","clone","previousWorldMatrix","matrixWorld","intendedNewPosition","x","y","z","Math","max","min","setPosition","deltaLocalMatrix","multiply","invert","deltaWorldMatrix","tempMatrix","Matrix4","drag","filterTaps","threshold","useImperativeHandle","useLayoutEffect","createElement","matrixAutoUpdate"],"sources":["/Users/ratseevtimur/Documents/Test-Projects/door-3d/node_modules/@react-three/drei/web/DragControls.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree } from '@react-three/fiber';\nimport { useGesture } from '@use-gesture/react';\n\nconst initialModelPosition = new THREE.Vector3();\nconst mousePosition2D = new THREE.Vector2();\nconst mousePosition3D = new THREE.Vector3();\nconst dragOffset = new THREE.Vector3();\nconst dragPlaneNormal = new THREE.Vector3();\nconst dragPlane = new THREE.Plane();\nconst DragControls = /*#__PURE__*/React.forwardRef(({\n  autoTransform = true,\n  matrix,\n  axisLock,\n  dragLimits,\n  onHover,\n  onDragStart,\n  onDrag,\n  onDragEnd,\n  children,\n  ...props\n}, fRef) => {\n  // @ts-expect-error new in @react-three/fiber@7.0.5\n  const defaultControls = useThree(state => state.controls);\n  const {\n    camera,\n    size,\n    raycaster,\n    invalidate\n  } = useThree();\n  const ref = React.useRef(null);\n  const bind = useGesture({\n    onHover: ({\n      hovering\n    }) => onHover && onHover(hovering !== null && hovering !== void 0 ? hovering : false),\n    onDragStart: ({\n      event\n    }) => {\n      defaultControls.enabled = false;\n      const {\n        point\n      } = event;\n      ref.current.matrix.decompose(initialModelPosition, new THREE.Quaternion(), new THREE.Vector3());\n      mousePosition3D.copy(point);\n      dragOffset.copy(mousePosition3D).sub(initialModelPosition);\n      onDragStart && onDragStart(initialModelPosition);\n      invalidate();\n    },\n    onDrag: ({\n      xy: [dragX, dragY],\n      intentional\n    }) => {\n      if (!intentional) return;\n      const normalizedMouseX = (dragX - size.left) / size.width * 2 - 1;\n      const normalizedMouseY = -((dragY - size.top) / size.height) * 2 + 1;\n      mousePosition2D.set(normalizedMouseX, normalizedMouseY);\n      raycaster.setFromCamera(mousePosition2D, camera);\n      if (!axisLock) {\n        camera.getWorldDirection(dragPlaneNormal).negate();\n      } else {\n        switch (axisLock) {\n          case 'x':\n            dragPlaneNormal.set(1, 0, 0);\n            break;\n          case 'y':\n            dragPlaneNormal.set(0, 1, 0);\n            break;\n          case 'z':\n            dragPlaneNormal.set(0, 0, 1);\n            break;\n        }\n      }\n      dragPlane.setFromNormalAndCoplanarPoint(dragPlaneNormal, mousePosition3D);\n      raycaster.ray.intersectPlane(dragPlane, mousePosition3D);\n      const previousLocalMatrix = ref.current.matrix.clone();\n      const previousWorldMatrix = ref.current.matrixWorld.clone();\n      const intendedNewPosition = new THREE.Vector3(mousePosition3D.x - dragOffset.x, mousePosition3D.y - dragOffset.y, mousePosition3D.z - dragOffset.z);\n      if (dragLimits) {\n        intendedNewPosition.x = dragLimits[0] ? Math.max(Math.min(intendedNewPosition.x, dragLimits[0][1]), dragLimits[0][0]) : intendedNewPosition.x;\n        intendedNewPosition.y = dragLimits[1] ? Math.max(Math.min(intendedNewPosition.y, dragLimits[1][1]), dragLimits[1][0]) : intendedNewPosition.y;\n        intendedNewPosition.z = dragLimits[2] ? Math.max(Math.min(intendedNewPosition.z, dragLimits[2][1]), dragLimits[2][0]) : intendedNewPosition.z;\n      }\n      if (autoTransform) {\n        ref.current.matrix.setPosition(intendedNewPosition);\n        const deltaLocalMatrix = ref.current.matrix.clone().multiply(previousLocalMatrix.invert());\n        const deltaWorldMatrix = ref.current.matrix.clone().multiply(previousWorldMatrix.invert());\n        onDrag && onDrag(ref.current.matrix, deltaLocalMatrix, ref.current.matrixWorld, deltaWorldMatrix);\n      } else {\n        const tempMatrix = new THREE.Matrix4().copy(ref.current.matrix);\n        tempMatrix.setPosition(intendedNewPosition);\n        const deltaLocalMatrix = tempMatrix.clone().multiply(previousLocalMatrix.invert());\n        const deltaWorldMatrix = tempMatrix.clone().multiply(previousWorldMatrix.invert());\n        onDrag && onDrag(tempMatrix, deltaLocalMatrix, ref.current.matrixWorld, deltaWorldMatrix);\n      }\n      invalidate();\n    },\n    onDragEnd: () => {\n      defaultControls.enabled = true;\n      onDragEnd && onDragEnd();\n      invalidate();\n    }\n  }, {\n    drag: {\n      filterTaps: true,\n      threshold: 1\n    }\n  });\n  React.useImperativeHandle(fRef, () => ref.current, []);\n  React.useLayoutEffect(() => {\n    if (!matrix) return;\n\n    // If the matrix is a real matrix4 it means that the user wants to control the gizmo\n    // In that case it should just be set, as a bare prop update would merely copy it\n    ref.current.matrix = matrix;\n  }, [matrix]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: ref\n  }, bind(), {\n    matrix: matrix,\n    matrixAutoUpdate: false\n  }, props), children);\n});\n\nexport { DragControls };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}