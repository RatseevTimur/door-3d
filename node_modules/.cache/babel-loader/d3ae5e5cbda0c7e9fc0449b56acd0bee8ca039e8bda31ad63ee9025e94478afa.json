{"ast":null,"code":"import { TypeBackedArray } from './TypeBackedArray.js';\n\n// Utility class for for tracking attribute data in type-backed arrays for a set\n// of groups. The set of attributes is kept for each group and are expected to be the\n// same buffer type.\nexport class TypedAttributeData {\n  constructor() {\n    this.groupAttributes = [{}];\n    this.groupCount = 0;\n  }\n\n  // returns the buffer type for the given attribute\n  getType(name) {\n    return this.groupAttributes[0][name].type;\n  }\n  getItemSize(name) {\n    return this.groupAttributes[0][name].itemSize;\n  }\n  getNormalized(name) {\n    return this.groupAttributes[0][name].normalized;\n  }\n  getCount(index) {\n    if (this.groupCount <= index) {\n      return 0;\n    }\n    const pos = this.getGroupAttrArray('position', index);\n    return pos.length / pos.itemSize;\n  }\n\n  // returns the total length required for all groups for the given attribute\n  getTotalLength(name) {\n    const {\n      groupCount,\n      groupAttributes\n    } = this;\n    let length = 0;\n    for (let i = 0; i < groupCount; i++) {\n      const attrSet = groupAttributes[i];\n      length += attrSet[name].length;\n    }\n    return length;\n  }\n  getGroupAttrSet() {\n    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    // TODO: can this be abstracted?\n    // Return the exiting group set if necessary\n    const {\n      groupAttributes\n    } = this;\n    if (groupAttributes[index]) {\n      this.groupCount = Math.max(this.groupCount, index + 1);\n      return groupAttributes[index];\n    }\n\n    // add any new group sets required\n    const refAttrSet = groupAttributes[0];\n    this.groupCount = Math.max(this.groupCount, index + 1);\n    while (index >= groupAttributes.length) {\n      const newAttrSet = {};\n      groupAttributes.push(newAttrSet);\n      for (const key in refAttrSet) {\n        const refAttr = refAttrSet[key];\n        const newAttr = new TypeBackedArray(refAttr.type);\n        newAttr.itemSize = refAttr.itemSize;\n        newAttr.normalized = refAttr.normalized;\n        newAttrSet[key] = newAttr;\n      }\n    }\n    return groupAttributes[index];\n  }\n\n  // Get the raw array for the group set of data\n  getGroupAttrArray(name) {\n    let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    // throw an error if we've never\n    const {\n      groupAttributes\n    } = this;\n    const referenceAttrSet = groupAttributes[0];\n    const referenceAttr = referenceAttrSet[name];\n    if (!referenceAttr) {\n      throw new Error(\"TypedAttributeData: Attribute with \\\"\".concat(name, \"\\\" has not been initialized\"));\n    }\n    return this.getGroupAttrSet(index)[name];\n  }\n\n  // initializes an attribute array with the given name, type, and size\n  initializeArray(name, type, itemSize, normalized) {\n    const {\n      groupAttributes\n    } = this;\n    const referenceAttrSet = groupAttributes[0];\n    const referenceAttr = referenceAttrSet[name];\n    if (referenceAttr) {\n      if (referenceAttr.type !== type) {\n        for (let i = 0, l = groupAttributes.length; i < l; i++) {\n          const arr = groupAttributes[i][name];\n          arr.setType(type);\n          arr.itemSize = itemSize;\n          arr.normalized = normalized;\n        }\n      }\n    } else {\n      for (let i = 0, l = groupAttributes.length; i < l; i++) {\n        const arr = new TypeBackedArray(type);\n        arr.itemSize = itemSize;\n        arr.normalized = normalized;\n        groupAttributes[i][name] = arr;\n      }\n    }\n  }\n\n  // Clear all the data\n  clear() {\n    this.groupCount = 0;\n    const {\n      groupAttributes\n    } = this;\n    groupAttributes.forEach(attrSet => {\n      for (const key in attrSet) {\n        attrSet[key].clear();\n      }\n    });\n  }\n\n  // Remove the given key\n  delete(key) {\n    this.groupAttributes.forEach(attrSet => {\n      delete attrSet[key];\n    });\n  }\n\n  // Reset the datasets completely\n  reset() {\n    this.groupAttributes = [];\n    this.groupCount = 0;\n  }\n}","map":{"version":3,"names":["TypeBackedArray","TypedAttributeData","constructor","groupAttributes","groupCount","getType","name","type","getItemSize","itemSize","getNormalized","normalized","getCount","index","pos","getGroupAttrArray","length","getTotalLength","i","attrSet","getGroupAttrSet","arguments","undefined","Math","max","refAttrSet","newAttrSet","push","key","refAttr","newAttr","referenceAttrSet","referenceAttr","Error","concat","initializeArray","l","arr","setType","clear","forEach","delete","reset"],"sources":["/Users/ratseevtimur/Documents/Test-Projects/door-3d/node_modules/three-bvh-csg/src/core/TypedAttributeData.js"],"sourcesContent":["import { TypeBackedArray } from './TypeBackedArray.js';\n\n// Utility class for for tracking attribute data in type-backed arrays for a set\n// of groups. The set of attributes is kept for each group and are expected to be the\n// same buffer type.\nexport class TypedAttributeData {\n\n\tconstructor() {\n\n\t\tthis.groupAttributes = [ {} ];\n\t\tthis.groupCount = 0;\n\n\t}\n\n\t// returns the buffer type for the given attribute\n\tgetType( name ) {\n\n\t\treturn this.groupAttributes[ 0 ][ name ].type;\n\n\t}\n\n\tgetItemSize( name ) {\n\n\t\treturn this.groupAttributes[ 0 ][ name ].itemSize;\n\n\t}\n\n\tgetNormalized( name ) {\n\n\t\treturn this.groupAttributes[ 0 ][ name ].normalized;\n\n\t}\n\n\tgetCount( index ) {\n\n\t\tif ( this.groupCount <= index ) {\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst pos = this.getGroupAttrArray( 'position', index );\n\t\treturn pos.length / pos.itemSize;\n\n\t}\n\n\t// returns the total length required for all groups for the given attribute\n\tgetTotalLength( name ) {\n\n\t\tconst { groupCount, groupAttributes } = this;\n\n\t\tlet length = 0;\n\t\tfor ( let i = 0; i < groupCount; i ++ ) {\n\n\t\t\tconst attrSet = groupAttributes[ i ];\n\t\t\tlength += attrSet[ name ].length;\n\n\t\t}\n\n\t\treturn length;\n\n\t}\n\n\tgetGroupAttrSet( index = 0 ) {\n\n\t\t// TODO: can this be abstracted?\n\t\t// Return the exiting group set if necessary\n\t\tconst { groupAttributes } = this;\n\t\tif ( groupAttributes[ index ] ) {\n\n\t\t\tthis.groupCount = Math.max( this.groupCount, index + 1 );\n\t\t\treturn groupAttributes[ index ];\n\n\t\t}\n\n\t\t// add any new group sets required\n\t\tconst refAttrSet = groupAttributes[ 0 ];\n\t\tthis.groupCount = Math.max( this.groupCount, index + 1 );\n\t\twhile ( index >= groupAttributes.length ) {\n\n\t\t\tconst newAttrSet = {};\n\t\t\tgroupAttributes.push( newAttrSet );\n\t\t\tfor ( const key in refAttrSet ) {\n\n\t\t\t\tconst refAttr = refAttrSet[ key ];\n\t\t\t\tconst newAttr = new TypeBackedArray( refAttr.type );\n\t\t\t\tnewAttr.itemSize = refAttr.itemSize;\n\t\t\t\tnewAttr.normalized = refAttr.normalized;\n\t\t\t\tnewAttrSet[ key ] = newAttr;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn groupAttributes[ index ];\n\n\t}\n\n\t// Get the raw array for the group set of data\n\tgetGroupAttrArray( name, index = 0 ) {\n\n\t\t// throw an error if we've never\n\t\tconst { groupAttributes } = this;\n\t\tconst referenceAttrSet = groupAttributes[ 0 ];\n\t\tconst referenceAttr = referenceAttrSet[ name ];\n\t\tif ( ! referenceAttr ) {\n\n\t\t\tthrow new Error( `TypedAttributeData: Attribute with \"${ name }\" has not been initialized` );\n\n\t\t}\n\n\t\treturn this.getGroupAttrSet( index )[ name ];\n\n\t}\n\n\t// initializes an attribute array with the given name, type, and size\n\tinitializeArray( name, type, itemSize, normalized ) {\n\n\t\tconst { groupAttributes } = this;\n\t\tconst referenceAttrSet = groupAttributes[ 0 ];\n\t\tconst referenceAttr = referenceAttrSet[ name ];\n\t\tif ( referenceAttr ) {\n\n\t\t\tif ( referenceAttr.type !== type ) {\n\n\t\t\t\tfor ( let i = 0, l = groupAttributes.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst arr = groupAttributes[ i ][ name ];\n\t\t\t\t\tarr.setType( type );\n\t\t\t\t\tarr.itemSize = itemSize;\n\t\t\t\t\tarr.normalized = normalized;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0, l = groupAttributes.length; i < l; i ++ ) {\n\n\t\t\t\tconst arr = new TypeBackedArray( type );\n\t\t\t\tarr.itemSize = itemSize;\n\t\t\t\tarr.normalized = normalized;\n\t\t\t\tgroupAttributes[ i ][ name ] = arr;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Clear all the data\n\tclear() {\n\n\t\tthis.groupCount = 0;\n\n\t\tconst { groupAttributes } = this;\n\t\tgroupAttributes.forEach( attrSet => {\n\n\t\t\tfor ( const key in attrSet ) {\n\n\t\t\t\tattrSet[ key ].clear();\n\n\t\t\t}\n\n\n\t\t} );\n\n\t}\n\n\t// Remove the given key\n\tdelete( key ) {\n\n\t\tthis.groupAttributes.forEach( attrSet => {\n\n\t\t\tdelete attrSet[ key ];\n\n\t\t} );\n\n\t}\n\n\t// Reset the datasets completely\n\treset() {\n\n\t\tthis.groupAttributes = [];\n\t\tthis.groupCount = 0;\n\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}