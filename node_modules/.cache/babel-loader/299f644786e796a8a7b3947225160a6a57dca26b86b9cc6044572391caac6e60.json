{"ast":null,"code":"import { Mesh, Matrix4 } from 'three';\nimport { MeshBVH } from 'three-mesh-bvh';\nimport { HalfEdgeMap } from './HalfEdgeMap.js';\nimport { areSharedArrayBuffersSupported, convertToSharedArrayBuffer, ensureIndex, getTriCount } from './utils/geometryUtils.js';\nexport class Brush extends Mesh {\n  constructor() {\n    super(...arguments);\n    this.isBrush = true;\n    this._previousMatrix = new Matrix4();\n    this._previousMatrix.elements.fill(0);\n  }\n  markUpdated() {\n    this._previousMatrix.copy(this.matrix);\n  }\n  isDirty() {\n    const {\n      matrix,\n      _previousMatrix\n    } = this;\n    const el1 = matrix.elements;\n    const el2 = _previousMatrix.elements;\n    for (let i = 0; i < 16; i++) {\n      if (el1[i] !== el2[i]) {\n        return true;\n      }\n    }\n    return false;\n  }\n  prepareGeometry() {\n    // generate shared array buffers\n    const geometry = this.geometry;\n    const attributes = geometry.attributes;\n    const useSharedArrayBuffer = areSharedArrayBuffersSupported();\n    if (useSharedArrayBuffer) {\n      for (const key in attributes) {\n        const attribute = attributes[key];\n        if (attribute.isInterleavedBufferAttribute) {\n          throw new Error('Brush: InterleavedBufferAttributes are not supported.');\n        }\n        attribute.array = convertToSharedArrayBuffer(attribute.array);\n      }\n    }\n\n    // generate bounds tree\n    if (!geometry.boundsTree) {\n      ensureIndex(geometry, {\n        useSharedArrayBuffer\n      });\n      geometry.boundsTree = new MeshBVH(geometry, {\n        maxLeafTris: 3,\n        indirect: true,\n        useSharedArrayBuffer\n      });\n    }\n\n    // generate half edges\n    if (!geometry.halfEdges) {\n      geometry.halfEdges = new HalfEdgeMap(geometry);\n    }\n\n    // save group indices for materials\n    if (!geometry.groupIndices) {\n      const triCount = getTriCount(geometry);\n      const array = new Uint16Array(triCount);\n      const groups = geometry.groups;\n      for (let i = 0, l = groups.length; i < l; i++) {\n        const {\n          start,\n          count\n        } = groups[i];\n        for (let g = start / 3, lg = (start + count) / 3; g < lg; g++) {\n          array[g] = i;\n        }\n      }\n      geometry.groupIndices = array;\n    }\n  }\n  disposeCacheData() {\n    const {\n      geometry\n    } = this;\n    geometry.halfEdges = null;\n    geometry.boundsTree = null;\n    geometry.groupIndices = null;\n  }\n}","map":{"version":3,"names":["Mesh","Matrix4","MeshBVH","HalfEdgeMap","areSharedArrayBuffersSupported","convertToSharedArrayBuffer","ensureIndex","getTriCount","Brush","constructor","arguments","isBrush","_previousMatrix","elements","fill","markUpdated","copy","matrix","isDirty","el1","el2","i","prepareGeometry","geometry","attributes","useSharedArrayBuffer","key","attribute","isInterleavedBufferAttribute","Error","array","boundsTree","maxLeafTris","indirect","halfEdges","groupIndices","triCount","Uint16Array","groups","l","length","start","count","g","lg","disposeCacheData"],"sources":["/Users/ratseevtimur/Documents/Test-Projects/door-3d/node_modules/three-bvh-csg/src/core/Brush.js"],"sourcesContent":["import { Mesh, Matrix4 } from 'three';\nimport { MeshBVH } from 'three-mesh-bvh';\nimport { HalfEdgeMap } from './HalfEdgeMap.js';\nimport { areSharedArrayBuffersSupported, convertToSharedArrayBuffer, ensureIndex, getTriCount } from './utils/geometryUtils.js';\n\nexport class Brush extends Mesh {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.isBrush = true;\n\t\tthis._previousMatrix = new Matrix4();\n\t\tthis._previousMatrix.elements.fill( 0 );\n\n\t}\n\n\tmarkUpdated() {\n\n\t\tthis._previousMatrix.copy( this.matrix );\n\n\t}\n\n\tisDirty() {\n\n\t\tconst { matrix, _previousMatrix } = this;\n\t\tconst el1 = matrix.elements;\n\t\tconst el2 = _previousMatrix.elements;\n\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\tif ( el1[ i ] !== el2[ i ] ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tprepareGeometry() {\n\n\t\t// generate shared array buffers\n\t\tconst geometry = this.geometry;\n\t\tconst attributes = geometry.attributes;\n\t\tconst useSharedArrayBuffer = areSharedArrayBuffersSupported();\n\t\tif ( useSharedArrayBuffer ) {\n\n\t\t\tfor ( const key in attributes ) {\n\n\t\t\t\tconst attribute = attributes[ key ];\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\tthrow new Error( 'Brush: InterleavedBufferAttributes are not supported.' );\n\n\t\t\t\t}\n\n\t\t\t\tattribute.array = convertToSharedArrayBuffer( attribute.array );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate bounds tree\n\t\tif ( ! geometry.boundsTree ) {\n\n\t\t\tensureIndex( geometry, { useSharedArrayBuffer } );\n\t\t\tgeometry.boundsTree = new MeshBVH( geometry, { maxLeafTris: 3, indirect: true, useSharedArrayBuffer } );\n\n\t\t}\n\n\t\t// generate half edges\n\t\tif ( ! geometry.halfEdges ) {\n\n\t\t\tgeometry.halfEdges = new HalfEdgeMap( geometry );\n\n\t\t}\n\n\t\t// save group indices for materials\n\t\tif ( ! geometry.groupIndices ) {\n\n\t\t\tconst triCount = getTriCount( geometry );\n\t\t\tconst array = new Uint16Array( triCount );\n\t\t\tconst groups = geometry.groups;\n\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\tconst { start, count } = groups[ i ];\n\t\t\t\tfor ( let g = start / 3, lg = ( start + count ) / 3; g < lg; g ++ ) {\n\n\t\t\t\t\tarray[ g ] = i;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.groupIndices = array;\n\n\t\t}\n\n\t}\n\n\tdisposeCacheData() {\n\n\t\tconst { geometry } = this;\n\t\tgeometry.halfEdges = null;\n\t\tgeometry.boundsTree = null;\n\t\tgeometry.groupIndices = null;\n\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}