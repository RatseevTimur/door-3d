{"ast":null,"code":"import { BufferAttribute } from 'three';\nimport { TriangleSplitter } from './TriangleSplitter.js';\nimport { TypedAttributeData } from './TypedAttributeData.js';\nimport { OperationDebugData } from './debug/OperationDebugData.js';\nimport { performOperation } from './operations/operations.js';\nimport { Brush } from './Brush.js';\n\n// merges groups with common material indices in place\nfunction joinGroups(groups) {\n  for (let i = 0; i < groups.length - 1; i++) {\n    const group = groups[i];\n    const nextGroup = groups[i + 1];\n    if (group.materialIndex === nextGroup.materialIndex) {\n      const start = group.start;\n      const end = nextGroup.start + nextGroup.count;\n      nextGroup.start = start;\n      nextGroup.count = end - start;\n      groups.splice(i, 1);\n      i--;\n    }\n  }\n}\n\n// initialize the target geometry and attribute data to be based on\n// the given reference geometry\nfunction prepareAttributesData(referenceGeometry, targetGeometry, attributeData, relevantAttributes) {\n  attributeData.clear();\n\n  // initialize and clear unused data from the attribute buffers and vice versa\n  const aAttributes = referenceGeometry.attributes;\n  for (let i = 0, l = relevantAttributes.length; i < l; i++) {\n    const key = relevantAttributes[i];\n    const aAttr = aAttributes[key];\n    attributeData.initializeArray(key, aAttr.array.constructor, aAttr.itemSize, aAttr.normalized);\n  }\n  for (const key in attributeData.attributes) {\n    if (!relevantAttributes.includes(key)) {\n      attributeData.delete(key);\n    }\n  }\n  for (const key in targetGeometry.attributes) {\n    if (!relevantAttributes.includes(key)) {\n      targetGeometry.deleteAttribute(key);\n      targetGeometry.dispose();\n    }\n  }\n}\n\n// Assigns the given tracked attribute data to the geometry and returns whether the\n// geometry needs to be disposed of.\nfunction assignBufferData(geometry, attributeData, groupOrder) {\n  let needsDisposal = false;\n  let drawRange = -1;\n\n  // set the data\n  const attributes = geometry.attributes;\n  const referenceAttrSet = attributeData.groupAttributes[0];\n  for (const key in referenceAttrSet) {\n    const requiredLength = attributeData.getTotalLength(key);\n    const type = attributeData.getType(key);\n    const itemSize = attributeData.getItemSize(key);\n    const normalized = attributeData.getNormalized(key);\n    let geoAttr = attributes[key];\n    if (!geoAttr || geoAttr.array.length < requiredLength) {\n      // create the attribute if it doesn't exist yet\n      geoAttr = new BufferAttribute(new type(requiredLength), itemSize, normalized);\n      geometry.setAttribute(key, geoAttr);\n      needsDisposal = true;\n    }\n\n    // assign the data to the geometry attribute buffers in the provided order\n    // of the groups list\n    let offset = 0;\n    for (let i = 0, l = Math.min(groupOrder.length, attributeData.groupCount); i < l; i++) {\n      const index = groupOrder[i].index;\n      const {\n        array,\n        type,\n        length\n      } = attributeData.groupAttributes[index][key];\n      const trimmedArray = new type(array.buffer, 0, length);\n      geoAttr.array.set(trimmedArray, offset);\n      offset += trimmedArray.length;\n    }\n    geoAttr.needsUpdate = true;\n    drawRange = requiredLength / geoAttr.itemSize;\n  }\n\n  // remove or update the index appropriately\n  if (geometry.index) {\n    const indexArray = geometry.index.array;\n    if (indexArray.length < drawRange) {\n      geometry.index = null;\n      needsDisposal = true;\n    } else {\n      for (let i = 0, l = indexArray.length; i < l; i++) {\n        indexArray[i] = i;\n      }\n    }\n  }\n\n  // initialize the groups\n  let groupOffset = 0;\n  geometry.clearGroups();\n  for (let i = 0, l = Math.min(groupOrder.length, attributeData.groupCount); i < l; i++) {\n    const {\n      index,\n      materialIndex\n    } = groupOrder[i];\n    const vertCount = attributeData.getCount(index);\n    if (vertCount !== 0) {\n      geometry.addGroup(groupOffset, vertCount, materialIndex);\n      groupOffset += vertCount;\n    }\n  }\n\n  // update the draw range\n  geometry.setDrawRange(0, drawRange);\n\n  // remove the bounds tree if it exists because its now out of date\n  // TODO: can we have this dispose in the same way that a brush does?\n  // TODO: why are half edges and group indices not removed here?\n  geometry.boundsTree = null;\n  if (needsDisposal) {\n    geometry.dispose();\n  }\n}\n\n// Returns the list of materials used for the given set of groups\nfunction getMaterialList(groups, materials) {\n  let result = materials;\n  if (!Array.isArray(materials)) {\n    result = [];\n    groups.forEach(g => {\n      result[g.materialIndex] = materials;\n    });\n  }\n  return result;\n}\n\n// Utility class for performing CSG operations\nexport class Evaluator {\n  constructor() {\n    this.triangleSplitter = new TriangleSplitter();\n    this.attributeData = [];\n    this.attributes = ['position', 'uv', 'normal'];\n    this.useGroups = true;\n    this.consolidateGroups = true;\n    this.debug = new OperationDebugData();\n  }\n  getGroupRanges(geometry) {\n    return !this.useGroups || geometry.groups.length === 0 ? [{\n      start: 0,\n      count: Infinity,\n      materialIndex: 0\n    }] : geometry.groups.map(group => ({\n      ...group\n    }));\n  }\n  evaluate(a, b, operations) {\n    let targetBrushes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Brush();\n    let wasArray = true;\n    if (!Array.isArray(operations)) {\n      operations = [operations];\n    }\n    if (!Array.isArray(targetBrushes)) {\n      targetBrushes = [targetBrushes];\n      wasArray = false;\n    }\n    if (targetBrushes.length !== operations.length) {\n      throw new Error('Evaluator: operations and target array passed as different sizes.');\n    }\n    a.prepareGeometry();\n    b.prepareGeometry();\n    const {\n      triangleSplitter,\n      attributeData,\n      attributes,\n      useGroups,\n      consolidateGroups,\n      debug\n    } = this;\n\n    // expand the attribute data array to the necessary size\n    while (attributeData.length < targetBrushes.length) {\n      attributeData.push(new TypedAttributeData());\n    }\n\n    // prepare the attribute data buffer information\n    targetBrushes.forEach((brush, i) => {\n      prepareAttributesData(a.geometry, brush.geometry, attributeData[i], attributes);\n    });\n\n    // run the operation to fill the list of attribute data\n    debug.init();\n    performOperation(a, b, operations, triangleSplitter, attributeData, {\n      useGroups\n    });\n    debug.complete();\n\n    // get the materials and group ranges\n    const aGroups = this.getGroupRanges(a.geometry);\n    const aMaterials = getMaterialList(aGroups, a.material);\n    const bGroups = this.getGroupRanges(b.geometry);\n    const bMaterials = getMaterialList(bGroups, b.material);\n    bGroups.forEach(g => g.materialIndex += aMaterials.length);\n    let groups = [...aGroups, ...bGroups].map((group, index) => ({\n      ...group,\n      index\n    }));\n\n    // generate the minimum set of materials needed for the list of groups and adjust the groups\n    // if they're needed\n    if (useGroups) {\n      const allMaterials = [...aMaterials, ...bMaterials];\n      if (consolidateGroups) {\n        groups = groups.map(group => {\n          const mat = allMaterials[group.materialIndex];\n          group.materialIndex = allMaterials.indexOf(mat);\n          return group;\n        }).sort((a, b) => {\n          return a.materialIndex - b.materialIndex;\n        });\n      }\n\n      // create a map from old to new index and remove materials that aren't used\n      const finalMaterials = [];\n      for (let i = 0, l = allMaterials.length; i < l; i++) {\n        let foundGroup = false;\n        for (let g = 0, lg = groups.length; g < lg; g++) {\n          const group = groups[g];\n          if (group.materialIndex === i) {\n            foundGroup = true;\n            group.materialIndex = finalMaterials.length;\n          }\n        }\n        if (foundGroup) {\n          finalMaterials.push(allMaterials[i]);\n        }\n      }\n      targetBrushes.forEach(tb => {\n        tb.material = finalMaterials;\n      });\n    } else {\n      groups = [{\n        start: 0,\n        count: Infinity,\n        index: 0,\n        materialIndex: 0\n      }];\n      targetBrushes.forEach(tb => {\n        tb.material = aMaterials[0];\n      });\n    }\n\n    // apply groups and attribute data to the geometry\n    targetBrushes.forEach((brush, i) => {\n      const targetGeometry = brush.geometry;\n      assignBufferData(targetGeometry, attributeData[i], groups);\n      if (consolidateGroups) {\n        joinGroups(targetGeometry.groups);\n      }\n    });\n    return wasArray ? targetBrushes : targetBrushes[0];\n  }\n\n  // TODO: fix\n  evaluateHierarchy(root) {\n    let target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Brush();\n    root.updateMatrixWorld(true);\n    const flatTraverse = (obj, cb) => {\n      const children = obj.children;\n      for (let i = 0, l = children.length; i < l; i++) {\n        const child = children[i];\n        if (child.isOperationGroup) {\n          flatTraverse(child, cb);\n        } else {\n          cb(child);\n        }\n      }\n    };\n    const traverse = brush => {\n      const children = brush.children;\n      let didChange = false;\n      for (let i = 0, l = children.length; i < l; i++) {\n        const child = children[i];\n        didChange = traverse(child) || didChange;\n      }\n      const isDirty = brush.isDirty();\n      if (isDirty) {\n        brush.markUpdated();\n      }\n      if (didChange && !brush.isOperationGroup) {\n        let result;\n        flatTraverse(brush, child => {\n          if (!result) {\n            result = this.evaluate(brush, child, child.operation);\n          } else {\n            result = this.evaluate(result, child, child.operation);\n          }\n        });\n        brush._cachedGeometry = result.geometry;\n        brush._cachedMaterials = result.material;\n        return true;\n      } else {\n        return didChange || isDirty;\n      }\n    };\n    traverse(root);\n    target.geometry = root._cachedGeometry;\n    target.material = root._cachedMaterials;\n    return target;\n  }\n  reset() {\n    this.triangleSplitter.reset();\n  }\n}","map":{"version":3,"names":["BufferAttribute","TriangleSplitter","TypedAttributeData","OperationDebugData","performOperation","Brush","joinGroups","groups","i","length","group","nextGroup","materialIndex","start","end","count","splice","prepareAttributesData","referenceGeometry","targetGeometry","attributeData","relevantAttributes","clear","aAttributes","attributes","l","key","aAttr","initializeArray","array","constructor","itemSize","normalized","includes","delete","deleteAttribute","dispose","assignBufferData","geometry","groupOrder","needsDisposal","drawRange","referenceAttrSet","groupAttributes","requiredLength","getTotalLength","type","getType","getItemSize","getNormalized","geoAttr","setAttribute","offset","Math","min","groupCount","index","trimmedArray","buffer","set","needsUpdate","indexArray","groupOffset","clearGroups","vertCount","getCount","addGroup","setDrawRange","boundsTree","getMaterialList","materials","result","Array","isArray","forEach","g","Evaluator","triangleSplitter","useGroups","consolidateGroups","debug","getGroupRanges","Infinity","map","evaluate","a","b","operations","targetBrushes","arguments","undefined","wasArray","Error","prepareGeometry","push","brush","init","complete","aGroups","aMaterials","material","bGroups","bMaterials","allMaterials","mat","indexOf","sort","finalMaterials","foundGroup","lg","tb","evaluateHierarchy","root","target","updateMatrixWorld","flatTraverse","obj","cb","children","child","isOperationGroup","traverse","didChange","isDirty","markUpdated","operation","_cachedGeometry","_cachedMaterials","reset"],"sources":["/Users/ratseevtimur/Documents/Test-Projects/door-3d/node_modules/three-bvh-csg/src/core/Evaluator.js"],"sourcesContent":["import { BufferAttribute } from 'three';\nimport { TriangleSplitter } from './TriangleSplitter.js';\nimport { TypedAttributeData } from './TypedAttributeData.js';\nimport { OperationDebugData } from './debug/OperationDebugData.js';\nimport { performOperation } from './operations/operations.js';\nimport { Brush } from './Brush.js';\n\n// merges groups with common material indices in place\nfunction joinGroups( groups ) {\n\n\tfor ( let i = 0; i < groups.length - 1; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\t\tconst nextGroup = groups[ i + 1 ];\n\t\tif ( group.materialIndex === nextGroup.materialIndex ) {\n\n\t\t\tconst start = group.start;\n\t\t\tconst end = nextGroup.start + nextGroup.count;\n\t\t\tnextGroup.start = start;\n\t\t\tnextGroup.count = end - start;\n\n\t\t\tgroups.splice( i, 1 );\n\t\t\ti --;\n\n\t\t}\n\n\t}\n\n}\n\n// initialize the target geometry and attribute data to be based on\n// the given reference geometry\nfunction prepareAttributesData( referenceGeometry, targetGeometry, attributeData, relevantAttributes ) {\n\n\tattributeData.clear();\n\n\t// initialize and clear unused data from the attribute buffers and vice versa\n\tconst aAttributes = referenceGeometry.attributes;\n\tfor ( let i = 0, l = relevantAttributes.length; i < l; i ++ ) {\n\n\t\tconst key = relevantAttributes[ i ];\n\t\tconst aAttr = aAttributes[ key ];\n\t\tattributeData.initializeArray( key, aAttr.array.constructor, aAttr.itemSize, aAttr.normalized );\n\n\t}\n\n\tfor ( const key in attributeData.attributes ) {\n\n\t\tif ( ! relevantAttributes.includes( key ) ) {\n\n\t\t\tattributeData.delete( key );\n\n\t\t}\n\n\t}\n\n\tfor ( const key in targetGeometry.attributes ) {\n\n\t\tif ( ! relevantAttributes.includes( key ) ) {\n\n\t\t\ttargetGeometry.deleteAttribute( key );\n\t\t\ttargetGeometry.dispose();\n\n\t\t}\n\n\t}\n\n}\n\n// Assigns the given tracked attribute data to the geometry and returns whether the\n// geometry needs to be disposed of.\nfunction assignBufferData( geometry, attributeData, groupOrder ) {\n\n\tlet needsDisposal = false;\n\tlet drawRange = - 1;\n\n\t// set the data\n\tconst attributes = geometry.attributes;\n\tconst referenceAttrSet = attributeData.groupAttributes[ 0 ];\n\tfor ( const key in referenceAttrSet ) {\n\n\t\tconst requiredLength = attributeData.getTotalLength( key );\n\t\tconst type = attributeData.getType( key );\n\t\tconst itemSize = attributeData.getItemSize( key );\n\t\tconst normalized = attributeData.getNormalized( key );\n\t\tlet geoAttr = attributes[ key ];\n\t\tif ( ! geoAttr || geoAttr.array.length < requiredLength ) {\n\n\t\t\t// create the attribute if it doesn't exist yet\n\t\t\tgeoAttr = new BufferAttribute( new type( requiredLength ), itemSize, normalized );\n\t\t\tgeometry.setAttribute( key, geoAttr );\n\t\t\tneedsDisposal = true;\n\n\t\t}\n\n\t\t// assign the data to the geometry attribute buffers in the provided order\n\t\t// of the groups list\n\t\tlet offset = 0;\n\t\tfor ( let i = 0, l = Math.min( groupOrder.length, attributeData.groupCount ); i < l; i ++ ) {\n\n\t\t\tconst index = groupOrder[ i ].index;\n\t\t\tconst { array, type, length } = attributeData.groupAttributes[ index ][ key ];\n\t\t\tconst trimmedArray = new type( array.buffer, 0, length );\n\t\t\tgeoAttr.array.set( trimmedArray, offset );\n\t\t\toffset += trimmedArray.length;\n\n\t\t}\n\n\t\tgeoAttr.needsUpdate = true;\n\t\tdrawRange = requiredLength / geoAttr.itemSize;\n\n\t}\n\n\t// remove or update the index appropriately\n\tif ( geometry.index ) {\n\n\t\tconst indexArray = geometry.index.array;\n\t\tif ( indexArray.length < drawRange ) {\n\n\t\t\tgeometry.index = null;\n\t\t\tneedsDisposal = true;\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0, l = indexArray.length; i < l; i ++ ) {\n\n\t\t\t\tindexArray[ i ] = i;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// initialize the groups\n\tlet groupOffset = 0;\n\tgeometry.clearGroups();\n\tfor ( let i = 0, l = Math.min( groupOrder.length, attributeData.groupCount ); i < l; i ++ ) {\n\n\t\tconst { index, materialIndex } = groupOrder[ i ];\n\t\tconst vertCount = attributeData.getCount( index );\n\t\tif ( vertCount !== 0 ) {\n\n\t\t\tgeometry.addGroup( groupOffset, vertCount, materialIndex );\n\t\t\tgroupOffset += vertCount;\n\n\t\t}\n\n\t}\n\n\t// update the draw range\n\tgeometry.setDrawRange( 0, drawRange );\n\n\t// remove the bounds tree if it exists because its now out of date\n\t// TODO: can we have this dispose in the same way that a brush does?\n\t// TODO: why are half edges and group indices not removed here?\n\tgeometry.boundsTree = null;\n\n\tif ( needsDisposal ) {\n\n\t\tgeometry.dispose();\n\n\t}\n\n}\n\n// Returns the list of materials used for the given set of groups\nfunction getMaterialList( groups, materials ) {\n\n\tlet result = materials;\n\tif ( ! Array.isArray( materials ) ) {\n\n\t\tresult = [];\n\t\tgroups.forEach( g => {\n\n\t\t\tresult[ g.materialIndex ] = materials;\n\n\t\t} );\n\n\t}\n\n\treturn result;\n\n}\n\n// Utility class for performing CSG operations\nexport class Evaluator {\n\n\tconstructor() {\n\n\t\tthis.triangleSplitter = new TriangleSplitter();\n\t\tthis.attributeData = [];\n\t\tthis.attributes = [ 'position', 'uv', 'normal' ];\n\t\tthis.useGroups = true;\n\t\tthis.consolidateGroups = true;\n\t\tthis.debug = new OperationDebugData();\n\n\t}\n\n\tgetGroupRanges( geometry ) {\n\n\t\treturn ! this.useGroups || geometry.groups.length === 0 ?\n\t\t\t[ { start: 0, count: Infinity, materialIndex: 0 } ] :\n\t\t\tgeometry.groups.map( group => ( { ...group } ) );\n\n\t}\n\n\tevaluate( a, b, operations, targetBrushes = new Brush() ) {\n\n\t\tlet wasArray = true;\n\t\tif ( ! Array.isArray( operations ) ) {\n\n\t\t\toperations = [ operations ];\n\n\t\t}\n\n\t\tif ( ! Array.isArray( targetBrushes ) ) {\n\n\t\t\ttargetBrushes = [ targetBrushes ];\n\t\t\twasArray = false;\n\n\t\t}\n\n\t\tif ( targetBrushes.length !== operations.length ) {\n\n\t\t\tthrow new Error( 'Evaluator: operations and target array passed as different sizes.' );\n\n\t\t}\n\n\t\ta.prepareGeometry();\n\t\tb.prepareGeometry();\n\n\t\tconst {\n\t\t\ttriangleSplitter,\n\t\t\tattributeData,\n\t\t\tattributes,\n\t\t\tuseGroups,\n\t\t\tconsolidateGroups,\n\t\t\tdebug,\n\t\t} = this;\n\n\t\t// expand the attribute data array to the necessary size\n\t\twhile ( attributeData.length < targetBrushes.length ) {\n\n\t\t\tattributeData.push( new TypedAttributeData() );\n\n\t\t}\n\n\t\t// prepare the attribute data buffer information\n\t\ttargetBrushes.forEach( ( brush, i ) => {\n\n\t\t\tprepareAttributesData( a.geometry, brush.geometry, attributeData[ i ], attributes );\n\n\t\t} );\n\n\t\t// run the operation to fill the list of attribute data\n\t\tdebug.init();\n\t\tperformOperation( a, b, operations, triangleSplitter, attributeData, { useGroups } );\n\t\tdebug.complete();\n\n\t\t// get the materials and group ranges\n\t\tconst aGroups = this.getGroupRanges( a.geometry );\n\t\tconst aMaterials = getMaterialList( aGroups, a.material );\n\n\t\tconst bGroups = this.getGroupRanges( b.geometry );\n\t\tconst bMaterials = getMaterialList( bGroups, b.material );\n\t\tbGroups.forEach( g => g.materialIndex += aMaterials.length );\n\n\t\tlet groups = [ ...aGroups, ...bGroups ]\n\t\t\t.map( ( group, index ) => ( { ...group, index } ) );\n\n\t\t// generate the minimum set of materials needed for the list of groups and adjust the groups\n\t\t// if they're needed\n\t\tif ( useGroups ) {\n\n\t\t\tconst allMaterials = [ ...aMaterials, ...bMaterials ];\n\t\t\tif ( consolidateGroups ) {\n\n\t\t\t\tgroups = groups\n\t\t\t\t\t.map( group => {\n\n\t\t\t\t\t\tconst mat = allMaterials[ group.materialIndex ];\n\t\t\t\t\t\tgroup.materialIndex = allMaterials.indexOf( mat );\n\t\t\t\t\t\treturn group;\n\n\t\t\t\t\t} )\n\t\t\t\t\t.sort( ( a, b ) => {\n\n\t\t\t\t\t\treturn a.materialIndex - b.materialIndex;\n\n\t\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\t// create a map from old to new index and remove materials that aren't used\n\t\t\tconst finalMaterials = [];\n\t\t\tfor ( let i = 0, l = allMaterials.length; i < l; i ++ ) {\n\n\t\t\t\tlet foundGroup = false;\n\t\t\t\tfor ( let g = 0, lg = groups.length; g < lg; g ++ ) {\n\n\t\t\t\t\tconst group = groups[ g ];\n\t\t\t\t\tif ( group.materialIndex === i ) {\n\n\t\t\t\t\t\tfoundGroup = true;\n\t\t\t\t\t\tgroup.materialIndex = finalMaterials.length;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( foundGroup ) {\n\n\t\t\t\t\tfinalMaterials.push( allMaterials[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttargetBrushes.forEach( tb => {\n\n\t\t\t\ttb.material = finalMaterials;\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\tgroups = [ { start: 0, count: Infinity, index: 0, materialIndex: 0 } ];\n\t\t\ttargetBrushes.forEach( tb => {\n\n\t\t\t\ttb.material = aMaterials[ 0 ];\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// apply groups and attribute data to the geometry\n\t\ttargetBrushes.forEach( ( brush, i ) => {\n\n\t\t\tconst targetGeometry = brush.geometry;\n\t\t\tassignBufferData( targetGeometry, attributeData[ i ], groups );\n\t\t\tif ( consolidateGroups ) {\n\n\t\t\t\tjoinGroups( targetGeometry.groups );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn wasArray ? targetBrushes : targetBrushes[ 0 ];\n\n\t}\n\n\t// TODO: fix\n\tevaluateHierarchy( root, target = new Brush() ) {\n\n\t\troot.updateMatrixWorld( true );\n\n\t\tconst flatTraverse = ( obj, cb ) => {\n\n\t\t\tconst children = obj.children;\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = children[ i ];\n\t\t\t\tif ( child.isOperationGroup ) {\n\n\t\t\t\t\tflatTraverse( child, cb );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcb( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\n\t\tconst traverse = brush => {\n\n\t\t\tconst children = brush.children;\n\t\t\tlet didChange = false;\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = children[ i ];\n\t\t\t\tdidChange = traverse( child ) || didChange;\n\n\t\t\t}\n\n\t\t\tconst isDirty = brush.isDirty();\n\t\t\tif ( isDirty ) {\n\n\t\t\t\tbrush.markUpdated();\n\n\t\t\t}\n\n\t\t\tif ( didChange && ! brush.isOperationGroup ) {\n\n\t\t\t\tlet result;\n\t\t\t\tflatTraverse( brush, child => {\n\n\t\t\t\t\tif ( ! result ) {\n\n\t\t\t\t\t\tresult = this.evaluate( brush, child, child.operation );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tresult = this.evaluate( result, child, child.operation );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tbrush._cachedGeometry = result.geometry;\n\t\t\t\tbrush._cachedMaterials = result.material;\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn didChange || isDirty;\n\n\t\t\t}\n\n\t\t};\n\n\t\ttraverse( root );\n\n\t\ttarget.geometry = root._cachedGeometry;\n\t\ttarget.material = root._cachedMaterials;\n\n\t\treturn target;\n\n\t}\n\n\treset() {\n\n\t\tthis.triangleSplitter.reset();\n\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}