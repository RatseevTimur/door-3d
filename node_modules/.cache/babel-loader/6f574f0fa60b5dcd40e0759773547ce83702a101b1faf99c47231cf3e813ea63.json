{"ast":null,"code":"import { Matrix4, Matrix3, Triangle } from 'three';\nimport { getHitSideWithCoplanarCheck, getHitSide, collectIntersectingTriangles, appendAttributeFromTriangle, appendAttributesFromIndices, getOperationAction, SKIP_TRI, INVERT_TRI } from './operationsUtils.js';\nimport { getTriCount } from '../utils/geometryUtils.js';\nimport { HOLLOW_INTERSECTION, HOLLOW_SUBTRACTION } from '../constants.js';\nimport { isTriDegenerate } from '../utils/triangleUtils.js';\nconst _matrix = new Matrix4();\nconst _normalMatrix = new Matrix3();\nconst _triA = new Triangle();\nconst _triB = new Triangle();\nconst _tri = new Triangle();\nconst _barycoordTri = new Triangle();\nconst _attr = [];\nconst _actions = [];\nfunction getFirstIdFromSet(set) {\n  for (const id of set) return id;\n}\n\n// runs the given operation against a and b using the splitter and appending data to the\n// attributeData object.\nexport function performOperation(a, b, operations, splitter, attributeData) {\n  let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n  const {\n    useGroups = true\n  } = options;\n  const {\n    aIntersections,\n    bIntersections\n  } = collectIntersectingTriangles(a, b);\n  const resultGroups = [];\n  let resultMaterials = null;\n  let groupOffset;\n  groupOffset = useGroups ? 0 : -1;\n  performSplitTriangleOperations(a, b, aIntersections, operations, false, splitter, attributeData, groupOffset);\n  performWholeTriangleOperations(a, b, aIntersections, operations, false, attributeData, groupOffset);\n\n  // find whether the set of operations contains a non-hollow operations. If it does then we need\n  // to perform the second set of triangle additions\n  const nonHollow = operations.findIndex(op => op !== HOLLOW_INTERSECTION && op !== HOLLOW_SUBTRACTION) !== -1;\n  if (nonHollow) {\n    groupOffset = useGroups ? a.geometry.groups.length || 1 : -1;\n    performSplitTriangleOperations(b, a, bIntersections, operations, true, splitter, attributeData, groupOffset);\n    performWholeTriangleOperations(b, a, bIntersections, operations, true, attributeData, groupOffset);\n  }\n  _attr.length = 0;\n  _actions.length = 0;\n  return {\n    groups: resultGroups,\n    materials: resultMaterials\n  };\n}\n\n// perform triangle splitting and CSG operations on the set of split triangles\nfunction performSplitTriangleOperations(a, b, intersectionMap, operations, invert, splitter, attributeData) {\n  let groupOffset = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n  const invertedGeometry = a.matrixWorld.determinant() < 0;\n\n  // transforms into the local frame of matrix b\n  _matrix.copy(b.matrixWorld).invert().multiply(a.matrixWorld);\n  _normalMatrix.getNormalMatrix(a.matrixWorld).multiplyScalar(invertedGeometry ? -1 : 1);\n  const groupIndices = a.geometry.groupIndices;\n  const aIndex = a.geometry.index;\n  const aPosition = a.geometry.attributes.position;\n  const bBVH = b.geometry.boundsTree;\n  const bIndex = b.geometry.index;\n  const bPosition = b.geometry.attributes.position;\n  const splitIds = intersectionMap.ids;\n  const intersectionSet = intersectionMap.intersectionSet;\n\n  // iterate over all split triangle indices\n  for (let i = 0, l = splitIds.length; i < l; i++) {\n    const ia = splitIds[i];\n    const groupIndex = groupOffset === -1 ? 0 : groupIndices[ia] + groupOffset;\n\n    // get the triangle in the geometry B local frame\n    const ia3 = 3 * ia;\n    const ia0 = aIndex.getX(ia3 + 0);\n    const ia1 = aIndex.getX(ia3 + 1);\n    const ia2 = aIndex.getX(ia3 + 2);\n    _triA.a.fromBufferAttribute(aPosition, ia0).applyMatrix4(_matrix);\n    _triA.b.fromBufferAttribute(aPosition, ia1).applyMatrix4(_matrix);\n    _triA.c.fromBufferAttribute(aPosition, ia2).applyMatrix4(_matrix);\n\n    // initialize the splitter with the triangle from geometry A\n    splitter.reset();\n    splitter.initialize(_triA);\n\n    // split the triangle with the intersecting triangles from B\n    const intersectingIndices = intersectionSet[ia];\n    for (let ib = 0, l = intersectingIndices.length; ib < l; ib++) {\n      const ib3 = 3 * intersectingIndices[ib];\n      const ib0 = bIndex.getX(ib3 + 0);\n      const ib1 = bIndex.getX(ib3 + 1);\n      const ib2 = bIndex.getX(ib3 + 2);\n      _triB.a.fromBufferAttribute(bPosition, ib0);\n      _triB.b.fromBufferAttribute(bPosition, ib1);\n      _triB.c.fromBufferAttribute(bPosition, ib2);\n      splitter.splitByTriangle(_triB);\n    }\n\n    // for all triangles in the split result\n    const triangles = splitter.triangles;\n    for (let ib = 0, l = triangles.length; ib < l; ib++) {\n      // get the barycentric coordinates of the clipped triangle to add\n      const clippedTri = triangles[ib];\n\n      // try to use the side derived from the clipping but if it turns out to be\n      // uncertain then fall back to the raycasting approach\n      const hitSide = splitter.coplanarTriangleUsed ? getHitSideWithCoplanarCheck(clippedTri, bBVH) : getHitSide(clippedTri, bBVH);\n      _attr.length = 0;\n      _actions.length = 0;\n      for (let o = 0, lo = operations.length; o < lo; o++) {\n        const op = getOperationAction(operations[o], hitSide, invert);\n        if (op !== SKIP_TRI) {\n          _actions.push(op);\n          _attr.push(attributeData[o].getGroupAttrSet(groupIndex));\n        }\n      }\n      if (_attr.length !== 0) {\n        _triA.getBarycoord(clippedTri.a, _barycoordTri.a);\n        _triA.getBarycoord(clippedTri.b, _barycoordTri.b);\n        _triA.getBarycoord(clippedTri.c, _barycoordTri.c);\n        for (let k = 0, lk = _attr.length; k < lk; k++) {\n          const attrSet = _attr[k];\n          const action = _actions[k];\n          const invertTri = action === INVERT_TRI;\n          appendAttributeFromTriangle(ia, _barycoordTri, a.geometry, a.matrixWorld, _normalMatrix, attrSet, invertedGeometry !== invertTri);\n        }\n      }\n    }\n  }\n  return splitIds.length;\n}\n\n// perform CSG operations on the set of whole triangles using a half edge structure\n// at the moment this isn't always faster due to overhead of building the half edge structure\n// and degraded connectivity due to split triangles.\n\nfunction performWholeTriangleOperations(a, b, splitTriSet, operations, invert, attributeData) {\n  let groupOffset = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  const invertedGeometry = a.matrixWorld.determinant() < 0;\n\n  // matrix for transforming into the local frame of geometry b\n  _matrix.copy(b.matrixWorld).invert().multiply(a.matrixWorld);\n  _normalMatrix.getNormalMatrix(a.matrixWorld).multiplyScalar(invertedGeometry ? -1 : 1);\n  const bBVH = b.geometry.boundsTree;\n  const groupIndices = a.geometry.groupIndices;\n  const aIndex = a.geometry.index;\n  const aAttributes = a.geometry.attributes;\n  const aPosition = aAttributes.position;\n  const stack = [];\n  const halfEdges = a.geometry.halfEdges;\n  const traverseSet = new Set();\n  const triCount = getTriCount(a.geometry);\n  for (let i = 0, l = triCount; i < l; i++) {\n    if (!(i in splitTriSet.intersectionSet)) {\n      traverseSet.add(i);\n    }\n  }\n  while (traverseSet.size > 0) {\n    const id = getFirstIdFromSet(traverseSet);\n    traverseSet.delete(id);\n    stack.push(id);\n\n    // get the vertex indices\n    const i3 = 3 * id;\n    const i0 = aIndex.getX(i3 + 0);\n    const i1 = aIndex.getX(i3 + 1);\n    const i2 = aIndex.getX(i3 + 2);\n\n    // get the vertex position in the frame of geometry b so we can\n    // perform hit testing\n    _tri.a.fromBufferAttribute(aPosition, i0).applyMatrix4(_matrix);\n    _tri.b.fromBufferAttribute(aPosition, i1).applyMatrix4(_matrix);\n    _tri.c.fromBufferAttribute(aPosition, i2).applyMatrix4(_matrix);\n\n    // get the side and decide if we need to cull the triangle based on the operation\n    const hitSide = getHitSide(_tri, bBVH);\n    _actions.length = 0;\n    _attr.length = 0;\n    for (let o = 0, lo = operations.length; o < lo; o++) {\n      const op = getOperationAction(operations[o], hitSide, invert);\n      if (op !== SKIP_TRI) {\n        _actions.push(op);\n        _attr.push(attributeData[o]);\n      }\n    }\n    while (stack.length > 0) {\n      const currId = stack.pop();\n      for (let i = 0; i < 3; i++) {\n        const sid = halfEdges.getSiblingTriangleIndex(currId, i);\n        if (sid !== -1 && traverseSet.has(sid)) {\n          stack.push(sid);\n          traverseSet.delete(sid);\n        }\n      }\n      if (_attr.length !== 0) {\n        const i3 = 3 * currId;\n        const i0 = aIndex.getX(i3 + 0);\n        const i1 = aIndex.getX(i3 + 1);\n        const i2 = aIndex.getX(i3 + 2);\n        const groupIndex = groupOffset === -1 ? 0 : groupIndices[currId] + groupOffset;\n        _tri.a.fromBufferAttribute(aPosition, i0);\n        _tri.b.fromBufferAttribute(aPosition, i1);\n        _tri.c.fromBufferAttribute(aPosition, i2);\n        if (!isTriDegenerate(_tri)) {\n          for (let k = 0, lk = _attr.length; k < lk; k++) {\n            const action = _actions[k];\n            const attrSet = _attr[k].getGroupAttrSet(groupIndex);\n            const invertTri = action === INVERT_TRI;\n            appendAttributesFromIndices(i0, i1, i2, aAttributes, a.matrixWorld, _normalMatrix, attrSet, invertTri !== invertedGeometry);\n          }\n        }\n      }\n    }\n  }\n}","map":{"version":3,"names":["Matrix4","Matrix3","Triangle","getHitSideWithCoplanarCheck","getHitSide","collectIntersectingTriangles","appendAttributeFromTriangle","appendAttributesFromIndices","getOperationAction","SKIP_TRI","INVERT_TRI","getTriCount","HOLLOW_INTERSECTION","HOLLOW_SUBTRACTION","isTriDegenerate","_matrix","_normalMatrix","_triA","_triB","_tri","_barycoordTri","_attr","_actions","getFirstIdFromSet","set","id","performOperation","a","b","operations","splitter","attributeData","options","arguments","length","undefined","useGroups","aIntersections","bIntersections","resultGroups","resultMaterials","groupOffset","performSplitTriangleOperations","performWholeTriangleOperations","nonHollow","findIndex","op","geometry","groups","materials","intersectionMap","invert","invertedGeometry","matrixWorld","determinant","copy","multiply","getNormalMatrix","multiplyScalar","groupIndices","aIndex","index","aPosition","attributes","position","bBVH","boundsTree","bIndex","bPosition","splitIds","ids","intersectionSet","i","l","ia","groupIndex","ia3","ia0","getX","ia1","ia2","fromBufferAttribute","applyMatrix4","c","reset","initialize","intersectingIndices","ib","ib3","ib0","ib1","ib2","splitByTriangle","triangles","clippedTri","hitSide","coplanarTriangleUsed","o","lo","push","getGroupAttrSet","getBarycoord","k","lk","attrSet","action","invertTri","splitTriSet","aAttributes","stack","halfEdges","traverseSet","Set","triCount","add","size","delete","i3","i0","i1","i2","currId","pop","sid","getSiblingTriangleIndex","has"],"sources":["/Users/ratseevtimur/Documents/Test-Projects/door-3d/node_modules/three-bvh-csg/src/core/operations/operations.js"],"sourcesContent":["import { Matrix4, Matrix3, Triangle } from 'three';\nimport {\n\tgetHitSideWithCoplanarCheck,\n\tgetHitSide,\n\tcollectIntersectingTriangles,\n\tappendAttributeFromTriangle,\n\tappendAttributesFromIndices,\n\tgetOperationAction,\n\tSKIP_TRI, INVERT_TRI,\n} from './operationsUtils.js';\nimport { getTriCount } from '../utils/geometryUtils.js';\nimport { HOLLOW_INTERSECTION, HOLLOW_SUBTRACTION } from '../constants.js';\nimport { isTriDegenerate } from '../utils/triangleUtils.js';\n\nconst _matrix = new Matrix4();\nconst _normalMatrix = new Matrix3();\nconst _triA = new Triangle();\nconst _triB = new Triangle();\nconst _tri = new Triangle();\nconst _barycoordTri = new Triangle();\nconst _attr = [];\nconst _actions = [];\n\nfunction getFirstIdFromSet( set ) {\n\n\tfor ( const id of set ) return id;\n\n}\n\n// runs the given operation against a and b using the splitter and appending data to the\n// attributeData object.\nexport function performOperation(\n\ta,\n\tb,\n\toperations,\n\tsplitter,\n\tattributeData,\n\toptions = {},\n) {\n\n\tconst { useGroups = true } = options;\n\tconst { aIntersections, bIntersections } = collectIntersectingTriangles( a, b );\n\n\tconst resultGroups = [];\n\tlet resultMaterials = null;\n\n\tlet groupOffset;\n\tgroupOffset = useGroups ? 0 : - 1;\n\tperformSplitTriangleOperations( a, b, aIntersections, operations, false, splitter, attributeData, groupOffset );\n\tperformWholeTriangleOperations( a, b, aIntersections, operations, false, attributeData, groupOffset );\n\n\t// find whether the set of operations contains a non-hollow operations. If it does then we need\n\t// to perform the second set of triangle additions\n\tconst nonHollow = operations\n\t\t.findIndex( op => op !== HOLLOW_INTERSECTION && op !== HOLLOW_SUBTRACTION ) !== - 1;\n\n\tif ( nonHollow ) {\n\n\t\tgroupOffset = useGroups ? a.geometry.groups.length || 1 : - 1;\n\t\tperformSplitTriangleOperations( b, a, bIntersections, operations, true, splitter, attributeData, groupOffset );\n\t\tperformWholeTriangleOperations( b, a, bIntersections, operations, true, attributeData, groupOffset );\n\n\t}\n\n\t_attr.length = 0;\n\t_actions.length = 0;\n\n\treturn {\n\t\tgroups: resultGroups,\n\t\tmaterials: resultMaterials\n\t};\n\n}\n\n// perform triangle splitting and CSG operations on the set of split triangles\nfunction performSplitTriangleOperations(\n\ta,\n\tb,\n\tintersectionMap,\n\toperations,\n\tinvert,\n\tsplitter,\n\tattributeData,\n\tgroupOffset = 0,\n) {\n\n\tconst invertedGeometry = a.matrixWorld.determinant() < 0;\n\n\t// transforms into the local frame of matrix b\n\t_matrix\n\t\t.copy( b.matrixWorld )\n\t\t.invert()\n\t\t.multiply( a.matrixWorld );\n\n\t_normalMatrix\n\t\t.getNormalMatrix( a.matrixWorld )\n\t\t.multiplyScalar( invertedGeometry ? - 1 : 1 );\n\n\tconst groupIndices = a.geometry.groupIndices;\n\tconst aIndex = a.geometry.index;\n\tconst aPosition = a.geometry.attributes.position;\n\n\tconst bBVH = b.geometry.boundsTree;\n\tconst bIndex = b.geometry.index;\n\tconst bPosition = b.geometry.attributes.position;\n\tconst splitIds = intersectionMap.ids;\n\tconst intersectionSet = intersectionMap.intersectionSet;\n\n\t// iterate over all split triangle indices\n\tfor ( let i = 0, l = splitIds.length; i < l; i ++ ) {\n\n\t\tconst ia = splitIds[ i ];\n\t\tconst groupIndex = groupOffset === - 1 ? 0 : groupIndices[ ia ] + groupOffset;\n\n\t\t// get the triangle in the geometry B local frame\n\t\tconst ia3 = 3 * ia;\n\t\tconst ia0 = aIndex.getX( ia3 + 0 );\n\t\tconst ia1 = aIndex.getX( ia3 + 1 );\n\t\tconst ia2 = aIndex.getX( ia3 + 2 );\n\t\t_triA.a.fromBufferAttribute( aPosition, ia0 ).applyMatrix4( _matrix );\n\t\t_triA.b.fromBufferAttribute( aPosition, ia1 ).applyMatrix4( _matrix );\n\t\t_triA.c.fromBufferAttribute( aPosition, ia2 ).applyMatrix4( _matrix );\n\n\t\t// initialize the splitter with the triangle from geometry A\n\t\tsplitter.reset();\n\t\tsplitter.initialize( _triA );\n\n\t\t// split the triangle with the intersecting triangles from B\n\t\tconst intersectingIndices = intersectionSet[ ia ];\n\t\tfor ( let ib = 0, l = intersectingIndices.length; ib < l; ib ++ ) {\n\n\t\t\tconst ib3 = 3 * intersectingIndices[ ib ];\n\t\t\tconst ib0 = bIndex.getX( ib3 + 0 );\n\t\t\tconst ib1 = bIndex.getX( ib3 + 1 );\n\t\t\tconst ib2 = bIndex.getX( ib3 + 2 );\n\t\t\t_triB.a.fromBufferAttribute( bPosition, ib0 );\n\t\t\t_triB.b.fromBufferAttribute( bPosition, ib1 );\n\t\t\t_triB.c.fromBufferAttribute( bPosition, ib2 );\n\t\t\tsplitter.splitByTriangle( _triB );\n\n\t\t}\n\n\t\t// for all triangles in the split result\n\t\tconst triangles = splitter.triangles;\n\t\tfor ( let ib = 0, l = triangles.length; ib < l; ib ++ ) {\n\n\t\t\t// get the barycentric coordinates of the clipped triangle to add\n\t\t\tconst clippedTri = triangles[ ib ];\n\n\t\t\t// try to use the side derived from the clipping but if it turns out to be\n\t\t\t// uncertain then fall back to the raycasting approach\n\t\t\tconst hitSide = splitter.coplanarTriangleUsed ?\n\t\t\t\tgetHitSideWithCoplanarCheck( clippedTri, bBVH ) :\n\t\t\t\tgetHitSide( clippedTri, bBVH );\n\n\t\t\t_attr.length = 0;\n\t\t\t_actions.length = 0;\n\t\t\tfor ( let o = 0, lo = operations.length; o < lo; o ++ ) {\n\n\t\t\t\tconst op = getOperationAction( operations[ o ], hitSide, invert );\n\t\t\t\tif ( op !== SKIP_TRI ) {\n\n\t\t\t\t\t_actions.push( op );\n\t\t\t\t\t_attr.push( attributeData[ o ].getGroupAttrSet( groupIndex ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( _attr.length !== 0 ) {\n\n\t\t\t\t_triA.getBarycoord( clippedTri.a, _barycoordTri.a );\n\t\t\t\t_triA.getBarycoord( clippedTri.b, _barycoordTri.b );\n\t\t\t\t_triA.getBarycoord( clippedTri.c, _barycoordTri.c );\n\n\t\t\t\tfor ( let k = 0, lk = _attr.length; k < lk; k ++ ) {\n\n\t\t\t\t\tconst attrSet = _attr[ k ];\n\t\t\t\t\tconst action = _actions[ k ];\n\t\t\t\t\tconst invertTri = action === INVERT_TRI;\n\t\t\t\t\tappendAttributeFromTriangle( ia, _barycoordTri, a.geometry, a.matrixWorld, _normalMatrix, attrSet, invertedGeometry !== invertTri );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn splitIds.length;\n\n}\n\n// perform CSG operations on the set of whole triangles using a half edge structure\n// at the moment this isn't always faster due to overhead of building the half edge structure\n// and degraded connectivity due to split triangles.\n\nfunction performWholeTriangleOperations(\n\ta,\n\tb,\n\tsplitTriSet,\n\toperations,\n\tinvert,\n\tattributeData,\n\tgroupOffset = 0,\n) {\n\n\tconst invertedGeometry = a.matrixWorld.determinant() < 0;\n\n\t// matrix for transforming into the local frame of geometry b\n\t_matrix\n\t\t.copy( b.matrixWorld )\n\t\t.invert()\n\t\t.multiply( a.matrixWorld );\n\n\t_normalMatrix\n\t\t.getNormalMatrix( a.matrixWorld )\n\t\t.multiplyScalar( invertedGeometry ? - 1 : 1 );\n\n\tconst bBVH = b.geometry.boundsTree;\n\tconst groupIndices = a.geometry.groupIndices;\n\tconst aIndex = a.geometry.index;\n\tconst aAttributes = a.geometry.attributes;\n\tconst aPosition = aAttributes.position;\n\n\tconst stack = [];\n\tconst halfEdges = a.geometry.halfEdges;\n\tconst traverseSet = new Set();\n\tconst triCount = getTriCount( a.geometry );\n\tfor ( let i = 0, l = triCount; i < l; i ++ ) {\n\n\t\tif ( ! ( i in splitTriSet.intersectionSet ) ) {\n\n\t\t\ttraverseSet.add( i );\n\n\t\t}\n\n\t}\n\n\twhile ( traverseSet.size > 0 ) {\n\n\t\tconst id = getFirstIdFromSet( traverseSet );\n\t\ttraverseSet.delete( id );\n\n\t\tstack.push( id );\n\n\t\t// get the vertex indices\n\t\tconst i3 = 3 * id;\n\t\tconst i0 = aIndex.getX( i3 + 0 );\n\t\tconst i1 = aIndex.getX( i3 + 1 );\n\t\tconst i2 = aIndex.getX( i3 + 2 );\n\n\t\t// get the vertex position in the frame of geometry b so we can\n\t\t// perform hit testing\n\t\t_tri.a.fromBufferAttribute( aPosition, i0 ).applyMatrix4( _matrix );\n\t\t_tri.b.fromBufferAttribute( aPosition, i1 ).applyMatrix4( _matrix );\n\t\t_tri.c.fromBufferAttribute( aPosition, i2 ).applyMatrix4( _matrix );\n\n\t\t// get the side and decide if we need to cull the triangle based on the operation\n\t\tconst hitSide = getHitSide( _tri, bBVH );\n\n\t\t_actions.length = 0;\n\t\t_attr.length = 0;\n\t\tfor ( let o = 0, lo = operations.length; o < lo; o ++ ) {\n\n\t\t\tconst op = getOperationAction( operations[ o ], hitSide, invert );\n\t\t\tif ( op !== SKIP_TRI ) {\n\n\t\t\t\t_actions.push( op );\n\t\t\t\t_attr.push( attributeData[ o ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\twhile ( stack.length > 0 ) {\n\n\t\t\tconst currId = stack.pop();\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst sid = halfEdges.getSiblingTriangleIndex( currId, i );\n\t\t\t\tif ( sid !== - 1 && traverseSet.has( sid ) ) {\n\n\t\t\t\t\tstack.push( sid );\n\t\t\t\t\ttraverseSet.delete( sid );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( _attr.length !== 0 ) {\n\n\t\t\t\tconst i3 = 3 * currId;\n\t\t\t\tconst i0 = aIndex.getX( i3 + 0 );\n\t\t\t\tconst i1 = aIndex.getX( i3 + 1 );\n\t\t\t\tconst i2 = aIndex.getX( i3 + 2 );\n\t\t\t\tconst groupIndex = groupOffset === - 1 ? 0 : groupIndices[ currId ] + groupOffset;\n\n\t\t\t\t_tri.a.fromBufferAttribute( aPosition, i0 );\n\t\t\t\t_tri.b.fromBufferAttribute( aPosition, i1 );\n\t\t\t\t_tri.c.fromBufferAttribute( aPosition, i2 );\n\t\t\t\tif ( ! isTriDegenerate( _tri ) ) {\n\n\t\t\t\t\tfor ( let k = 0, lk = _attr.length; k < lk; k ++ ) {\n\n\t\t\t\t\t\tconst action = _actions[ k ];\n\t\t\t\t\t\tconst attrSet = _attr[ k ].getGroupAttrSet( groupIndex );\n\t\t\t\t\t\tconst invertTri = action === INVERT_TRI;\n\t\t\t\t\t\tappendAttributesFromIndices( i0, i1, i2, aAttributes, a.matrixWorld, _normalMatrix, attrSet, invertTri !== invertedGeometry );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}